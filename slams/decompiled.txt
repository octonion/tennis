package {
    import flash.events.*;
    import com.ibm.AS3util.*;
    import flash.external.*;
    import flash.display.*;

    public class Main extends Sprite {

        public static var FLASHVARS:Object;

        private var _radio:Radio;
        private var _configLocation:String;
        private var _initChannel:String;
        private var _startAudio:int;
        private var _debug:Debug;
        private var _config:Config;
        public var _numChannels:int;
        private var _startRadio:Boolean = true;

        public function Main():void{
            super();
            if (stage){
                this.init();
            } else {
                addEventListener(Event.ADDED_TO_STAGE, this.init);
            };
        }
        private function init(e:Event=null):void{
            removeEventListener(Event.ADDED_TO_STAGE, this.init);
            Debug.getInstance().debug = "true";
            this._debug = Debug.getInstance();
            this._debug.traceInfo("Start!");
            this.loadFlashvars();
        }
        private function loadFlashvars():void{
            var debug:* = null;
            var keyStr:* = null;
            var valueStr:* = null;
            this._debug.traceDebug("loadFlashvars() start");
            try {
                FLASHVARS = this.root.loaderInfo.parameters;
                for (keyStr in FLASHVARS) {
                    valueStr = String(FLASHVARS[keyStr]);
                    switch (keyStr){
                        case "initChannel":
                            this._initChannel = valueStr;
                            break;
                        case "startAudio":
                            this._startAudio = parseInt(valueStr);
                            break;
                        case "configLocation":
                            this._configLocation = valueStr;
                            break;
                        case "numChannels":
                            this._numChannels = parseInt(valueStr);
                            break;
                        case "flashDebug":
                            debug = valueStr;
                            if (debug == "false"){
                                Debug.getInstance().debug = "false";
                            };
                            break;
                        case "autoStart":
                            this._startRadio = (((valueStr == "true")) ? true : false);
                            break;
                    };
                    this._debug.traceDebug(((("Main.loadFlashvars: " + keyStr) + ":\t") + valueStr));
                };
                this._config = Config.getInstance();
                this._config.addEventListener(ConfigEvent.LOADED, this.onConfigLoaded);
                this._config.init(this._configLocation, this._numChannels);
            } catch(error:Error) {
                _debug.traceDebug(("Main.loadFlashvars: " + error));
            };
            this._debug.traceDebug("loadFlashvars() complete");
        }
        private function onConfigLoaded(e:ConfigEvent):void{
            Debug.getInstance().traceInfo("Main.onConfigLoaded");
            this._radio = new Radio(this._configLocation, this._initChannel, this._startAudio, this._startRadio, this._numChannels);
            this.addChild(this._radio);
            ExternalInterface.addCallback("startStream", this._radio.channelButtonClicked);
            ExternalInterface.addCallback("stopStream", this._radio.stopRadio);
            ExternalInterface.addCallback("volumeUp", this._radio.volumeChangeUp);
            ExternalInterface.addCallback("volumeDown", this._radio.volumeChangeDown);
            ExternalInterface.addCallback("volumeMute", this._radio.doMute);
        }

    }
}//package 
﻿package mx.core {

    public namespace mx_internal = "http://www.adobe.com/2006/flex/mx/internal";
}//package mx.core 
﻿package mx.events {
    import flash.events.*;

    public class PropertyChangeEvent extends Event {

        mx_internal static const VERSION:String = "4.6.0.23201";
        public static const PROPERTY_CHANGE:String = "propertyChange";

        public var kind:String;
        public var newValue:Object;
        public var oldValue:Object;
        public var property:Object;
        public var source:Object;

        public function PropertyChangeEvent(type:String, bubbles:Boolean=false, cancelable:Boolean=false, kind:String=null, property:Object=null, oldValue:Object=null, newValue:Object=null, source:Object=null){
            super(type, bubbles, cancelable);
            this.kind = kind;
            this.property = property;
            this.oldValue = oldValue;
            this.newValue = newValue;
            this.source = source;
        }
        public static function createUpdateEvent(source:Object, property:Object, oldValue:Object, newValue:Object):PropertyChangeEvent{
            var event:PropertyChangeEvent = new PropertyChangeEvent(PROPERTY_CHANGE);
            event.kind = PropertyChangeEventKind.UPDATE;
            event.oldValue = oldValue;
            event.newValue = newValue;
            event.source = source;
            event.property = property;
            return (event);
        }

        override public function clone():Event{
            return (new PropertyChangeEvent(type, bubbles, cancelable, this.kind, this.property, this.oldValue, this.newValue, this.source));
        }

    }
}//package mx.events 
﻿package mx.events {

    public final class PropertyChangeEventKind {

        mx_internal static const VERSION:String = "4.6.0.23201";
        public static const UPDATE:String = "update";
        public static const DELETE:String = "delete";

    }
}//package mx.events 
﻿package octoshape {
    import octoshape.*;
    import flash.events.*;
    import flash.utils.*;
    import flash.net.*;

    class SocketConnection extends EventDispatcher {

        private var nxtid:uint = 0;
        private var connected:Boolean = false;
        private var eulaStandardRequested:Boolean = false;
        private var eulaCustomRequested:Boolean = false;
        private var shutdown:Boolean = false;
        private var launcher:OctoshapeLauncher;
        private var eulaInProtocol:Boolean = false;
        private var os:OctoshapeSystemBase;
        private var eulaShowing:Boolean = false;
        private var closed:Boolean = false;
        private var readBuffer:ByteArray;
        private var socket:Socket;
        private var dict:Dictionary;

        public function SocketConnection(os:OctoshapeSystemBase, launcher:OctoshapeLauncher){
            var os:* = os;
            var launcher:* = launcher;
            readBuffer = new ByteArray();
            dict = new Dictionary();
            super();
            this.os = os;
            this.launcher = launcher;
            socket = new Socket();
            socket.addEventListener(IOErrorEvent.IO_ERROR, function (e:Event):void{
                if (!(doShutdown())){
                    return;
                };
                os.logInfo(("Got an IO_ERROR: " + e));
                dispatchEvent(ProblemList.TCP_IOERR());
            });
            socket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, function (e:Event):void{
                if (!(doShutdown())){
                    return;
                };
                os.logInfo(("Got a SECURITY_ERROR: " + e));
                dispatchEvent(ProblemList.TCP_SECURITY());
            });
            socket.addEventListener(Event.CLOSE, function (e:Event):void{
                if (!(doShutdown())){
                    return;
                };
                os.logInfo(("Got a CLOSE: " + e));
                dispatchEvent(ProblemList.TCP_CLOSED());
            });
            socket.addEventListener(Event.CONNECT, connectHandler);
            socket.addEventListener(ProgressEvent.SOCKET_DATA, dataHandler);
        }
        public function unregisterSession(id:String):void{
            dict[id] = undefined;
        }
        public function registerSession(session:SuaSession):String{
            var id:String = ("c" + nxtid++);
            dict[id] = session;
            return (id);
        }
        private function connectHandler(event:Event):void{
            os.logInfo("We are connected.");
            var x:XML = <octoshape-connect supportedversions='v3,v1' eula='true'/>
            ;
            x["@componentversion"] = Constants.version;
            if (Constants.variant != null){
                x["@variant"] = Constants.variant;
            };
            sendXml(x);
        }
        private function doShutdown():Boolean{
            if (shutdown){
                return (false);
            };
            os.logInfo("Shutsdown socket");
            shutdown = true;
            socket.close();
            return (true);
        }
        function stop():void{
            os.logInfo("stop called on socket connection");
            this.doShutdown();
        }
        public function connect(host:String, port:int, timeout:int=0):void{
            var t:* = null;
            var host:* = host;
            var port:* = port;
            var timeout:int = timeout;
            os.logInfo(((((("Tries to connect to " + host) + ":") + port) + " (2) timeout: ") + timeout));
            socket.connect(host, port);
            if (timeout > 0){
                t = new Timer(timeout, 1);
                t.addEventListener(TimerEvent.TIMER, function (e:Event):void{
                    if (!(socket.connected)){
                        if (host == "localhost"){
                            os.logInfo("We failed to connect to localhost, we're probably on vista with ipv6 setup.");
                            connect("127.0.0.1", port, 0);
                        } else {
                            if (!(doShutdown())){
                                return;
                            };
                            os.logInfo((("Connect timeout (" + timeout) + ") reached and we are not connected."));
                            dispatchEvent(ProblemList.TCP_TIMEOUT(timeout));
                        };
                    };
                });
                t.start();
            };
        }
        private function gotXml(xml:XML):void{
            var pe:ProblemEvent;
            var cmd:String;
            var status:String;
            var x:XML;
            var x1:XML;
            var x2:XML;
            var s1:String;
            var a:*;
            var b:SuaSession;
            os.logDebug(("Got xml: " + xml.toXMLString()));
            if (!(connected)){
                if (xml.name() == "octoshape-accept"){
                    connected = true;
                    if (xml["@selectedversion"] == "v3"){
                        eulaInProtocol = true;
                        return;
                    };
                    dispatchEvent(new Event(Event.CONNECT));
                } else {
                    if (!(doShutdown())){
                        return;
                    };
                    pe = new ProblemEvent();
                    if (xml.name() == "octoshape-deny"){
                        pe.setProblem(xml);
                    };
                    dispatchEvent(ProblemList.REFUSED(pe));
                };
            } else {
                if (eulaInProtocol){
                    if (xml.name() != "octoshape-eula"){
                        os.logWarning(("Expected octoshape-eula message, not " + xml));
                    } else {
                        cmd = xml["@cmd"];
                        if (cmd != "status"){
                            os.logWarning(("Expected status command, not " + cmd));
                        } else {
                            status = xml["@status"];
                            if (status == "accepted"){
                                eulaInProtocol = false;
                                if (eulaShowing){
                                    dispatchEvent(ProblemList.EULAACCEPTED());
                                };
                                dispatchEvent(new Event(Event.CONNECT));
                            } else {
                                if ((((status == "rejected")) || ((((status == "continue")) && (eulaStandardRequested))))){
                                    if (!(doShutdown())){
                                        return;
                                    };
                                    dispatchEvent(ProblemList.EULAREJECTED());
                                } else {
                                    if (status == "showing"){
                                        dispatchEvent(ProblemList.EULASHOWING());
                                        eulaShowing = true;
                                    } else {
                                        if (status == "continue"){
                                            if (!(eulaCustomRequested)){
                                                eulaCustomRequested = true;
                                                if (Constants.eulaText != null){
                                                    x1 = <octoshape-eula cmd='giveeula'/>
                                                    ;
                                                    x1.appendChild(Constants.eulaText);
                                                    sendXml(x1);
                                                    return;
                                                };
                                                if (((!((Constants.eulaPreaccept == null))) && (this.launcher.canShowEula()))){
                                                    x2 = <octoshape-eula cmd='checkaccept'/>
                                                    ;
                                                    x2.appendChild(Constants.eulaPreaccept);
                                                    sendXml(x2);
                                                    return;
                                                };
                                            };
                                            eulaStandardRequested = true;
                                            x = <octoshape-eula cmd='showbuildin'/>
                                            ;
                                            sendXml(x);
                                        };
                                    };
                                };
                            };
                        };
                    };
                } else {
                    s1 = xml["@id"];
                    a = dict[s1];
                    b = (a as SuaSession);
                    if (b != null){
                        b.xmlFromRemote(xml);
                    } else {
                        os.logInfo(("Ignores xml because we have no receiver; close called?: " + xml));
                    };
                };
            };
        }
        private function dataHandler(event:Event):void{
            var result:String;
            socket.readBytes(readBuffer, readBuffer.length);
            var i:int;
            while (i < readBuffer.length) {
                if (readBuffer[i] == 0){
                    result = readBuffer.readUTFBytes((i - readBuffer.position));
                    readBuffer.position = (i + 1);
                    gotXml(new XML(result));
                };
                i++;
            };
            var j:uint = readBuffer.position;
            while (j < readBuffer.length) {
                readBuffer[(j - readBuffer.position)] = readBuffer[j];
                j++;
            };
            readBuffer.length = (j - readBuffer.position);
            readBuffer.position = 0;
        }
        public function sendXml(xml:XML):void{
            if (shutdown){
                return;
            };
            var s:String = xml.toXMLString();
            os.logDebug(("Sends xml " + s));
            socket.writeUTFBytes(s);
            socket.writeByte(0);
            socket.flush();
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.events.*;
    import flash.utils.*;
    import flash.system.*;

    public class OctoshapeSystemBase extends EventDispatcher {

        protected var _systemSupported:Boolean;
        private var instanceId:String;
        private var statSessions:Dictionary;
        private var streamPlayers:Dictionary;
        private var superStatClient:StatSession;
        private var isOph:Boolean;
        private var launcher:OctoshapeLauncher;
        private var directStatConn:StatDirectConnection;
        private var logLevel:int = 0;
        private var currentConnection:SocketConnection;
        private var isShutdown:Boolean;
        private var busyLoop:BusyLoopDetector;
        protected var launch:Boolean = true;
        private var logFunction:Function;
        private var currentSocket:SocketConnection;
        var statlink:String;
        private var userPlayerCount:int = 0;
        private var isStarted:Boolean = false;

        public function OctoshapeSystemBase(isOph:Boolean){
            streamPlayers = new Dictionary();
            statSessions = new Dictionary();
            busyLoop = new BusyLoopDetector(3, (60 * 1000));
            super();
            _systemSupported = true;
            this.isShutdown = false;
            this.isOph = isOph;
            var min:Number = 0x10000000;
            var max:Number = 0xFFFFFFFF;
            var randNum:Number = new Number((min + Math.round((Math.random() * (max - min)))));
            this.instanceId = randNum.toString(16).toUpperCase();
            this.statlink = null;
            this.superStatClient = null;
            this.directStatConn = new StatDirectConnection(this);
        }
        public function setLog(log:Boolean, f:Function):void{
            this.logLevel = ((log) ? 2 : 0);
            this.logFunction = f;
            logInfo(("Logging is enabled; our version is " + Constants.version));
        }
        public function initializeStat(statlink1:String=null, clientSuper:Boolean=true, directSuper:Boolean=true, directLaunch:Boolean=true):void{
            var statlink1 = statlink1;
            var clientSuper:Boolean = clientSuper;
            var directSuper:Boolean = directSuper;
            var directLaunch:Boolean = directLaunch;
            if (this.isStarted){
                this.logWarning("Tried to set stat after start has been called.");
                return;
            };
            directStatConn.start(directLaunch, directSuper);
            if ((((statlink1 == null)) || ((statlink1.search(/[^A-Za-z0-9]/) >= 0)))){
                this.statlink = ("asosa" + ((isOph) ? 1 : 2));
            } else {
                this.statlink = statlink1;
            };
            if (clientSuper){
                this.superStatClient = this.statSession(this.statlink);
                this.superStatClient.addEventListener(ProblemEvent.TYPE, function (e:ProblemEvent):void{
                    logInfo(("Client stat error: " + e.toString()));
                });
            };
            this.logInfo(((((((("Initialized stat (" + this.statlink) + ") client: ") + clientSuper) + " direct: ") + directSuper) + " launch: ") + directLaunch));
        }
        public function ondemandStream(link:String, timeEventsLoop:Boolean=false, doAuthorization:Boolean=false):StreamPlayerOndemand{
            var s:StreamPlayerOndemand = new StreamPlayerOndemand(++userPlayerCount, this, link, timeEventsLoop, doAuthorization);
            streamPlayers[s] = null;
            return (s);
        }
        public function liveStream(link:String, timeEventOnNewFrame:Boolean=false, doAuthorization:Boolean=false):StreamPlayerLive{
            var s:StreamPlayerLive = new StreamPlayerLive(++userPlayerCount, this, link, timeEventOnNewFrame, doAuthorization);
            streamPlayers[s] = null;
            return (s);
        }
        function logInfo(s:String):void{
            if (logLevel >= 2){
                if (logFunction != null){
                    logFunction(s);
                } else {
                    trace(s);
                };
            };
        }
        private function updateSuperStat():void{
            this.logInfo("updating super stat ... ");
            this.directStatConn.openSuperStat();
            if (superStatClient != null){
                this.logInfo("Updating stat client session. ");
                superStatClient.updateMessage(statTag());
            };
            this.logInfo("end updating super stat");
        }
        function isOphSystem():Boolean{
            return (this.isOph);
        }
        function statTag():String{
            return (((instanceId + "-") + statlink));
        }
        public function setLogLevel(logLevel:int, f:Function):void{
            this.logLevel = logLevel;
            this.logFunction = f;
            logInfo(("Logging is enabled; our version is " + Constants.version));
        }
        public function setLaunch(launch:Boolean):void{
            this.launch = launch;
        }
        function unregister(s:EventDispatcher, isStreamPlayer:Boolean=true):void{
            if (isStreamPlayer){
                delete streamPlayers[s];
            } else {
                delete statSessions[s];
            };
        }
        protected function forcePluginReStart():int{
            return (1000);
        }
        public function systemSupported():Boolean{
            return (_systemSupported);
        }
        public function statSession(statLink:String):StatSession{
            var s:StatSession = new StatSession(++userPlayerCount, this, statLink);
            statSessions[s] = null;
            return (s);
        }
        private function socketConnectionUpdated():void{
            var x1:Object;
            var x2:Object;
            for (x1 in streamPlayers) {
                (x1 as StreamPlayer).socketConnectionUpdated();
            };
            for (x2 in statSessions) {
                (x2 as StatSession).socketConnectionUpdated();
            };
        }
        function logWarning(s:String):void{
            if (logLevel >= 1){
                logInfo(("WARNING:" + s));
            };
        }
        function getConnection(tryReestablish:Boolean):SocketConnection{
            if (this.isShutdown){
                return (null);
            };
            if (((!((currentConnection == null))) && ((launcher == null)))){
                return (currentConnection);
            };
            if (tryReestablish){
                start();
            };
            return (null);
        }
        private function closeSuperStat():void{
            this.logInfo("Closing super stat");
            directStatConn.closeSuperStat();
            if (superStatClient != null){
                superStatClient.close();
            };
        }
        public function version():String{
            return (Constants.version);
        }
        function newLauncher():OctoshapeLauncher{
            return (null);
        }
        function connectionProblem(e:ProblemEvent):void{
            var t:* = null;
            var e:* = e;
            if (this.isShutdown){
                return;
            };
            if (e.hasProblemIds("normal")){
                dispatchEvent(e);
                return;
            };
            if (launcher != null){
                logInfo(("Could not connect to plugin: " + e));
                if (launcher.startAgain()){
                    return;
                };
                launcher.close();
                launcher = null;
                currentConnection = null;
                dispatchEvent(e);
                return;
            };
            logInfo(("Connection to plugin closed with problem " + e));
            currentConnection = null;
            socketConnectionUpdated();
            if (((((!(ProblemList.IS_TCP_RETRY_PROBLEM(e))) || (!(busyLoop.probe())))) || ((this.forcePluginReStart() < 0)))){
                logInfo("We give up and pass on the problem.");
                busyLoop.reset();
                dispatchEvent(e);
            } else {
                logInfo((("We will sleep for " + forcePluginReStart()) + " millis and then make a new connection to the plugin"));
                t = new Timer(forcePluginReStart(), 1);
                t.addEventListener(TimerEvent.TIMER, function (e:Event):void{
                    logInfo("Makes a connection to the plugin after having slept");
                    start();
                });
                t.start();
            };
        }
        public function start():void{
            var thiz:* = null;
            if (isShutdown){
                return;
            };
            isStarted = true;
            thiz = this;
            if (!(_systemSupported)){
                dispatchEvent(ProblemList.INSTALL_NOTSUPPORTED());
                return;
            };
            if (((!((launcher == null))) || (!((currentConnection == null))))){
                return;
            };
            launcher = this.newLauncher();
            launcher.addEventListener(PortFoundEvent.PORT, function (e:PortFoundEvent):void{
                var e:* = e;
                currentConnection = new SocketConnection(thiz, launcher);
                currentConnection.addEventListener(ProblemEvent.TYPE, connectionProblem);
                currentConnection.addEventListener(Event.CONNECT, function (e:Event):void{
                    if (launcher != null){
                        launcher.close();
                    };
                    launcher = null;
                    logInfo("A new tcp conneciton has been established - we inform all streamplayers about it.");
                    socketConnectionUpdated();
                    dispatchEvent(ProblemList.ISCONNECTED());
                });
                if (Capabilities.os == "Windows Vista"){
                    currentConnection.connect(e.ipAddress, e.port, 5000);
                } else {
                    currentConnection.connect(e.ipAddress, e.port, e.timeout);
                };
            });
            updateSuperStat();
            launcher.start(this.directStatConn.makeLaunch());
        }
        function logDebug(s:String):void{
            if (logLevel >= 3){
                if (logFunction != null){
                    logFunction(s);
                } else {
                    trace(s);
                };
            };
        }
        function playerXML():XML{
            var playerNode:XML = <player name='player'/>
            ;
            return (playerNode);
        }
        public function close():void{
            var x1:Object;
            var x2:Object;
            this.closeSuperStat();
            this.isShutdown = true;
            for (x1 in streamPlayers) {
                (x1 as StreamPlayer).close();
            };
            for (x2 in statSessions) {
                (x2 as StatSession).close();
            };
        }

    }
}//package octoshape 
﻿package octoshape {

    class Constants {

        static const variant:String = null;
        static const eulaPreaccept:XML = null;
        static const eulaText:XML = null;
        static const logLaunchDebug:Boolean = false;
        static const version:String = "1001110";

        public function Constants(){
            super();
        }
    }
}//package octoshape 
﻿package octoshape {
    import flash.display.*;
    import flash.text.*;
    import octoshape.*;
    import flash.events.*;
    import flash.external.*;
    import flash.geom.*;

    class EulaWindow extends Sprite {

        public static const EULACLOSED:String = "octoshape.EulaClosed";

        private var realStage:Object;
        private var eulaCheckBoxNormal:Sprite;
        private var eulaURL:String = "http://www.octoshape.com/";
        private var eulaTextLink:TextField;
        private var eulaHeader:TextField;
        private var eulaBaseBox:Sprite;
        private var eulaAcceptButtonUp:Sprite;
        private var eulaAcceptButton:SimpleButton;
        private var eulaAcceptButtonDown:Sprite;
        private var eulaCheckBoxSelected:Sprite;
        private var accepted:Boolean = false;
        private var eulaCheckBox:SimpleButton;
        private var eulaTextField:TextField;
        private var eulaTextLinkSprite:Sprite;
        private var eulaRejectButton:SimpleButton;
        private var eulaRejectButtonUp:Sprite;
        private var eulaAcceptButtonDisabled:Sprite;
        private var eulaRejectButtonDown:Sprite;

        public function EulaWindow(stage:Object){
            eulaBaseBox = new Sprite();
            eulaCheckBox = new SimpleButton();
            eulaAcceptButton = new SimpleButton();
            eulaRejectButton = new SimpleButton();
            eulaTextField = new TextField();
            eulaTextLinkSprite = new Sprite();
            eulaTextLink = new TextField();
            eulaHeader = new TextField();
            eulaAcceptButtonUp = createEULAButton(16645628, 14605010, 0x666666, 0x333333, "Accept");
            eulaAcceptButtonDown = createEULAButton(13487561, 14605010, 0x333333, 0x666666, "Accept");
            eulaAcceptButtonDisabled = createEULAButton(0xFEFEFE, 0xFEFEFE, 0x999999, 0x999999, "Accept");
            eulaRejectButtonUp = createEULAButton(16645628, 14605010, 0x666666, 0x333333, "Reject");
            eulaRejectButtonDown = createEULAButton(13487561, 14605010, 0x333333, 0x666666, "Reject");
            eulaCheckBoxNormal = createCheckBox(false);
            eulaCheckBoxSelected = createCheckBox(true);
            super();
            realStage = stage;
            realStage.stage.scaleMode = StageScaleMode.NO_SCALE;
        }
        public function eulaAccepted():Boolean{
            return (accepted);
        }
        private function eulaRejectedClick(e:MouseEvent):void{
            eulaRejectButton.removeEventListener(MouseEvent.CLICK, this.eulaRejectedClick);
            eulaAcceptButton.removeEventListener(MouseEvent.CLICK, this.eulaRejectedClick);
            realStage.stage.removeChild(eulaBaseBox);
            accepted = false;
            this.dispatchEvent(new Event(EULACLOSED));
        }
        private function createEULAButton(bgColorStart:uint, bgColorEnd:uint, tlBorder:uint, brBorder:uint, str:String):Sprite{
            var eulaTextFormat:TextFormat = new TextFormat("Arial", 10);
            var button:Sprite = new Sprite();
            var matr:Matrix = new Matrix();
            matr.createGradientBox(75, 14, 1.57, 0, 0);
            button.graphics.beginGradientFill(GradientType.LINEAR, [bgColorStart, bgColorEnd], [1, 1], [0, 0xFF], matr, SpreadMethod.PAD);
            button.graphics.drawRoundRect(1, 1, 74, 13, 1);
            button.graphics.endFill();
            button.graphics.lineStyle(1, tlBorder);
            button.graphics.moveTo(0, 14);
            button.graphics.lineTo(0, 1);
            button.graphics.moveTo(1, 0);
            button.graphics.lineTo(75, 0);
            button.graphics.lineStyle(1, brBorder);
            button.graphics.moveTo(75, 1);
            button.graphics.lineTo(75, 14);
            button.graphics.moveTo(75, 14);
            button.graphics.lineTo(1, 14);
            var labelText:TextField = new TextField();
            labelText.autoSize = TextFieldAutoSize.CENTER;
            labelText.selectable = false;
            labelText.text = str;
            labelText.setTextFormat(eulaTextFormat);
            labelText.x = ((button.width / 2) - (labelText.width / 2));
            labelText.y = ((button.height / 2) - (labelText.height / 2));
            button.addChild(labelText);
            return (button);
        }
        private function createCheckBox(isChecked:Boolean=false):Sprite{
            var eulaTextFormat:TextFormat = new TextFormat("Arial", 10);
            var base:Sprite = new Sprite();
            var box:Shape = new Shape();
            box.graphics.beginFill(0xFFFFFF);
            box.graphics.lineStyle(1, 0x333333);
            box.graphics.drawRect(0, 0, 12, 12);
            if (isChecked == true){
                box.graphics.lineStyle(1, 0);
                box.graphics.moveTo(0, 0);
                box.graphics.lineTo(12, 12);
                box.graphics.moveTo(12, 0);
                box.graphics.lineTo(0, 12);
            };
            box.graphics.endFill();
            var labelText:TextField = new TextField();
            labelText.autoSize = TextFieldAutoSize.CENTER;
            labelText.selectable = false;
            labelText.text = "I accept the EULA";
            labelText.setTextFormat(eulaTextFormat);
            labelText.x = 18;
            labelText.y = -3;
            base.addChild(box);
            base.addChild(labelText);
            return (base);
        }
        private function openEula(e:MouseEvent):void{
            ExternalInterface.call("window.open", eulaURL, "win", "");
        }
        private function eulaCheckBoxClick(e:MouseEvent):void{
            if (this.eulaCheckBox.upState == eulaCheckBoxNormal){
                eulaCheckBox.upState = eulaCheckBoxSelected;
                eulaCheckBox.overState = eulaCheckBoxSelected;
                eulaCheckBox.downState = eulaCheckBoxNormal;
                eulaAcceptButton.enabled = true;
                eulaAcceptButton.upState = eulaAcceptButtonUp;
                eulaAcceptButton.overState = eulaAcceptButtonUp;
                eulaAcceptButton.addEventListener(MouseEvent.CLICK, this.eulaAcceptedClick);
            } else {
                eulaCheckBox.upState = eulaCheckBoxNormal;
                eulaCheckBox.overState = eulaCheckBoxNormal;
                eulaCheckBox.downState = eulaCheckBoxSelected;
                eulaAcceptButton.enabled = false;
                eulaAcceptButton.upState = eulaAcceptButtonDisabled;
                eulaAcceptButton.overState = eulaAcceptButtonDisabled;
                eulaAcceptButton.removeEventListener(MouseEvent.CLICK, this.eulaAcceptedClick);
            };
        }
        private function centerEula(boxW:int, boxH:int):void{
            eulaBaseBox.x = ((realStage.stage.stageWidth - boxW) / 2);
            eulaBaseBox.y = ((realStage.stage.stageHeight - boxH) / 2);
        }
        public function start():void{
            var eulaHeaderTextFormat:TextFormat = new TextFormat("Arial", 10, 0);
            var eulaTextFieldTextFormat:TextFormat = new TextFormat("Arial", 10, 0);
            var eulaTextLinkTextFormat:TextFormat = new TextFormat("Arial", 10, 0xFF);
            var boxX:int;
            var boxY:int;
            var boxW:int = 212;
            var boxH:int = 135;
            var innerBoxX:int = (boxX + 5);
            var innerBoxY:int = (boxY + 18);
            var innerBoxW:int = (boxW - 10);
            var innerBoxH:int = (boxH - 40);
            var cornerRaduis:int = 10;
            eulaBaseBox.graphics.beginFill(0xEEEEEE);
            eulaBaseBox.graphics.lineStyle(1, 0x666666);
            eulaBaseBox.graphics.drawRect(boxX, boxY, boxW, boxH);
            eulaBaseBox.graphics.beginFill(0xFFFFFF);
            eulaBaseBox.graphics.lineStyle(1, 0xCCCCCC);
            eulaBaseBox.graphics.drawRoundRect(innerBoxX, innerBoxY, innerBoxW, innerBoxH, cornerRaduis);
            eulaBaseBox.graphics.endFill();
            eulaBaseBox.graphics.endFill();
            realStage.stage.addChild(eulaBaseBox);
            eulaHeader.x = (boxX + 3);
            eulaHeader.y = boxY;
            eulaHeader.selectable = false;
            eulaHeader.text = "Octoshape EULA";
            eulaHeader.defaultTextFormat = eulaHeaderTextFormat;
            eulaBaseBox.addChild(eulaHeader);
            eulaTextField.x = (innerBoxX + 7);
            eulaTextField.y = (innerBoxY + 7);
            eulaTextField.width = (innerBoxW - 14);
            eulaTextField.wordWrap = true;
            eulaTextField.selectable = false;
            eulaTextField.defaultTextFormat = eulaTextFieldTextFormat;
            eulaTextField.text = "You need to accept the EULA to continue.";
            eulaBaseBox.addChild(eulaTextField);
            eulaTextLinkSprite.x = (innerBoxX + 7);
            eulaTextLinkSprite.y = ((innerBoxY + eulaTextField.textHeight) + 8);
            eulaTextLinkSprite.mouseChildren = false;
            eulaTextLinkSprite.useHandCursor = true;
            eulaTextLinkSprite.buttonMode = true;
            eulaTextLink.width = (innerBoxW - 14);
            eulaTextLink.height = 16;
            eulaTextLink.wordWrap = true;
            eulaTextLink.selectable = false;
            eulaTextLink.defaultTextFormat = eulaTextLinkTextFormat;
            eulaTextLink.text = "Click here to view the EULA.";
            eulaTextLinkSprite.addChild(eulaTextLink);
            eulaBaseBox.addChild(eulaTextLinkSprite);
            eulaTextLinkSprite.addEventListener(MouseEvent.CLICK, this.openEula);
            eulaAcceptButton.useHandCursor = false;
            eulaAcceptButton.upState = eulaAcceptButtonDisabled;
            eulaAcceptButton.overState = eulaAcceptButtonDisabled;
            eulaAcceptButton.downState = eulaAcceptButtonDown;
            eulaAcceptButton.hitTestState = eulaAcceptButtonUp;
            eulaAcceptButton.enabled = false;
            eulaAcceptButton.x = (((boxX + boxW) - (75 * 2)) - 13);
            eulaAcceptButton.y = ((boxY + boxH) - 18);
            eulaBaseBox.addChild(eulaAcceptButton);
            eulaRejectButton.useHandCursor = false;
            eulaRejectButton.upState = eulaRejectButtonUp;
            eulaRejectButton.overState = eulaRejectButtonUp;
            eulaRejectButton.downState = eulaRejectButtonDown;
            eulaRejectButton.hitTestState = eulaRejectButtonUp;
            eulaRejectButton.x = (((boxX + boxW) - 75) - 7);
            eulaRejectButton.y = ((boxY + boxH) - 18);
            eulaRejectButton.addEventListener(MouseEvent.CLICK, this.eulaRejectedClick);
            eulaBaseBox.addChild(eulaRejectButton);
            eulaCheckBox.useHandCursor = false;
            eulaCheckBox.upState = eulaCheckBoxNormal;
            eulaCheckBox.overState = eulaCheckBoxNormal;
            eulaCheckBox.downState = eulaCheckBoxSelected;
            eulaCheckBox.hitTestState = eulaCheckBoxNormal;
            eulaCheckBox.x = (innerBoxX + 10);
            eulaCheckBox.y = ((innerBoxY + innerBoxH) - 20);
            eulaCheckBox.addEventListener(MouseEvent.CLICK, this.eulaCheckBoxClick);
            eulaBaseBox.addChild(eulaCheckBox);
            centerEula(boxW, boxH);
        }
        private function eulaAcceptedClick(e:MouseEvent):void{
            eulaRejectButton.removeEventListener(MouseEvent.CLICK, this.eulaRejectedClick);
            eulaAcceptButton.removeEventListener(MouseEvent.CLICK, this.eulaRejectedClick);
            realStage.stage.removeChild(eulaBaseBox);
            accepted = true;
            this.dispatchEvent(new Event(EULACLOSED));
        }

    }
}//package octoshape 
﻿package octoshape {
    import octoshape.*;
    import flash.events.*;

    class ProblemList {

        public function ProblemList(){
            super();
        }
        public static function PLUGIN_LAUNCH_TIMEOUT():ProblemEvent{
            return (new ProblemEvent(null, -1018).addProblem("pluginbasic").addProblem("detection").addProblem("timeout"));
        }
        public static function TCP_TIMEOUT(timeout:int):ProblemEvent{
            return (new ProblemEvent(null, -1011).addProblem("pluginbasic").addProblem("connect").addProblem("timeout", ("" + timeout)));
        }
        public static function INSTALL_NOTSUPPORTED():ProblemEvent{
            return (new ProblemEvent(null, -1007).addProblem("pluginbasic").addProblem("install").addProblem("notsupported"));
        }
        public static function getErrorCodeOnProblemFromPm(pe:ProblemEvent):int{
            if (pe.hasProblemIds("mplayer")){
                if (pe.hasProblemIds("notconnected")){
                    return (-2001);
                };
                if (pe.hasProblemIds("nompever")){
                    return (-2002);
                };
                if (pe.hasProblemIds("nompanymore")){
                    return (-2003);
                };
                if (pe.hasProblemIds("protoerr")){
                    return (-2004);
                };
                return (-2005);
            };
            if (pe.hasProblemIds("nostream")){
                if (pe.hasProblemIds("refused")){
                    if (pe.hasProblemIds("busy")){
                        return (-2006);
                    };
                    if (pe.hasProblemIds("admin")){
                        if (pe.hasProblemIds("geofilter")){
                            return (-2007);
                        };
                        if (pe.hasProblemIds("auth")){
                            if (pe.hasProblemIds("authexpired")){
                                return (-2008);
                            };
                            return (-2009);
                        };
                        return (-2010);
                    };
                    if (pe.hasProblemIds("tooold")){
                        return (-2011);
                    };
                    return (-2012);
                };
                if (pe.hasProblemIds("capacity")){
                    if (pe.hasProblemIds("upstream")){
                        return (-2013);
                    };
                    if (pe.hasProblemIds("downstream")){
                        return (-2014);
                    };
                    if (pe.hasProblemIds("notcontributing")){
                        return (-2015);
                    };
                    return (-2016);
                };
                if (pe.hasProblemIds("firewall")){
                    return (-2017);
                };
                if (pe.hasProblemIds("noresponse")){
                    return (-2018);
                };
                return (-2019);
            };
            if (pe.hasProblemIds("exclusivename")){
                return (-2020);
            };
            if (pe.hasProblemIds("endofstream")){
                return (-2021);
            };
            if (pe.hasProblemIds("link")){
                if (pe.hasProblemIds("notfound")){
                    return (-2022);
                };
                if (pe.hasProblemIds("noresponse")){
                    return (-2023);
                };
                return (-2024);
            };
            if (pe.hasProblemIds("sessionadmin")){
                return (-2025);
            };
            if (pe.hasProblemIds("update")){
                if (pe.hasProblemIds("noresponse")){
                    return (-2026);
                };
                if (pe.hasProblemIds("diskerr")){
                    return (-2027);
                };
                return (-2028);
            };
            if (pe.hasProblemIds("pm")){
                return (-2029);
            };
            return (-2030);
        }
        public static function passEvent(passTo:EventDispatcher):Function{
            var passTo:* = passTo;
            return (function (e:Event):void{
                passTo.dispatchEvent(e);
            });
        }
        public static function EULAACCEPTED():ProblemEvent{
            return (new ProblemEvent(null, 0).addProblem("pluginbasic").addProblem("eula").addProblem("accepted").addProblem("normal"));
        }
        public static function INSTALL_CANCELED():ProblemEvent{
            return (new ProblemEvent(null, -1001).addProblem("pluginbasic").addProblem("install").addProblem("canceled"));
        }
        public static function ILLIGAL_STRING(str:String):ProblemEvent{
            return (new ProblemEvent(null, -1006).addProblem("usage").addProblem("coding").addProblem("illigalstring").setDebug(("String was: " + str)));
        }
        public static function EULASHOWING():ProblemEvent{
            return (new ProblemEvent(null, 0).addProblem("pluginbasic").addProblem("eula").addProblem("showing").addProblem("normal"));
        }
        public static function INSTALL_DISK():ProblemEvent{
            return (new ProblemEvent(null, -1002).addProblem("pluginbasic").addProblem("install").addProblem("diskerr"));
        }
        public static function EULAREJECTED():ProblemEvent{
            return (new ProblemEvent(null, -1005).addProblem("pluginbasic").addProblem("eula").addProblem("rejected"));
        }
        public static function TCP_IOERR():ProblemEvent{
            return (new ProblemEvent(null, -1009).addProblem("pluginbasic").addProblem("connect").addProblem("ioerr").setDebug("There was a generic ioerror"));
        }
        public static function INSTALL_ATTEMPT():ProblemEvent{
            return (new ProblemEvent(null, 0).addProblem("pluginbasic").addProblem("install").addProblem("attempt").addProblem("normal"));
        }
        public static function TCP_CLOSED():ProblemEvent{
            return (new ProblemEvent(null, -1012).addProblem("pluginbasic").addProblem("connect").addProblem("ioerr").setDebug("Connection closed"));
        }
        public static function LINUX_NO_PLUGIN_DETECTION():ProblemEvent{
            var p:ProblemEvent = new ProblemEvent(null, -1019).addProblem("pluginbasic").addProblem("detection").addProblem("noauto");
            p.setDebug("We have no plug-in detection on Linux. ");
            return (p);
        }
        public static function INSTALL_SUCCESSFULL():ProblemEvent{
            return (new ProblemEvent(null, 0).addProblem("pluginbasic").addProblem("install").addProblem("successfull").addProblem("normal"));
        }
        public static function INSTALL_UNDERSIZED():ProblemEvent{
            return (new ProblemEvent(null, -1004).addProblem("pluginbasic").addProblem("install").addProblem("undersized"));
        }
        public static function REFUSED(e:ProblemEvent):ProblemEvent{
            e.setErrorCode(-1013);
            return (e.addProblem("pluginbasic").addProblem("connect").addProblem("refused"));
        }
        public static function JS_ERROR(err:int):ProblemEvent{
            var p:ProblemEvent = new ProblemEvent().addProblem("pluginbasic");
            p.setErrorCode(err);
            if ((((-100 >= err)) && ((err >= -109)))){
                p.addProblem("install").addProblem("canceled").addProblem("eula");
                p.addProblem("rejected");
                p.setDebug((("User rejected the EULA (" + err) + ")"));
                return (p);
            };
            if ((((-110 >= err)) && ((err >= -119)))){
                p.addProblem("install").addProblem("canceled").addProblem("distrusted");
                p.setDebug((("User cancelled a security alert (" + err) + ")"));
                return (p);
            };
            if ((((-200 >= err)) && ((err >= -299)))){
                p.addProblem("launch").addProblem("webrefresh");
                p.setDebug((("The plug-in apears to be installed, but the user needs to refresh the webpage (" + err) + ")"));
                return (p);
            };
            if ((((-300 >= err)) && ((err >= -399)))){
                p.addProblem("launch").addProblem("pluginerror");
                p.setDebug((("User should perform manual re-install (" + err) + ")"));
                return (p);
            };
            if ((((-400 >= err)) && ((err >= -499)))){
                p.addProblem("install").addProblem("noauto");
                p.setDebug((("User should perform manual install (" + err) + ")"));
                return (p);
            };
            if ((((-500 >= err)) && ((err >= -599)))){
                p.addProblem("launch").addProblem("noauto");
                p.setDebug((("The plug-in apears to be installed, but we could not launch it (" + err) + ")"));
                return (p);
            };
            if ((((-600 >= err)) && ((err >= -699)))){
                p.addProblem("detection").addProblem("noauto");
                p.setDebug((("We have no plug-in detection available (" + err) + ")"));
                return (p);
            };
            p.addProblem("detection").addProblem("weberror");
            p.setDebug((("There was an error with web integration (" + err) + ")"));
            return (p);
        }
        public static function LAUNCH():ProblemEvent{
            return (new ProblemEvent(null, -1008).addProblem("pluginbasic").addProblem("launch"));
        }
        public static function IS_TCP_RETRY_PROBLEM(e:ProblemEvent):Boolean{
            return (e.hasProblemIds("pluginbasic", "connect", "ioerr"));
        }
        public static function sendEvent(passTo:EventDispatcher, e:Event):Function{
            var passTo:* = passTo;
            var e:* = e;
            return (function (e2:Event):void{
                passTo.dispatchEvent(e);
            });
        }
        public static function INSTALL_VERIFY():ProblemEvent{
            return (new ProblemEvent(null, -1003).addProblem("pluginbasic").addProblem("install").addProblem("verify"));
        }
        public static function TCP_SECURITY():ProblemEvent{
            return (new ProblemEvent(null, -1010).addProblem("pluginbasic").addProblem("connect").addProblem("security"));
        }
        public static function ISCONNECTED():ProblemEvent{
            return (new ProblemEvent(null, 0).addProblem("pluginbasic").addProblem("ready").addProblem("normal"));
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.events.*;
    import flash.utils.*;

    public class ProblemEvent extends Event {

        public static const TYPE:String = "ProblemEvent";
        public static const PROBLEM:String = "ProblemEvent";

        private var problems:Dictionary;
        private var errorcode:int = -1;
        private var debug:String = null;

        public function ProblemEvent(x:XML=null, errorCode:int=-2147483648){
            super(TYPE);
            setProblem(x);
            if (errorCode == int.MIN_VALUE){
                this.errorcode = ProblemList.getErrorCodeOnProblemFromPm(this);
            } else {
                this.errorcode = errorCode;
            };
        }
        public function hasProblemIds(... _args):Boolean{
            var x:String;
            for each (x in _args) {
                if (problems[x] == null){
                    return (false);
                };
            };
            return (true);
        }
        public function isEmpty():Boolean{
            var problemid:String;
            for (problemid in problems) {
                return (false);
            };
            return (true);
        }
        function setProblem(x:XML):void{
            var pitem:XML;
            var pid:String;
            var args:Array;
            var parg:XML;
            problems = new Dictionary();
            if (((!((x == null))) && (!((x.name() == "problem"))))){
                if (x.problem != null){
                    x = x.problem[0];
                };
            };
            if (x == null){
                debug = null;
                return;
            };
            debug = x["@debug"];
            if (debug == ""){
                debug = null;
            };
            if (x.name() == "problem"){
                for each (pitem in x.pitem) {
                    pid = pitem["@problemid"];
                    args = new Array();
                    for each (parg in pitem.parg) {
                        args.push(parg["@arg"]);
                    };
                    problems[pid] = args;
                };
            };
        }
        override public function toString():String{
            var problemid:String;
            var s:Array;
            var result:String = "";
            for (problemid in problems) {
                if (result != ""){
                    result = (result + ",");
                };
                result = (result + problemid);
                s = problems[problemid];
                if (s.length > 0){
                    result = (result + (("(" + s.toString()) + ")"));
                };
            };
            if (debug != null){
                result = (result + (("(" + debug) + ")"));
            };
            if (result == ""){
                return ("Unknown");
            };
            return (result);
        }
        function setDebug(debug:String):ProblemEvent{
            this.debug = debug;
            return (this);
        }
        function setErrorCode(i:int):void{
            this.errorcode = i;
        }
        public function arguments(problemId:String):Array{
            if (problems[problemId] == null){
                return (null);
            };
            return ((problems[problemId] as Array));
        }
        public function get errorCode():int{
            return (this.errorcode);
        }
        override public function clone():Event{
            var x:Object;
            var e:ProblemEvent = new ProblemEvent(null, this.errorcode);
            e.debug = debug;
            for (x in problems) {
                e.problems[x] = problems[x];
            };
            return (e);
        }
        function addProblem(problemid:String, ... _args):ProblemEvent{
            problems[problemid] = _args;
            return (this);
        }

    }
}//package octoshape 
﻿package octoshape {
    import adobe.utils.*;
    import flash.utils.*;
    import flash.events.*;
    import octoshape.*;
    import flash.system.*;

    class OctoshapeInstaller extends EventDispatcher implements OctoshapeLauncher {

        private static var startupTimes:Array = [0, 100, 150, 200, 250, 250, 300, 300, 300, -1, 0, 250, 500, 500, 500, 500, 500, 0, 250, 500, 800, 800, 800, 800, 0, 250, 500, 800, 800, 800, 800, 0, 250, 500, 800, 800, 800, 800];
        private static var ports:Array = [5861, 7194, 8536, 9699];
        private static var startupTimesEula:Array = [750, 750, 750, 750, 750, 750, 750, 0, -2];

        private var timer:Timer;
        private var waitIdx:int = 0;
        private var currentTimes:Array;
        private var octoshapeEulaShowing:ProductManager;
        private var installationIsChecked:Boolean;
        private var octoshapePort:Array;
        private var stat:StatDirectLaunchSession;
        private var octoshapeEulaRejected:ProductManager;
        private var doLaunch:Boolean;
        private var os:OctoshapeSystemBase;
        private var octoshapepm:ProductManager;
        private var stage:Object;

        public function OctoshapeInstaller(os:OctoshapeSystemBase, stage:Object, doLaunch:Boolean){
            var x:uint;
            octoshapepm = new ProductManager("octoshape");
            octoshapeEulaShowing = new ProductManager("octoshapeeulashowing");
            octoshapeEulaRejected = new ProductManager("octoshapeeularejected");
            octoshapePort = new Array();
            timer = new Timer(0);
            super();
            this.os = os;
            this.doLaunch = doLaunch;
            this.stage = stage;
            os.logInfo("Constructed OctoshapeInstall object");
            timer.addEventListener(TimerEvent.TIMER, launch);
            while (x < ports.length) {
                octoshapePort[x] = new ProductManager(("octoshapeport" + ports[x]));
                x++;
            };
        }
        private function portFound(port:uint):void{
            dispatchEvent(new PortFoundEvent(port, null));
            stat.send();
        }
        private function sendInstallErrorEvent(e:Event, errorCode:int):Function{
            var e:* = e;
            var errorCode:* = errorCode;
            return (function (e2:Event):void{
                os.dispatchEvent(e);
                stat.closeEntry("install", errorCode);
            });
        }
        private function checkInstalled():void{
            installationIsChecked = true;
            if (octoshapepm.installed){
                if (Constants.logLaunchDebug){
                    os.logInfo("Octoshape is installed.");
                };
                launch(null);
            } else {
                if (Constants.logLaunchDebug){
                    os.logInfo("Octoshape is not installed - we will try to install it");
                };
                currentTimes = startupTimes;
                waitIdx = 0;
                stat.openEntry("install");
                os.dispatchEvent(ProblemList.INSTALL_ATTEMPT());
                octoshapepm.addEventListener(Event.CANCEL, sendInstallErrorEvent(ProblemList.INSTALL_CANCELED(), -1));
                octoshapepm.addEventListener(IOErrorEvent.DISK_ERROR, sendInstallErrorEvent(ProblemList.INSTALL_DISK(), -2));
                octoshapepm.addEventListener(IOErrorEvent.VERIFY_ERROR, sendInstallErrorEvent(ProblemList.INSTALL_VERIFY(), -3));
                octoshapepm.addEventListener(ErrorEvent.ERROR, sendInstallErrorEvent(ProblemList.INSTALL_UNDERSIZED(), -4));
                octoshapepm.addEventListener(Event.COMPLETE, function (e:Event):void{
                    os.dispatchEvent(ProblemList.INSTALL_SUCCESSFULL());
                    stat.closeEntry("install", 0);
                    launch(e);
                });
                octoshapepm.download();
            };
        }
        public function showEulaWindow():EulaWindow{
            return (new EulaWindow(this.stage));
        }
        public function start(stat:StatDirectLaunchSession):void{
            this.stat = stat;
            if (!(doLaunch)){
                if (Constants.logLaunchDebug){
                    os.logInfo("Should not launch or install octoshape because of configuration");
                };
                installationIsChecked = true;
                launch(null);
                return;
            };
            if (Capabilities.version.indexOf("9,0,115") != -1){
                if (Constants.logLaunchDebug){
                    os.logInfo("We are on version 9,0,115, we will launch before checking for installation");
                };
                launch(null);
                return;
            };
            checkInstalled();
        }
        public function startAgain():Boolean{
            return (false);
        }
        public function canShowEula():Boolean{
            return (!((stage == null)));
        }
        public function close():void{
        }
        private function launch(event:Event):void{
            var i:int;
            var action:int;
            stat.openEntry("launch");
            if (octoshapepm.running){
                installationIsChecked = true;
                if (octoshapeEulaShowing.running){
                    stat.openEntry("eula");
                    if (currentTimes != startupTimesEula){
                        if (Constants.logLaunchDebug){
                            os.logInfo("The eula is showing - we will wait for it to not show any more");
                        };
                        currentTimes = startupTimesEula;
                        waitIdx = 0;
                    };
                } else {
                    if (octoshapeEulaRejected.running){
                        if (Constants.logLaunchDebug){
                            os.logInfo("The eula was rejected");
                        };
                        dispatchEvent(ProblemList.EULAREJECTED());
                        stat.closeEntry("launch", -1);
                        stat.closeEntry("eula", -1);
                        stat.send();
                        return;
                    };
                    i = 0;
                    while (i < octoshapePort.length) {
                        if (octoshapePort[i].running){
                            if (Constants.logLaunchDebug){
                                os.logInfo(("The octoshape program listens on port " + ports[i]));
                            };
                            portFound(ports[i]);
                            stat.closeEntry("launch", 0);
                            stat.send();
                            return;
                        };
                        i++;
                    };
                    if (Constants.logLaunchDebug){
                        os.logInfo("The Octoshape program is running but we do not know what it is doing");
                    };
                    setStartup();
                };
            } else {
                if (Constants.logLaunchDebug){
                    os.logInfo("The octoshape program is not running");
                };
                setStartup();
            };
            while (true) {
                if (waitIdx >= currentTimes.length){
                    if (Constants.logLaunchDebug){
                        os.logInfo("There was a problem launching the octoshape plugin");
                    };
                    dispatchEvent(ProblemList.LAUNCH());
                    stat.closeEntry("launch", -1);
                    stat.send();
                    return;
                };
                action = currentTimes[waitIdx++];
                if (action == -2){
                    waitIdx = 0;
                } else {
                    if (action == -1){
                        if (!(installationIsChecked)){
                            checkInstalled();
                            return;
                        };
                    } else {
                        if (action == 0){
                            if (doLaunch){
                                if (Constants.logLaunchDebug){
                                    os.logInfo("Launches the octoshape program");
                                };
                                octoshapepm.launch();
                            } else {
                                if (Constants.logLaunchDebug){
                                    os.logInfo("Should launch the octoshape program but does not because of configuration");
                                };
                            };
                        } else {
                            timer.reset();
                            timer.repeatCount = 1;
                            timer.delay = action;
                            timer.start();
                            return;
                        };
                    };
                };
            };
        }
        private function setStartup():void{
            if (currentTimes != startupTimes){
                currentTimes = startupTimes;
                waitIdx = 0;
            };
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.events.*;

    public class AuthRequiredEvent extends Event {

        public static const TYPE:String = "AuthRequiredEvent";
        public static const AUTHREQUIRED:String = "AuthRequiredEvent";

        private var _authid:String;

        public function AuthRequiredEvent(authid:String):void{
            super(TYPE);
            this._authid = authid;
        }
        public function authid():String{
            return (_authid);
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.events.*;

    public class UrlEvent extends Event {

        public static const TYPE:String = "UrlEvent";
        public static const URL:String = "UrlEvent";

        private var _url:String;

        public function UrlEvent(url:String):void{
            super(TYPE);
            this._url = url;
        }
        override public function clone():Event{
            return (new UrlEvent(_url));
        }
        public function get bufferTime():Number{
            return (2);
        }
        public function get url():String{
            return (_url);
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.events.*;

    public class StreamStatusEvent extends Event {

        public static const TYPE:String = "StreamStatusEvent";
        public static const STATUS:String = "StreamStatusEvent";

        var _rateset:int;
        var _stream:String;

        public function StreamStatusEvent(rateset:int, stream:String):void{
            super(TYPE);
            this._rateset = rateset;
            this._stream = stream;
        }
        public function get stream():String{
            return (_stream);
        }
        public function get bitrate():int{
            return (_rateset);
        }
        override public function clone():Event{
            return (new StreamStatusEvent(_rateset, _stream));
        }

    }
}//package octoshape 
﻿package octoshape {
    import octoshape.*;

    class StatDirectLaunchSession {

        private var idJS:String = null;
        private var attempts:Object;
        private var parent:StatDirectConnection;
        private var idRan:String = null;
        private var closed:Boolean;
        private var idCookie:String = null;

        public function StatDirectLaunchSession(makeConnection:Boolean, parent:StatDirectConnection){
            super();
            this.parent = parent;
            this.closed = !(makeConnection);
            this.attempts = new Object();
            this.log(("Created StatDirectLaunchSession. makeConnection: " + makeConnection));
        }
        function openEntry(attId:String, millis:Number=-1, name:String=null):void{
            if (this.closed){
                return;
            };
            this.log((("opening stat entry " + name) + " ."));
            if (this.attempts.hasOwnProperty(attId)){
                this.log((("Attempted to open stat entry " + name) + " but it was already open."));
                return;
            };
            var xml:XML = <launch/>
            ;
            if (name == null){
                xml["@name"] = attId;
            } else {
                xml["@name"] = name;
            };
            if (millis == -1){
                xml["@begin"] = new Date().time.toFixed(0);
            } else {
                if (millis > 0){
                    xml["@begin"] = millis.toFixed(0);
                };
            };
            this.attempts[attId] = xml;
            this.attempts.setPropertyIsEnumerable(attId, true);
        }
        function closeEntry(attId:String, result:int, end:Number=-1, name:String=null):void{
            if (this.closed){
                return;
            };
            this.log((("closing stat entry " + name) + " ."));
            if (!(this.attempts.hasOwnProperty(attId))){
                this.log((("Attempted to close stat entry " + name) + " but it was not open (we add it anyway)."));
                openEntry(attId, 0, name);
            };
            var xml:XML = this.attempts[attId];
            if (((!((xml["@result"] == null))) && ((xml.attribute("result").length() > 0)))){
                this.parent.os.logWarning(((("Attempted to close stat entry " + name) + " but it was already closed with:") + xml["@result"]));
            } else {
                xml["@end"] = end.toFixed(0);
                xml["@result"] = ("" + result);
            };
        }
        function setJsIds(ranId:String, jsId:String, cookieId:String):void{
            if (this.closed){
                return;
            };
            if (this.idRan == null){
                this.idRan = ranId;
                this.idJS = jsId;
                this.idCookie = cookieId;
            } else {
                if (this.idRan != ranId){
                    this.parent.os.logWarning(((("JS-stat error: id mis-match in ran-id: " + this.idRan) + " - ") + ranId));
                    this.closed = true;
                };
                if (this.idJS != jsId){
                    this.parent.os.logWarning(((("JS-stat error: id mis-match in js-id: " + this.idJS) + " - ") + jsId));
                    this.closed = true;
                };
                if (this.idCookie != cookieId){
                    this.parent.os.logWarning(((("JS-stat error: id mis-match in cookie-id: " + this.idCookie) + " - ") + cookieId));
                    this.closed = true;
                };
            };
        }
        function send():void{
            var i:String;
            var x:XML;
            this.log(("stat launch send called. are we closed: " + this.closed));
            if (this.closed){
                return;
            };
            this.log("Should send stat launch info.");
            var xml:XML = <launchstat/>
            ;
            if (this.idRan != null){
                xml["@jscallid"] = this.idRan;
                xml["@jsid"] = this.idJS;
                xml["@cookieid"] = this.idCookie;
            };
            for (i in this.attempts) {
                x = this.attempts[i];
                xml.appendChild(x);
            };
            parent.sendFinishedSession(xml);
        }
        private function log(s:String):void{
            parent.os.logInfo(("DIRECT-launch | " + s));
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.events.*;
    import flash.utils.*;

    public class MetaDataEvent extends Event {

        public static const TYPE:String = "MetaDataEvent";
        private static const BASE64:String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

        private var _xml:XML;
        private var _data:ByteArray;

        public function MetaDataEvent(xml:XML, payload:String):void{
            super(TYPE);
            this._xml = xml;
            if ((((payload == null)) || ((payload.length == 0)))){
                this._data = null;
            } else {
                this._data = this.decodeBase64(payload);
            };
        }
        override public function clone():Event{
            var obj:MetaDataEvent = new MetaDataEvent(_xml, null);
            obj._data = _data;
            return (obj);
        }
        public function get xml():XML{
            return (_xml);
        }
        public function get data():ByteArray{
            return (_data);
        }
        private function decodeBase64(data:String):ByteArray{
            var base64Index1:uint;
            var base64Index2:uint;
            var base64Index3:uint;
            var base64Index4:uint;
            var resultByte1:uint;
            var resultByte2:uint;
            var resultByte3:uint;
            if ((data.length % 4) != 0){
                return (null);
            };
            var result:ByteArray = new ByteArray();
            var i:int;
            while (i < data.length) {
                base64Index1 = BASE64.indexOf(data.charAt(i));
                base64Index2 = BASE64.indexOf(data.charAt((i + 1)));
                base64Index3 = BASE64.indexOf(data.charAt((i + 2)));
                base64Index4 = BASE64.indexOf(data.charAt((i + 3)));
                resultByte1 = ((base64Index1 << 2) + ((base64Index2 & 48) >> 4));
                resultByte2 = (((base64Index2 & 15) << 4) + ((base64Index3 & 60) >> 2));
                resultByte3 = (((base64Index4 & 3) << 6) + base64Index4);
                result.writeByte(resultByte1);
                if (base64Index3 != 64){
                    result.writeByte(resultByte2);
                    if (base64Index4 != 64){
                        result.writeByte(resultByte3);
                    };
                };
                i = (i + 4);
            };
            result.position = 0;
            return (result);
        }

    }
}//package octoshape 
﻿package octoshape {
    import octoshape.*;

    class SuaSession {

        private var owner:SocketConnection;
        private var isClosed:Boolean = false;
        private var id_stat:String;
        private var id:String;

        public function SuaSession(owner:SocketConnection, os:OctoshapeSystemBase, parentId:String){
            super();
            this.owner = owner;
            id = owner.registerSession(this);
            id_stat = os.statTag();
        }
        final function xmlFromRemote(xml:XML):void{
            if (isClosed){
                return;
            };
            if (xml["@cmd"] == "close"){
                close();
                eventClose(false, new ProblemEvent(xml));
            } else {
                eventXml(xml);
            };
        }
        public function sendXml(xml:XML, addStatId:Boolean=false):void{
            var ch:XML;
            if (isClosed){
                return;
            };
            xml["@id"] = id;
            if (addStatId){
                ch = <extralinkoptions/>
                ;
                ch["@statid"] = this.id_stat;
                xml.appendChild(ch);
            };
            owner.sendXml(xml);
        }
        public function eventXml(xml:XML):void{
        }
        public function eventClose(allSession:Boolean, problem:ProblemEvent):void{
        }
        public function close():void{
            if (isClosed){
                return;
            };
            sendXml(<e cmd='close'><problem/></e>
            );
            isClosed = true;
            owner.unregisterSession(id);
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.events.*;

    public class TimeEventLive extends TimeEvent {

        public static const TYPE:String = "TimeEventLive";

        public var maxLive:Number;
        public var lastFrame:Number;
        public var current:Number;

        public function TimeEventLive(x:XML){
            super(TYPE, x);
            if (x != null){
                lastFrame = x.@lastframe;
                current = x.@current;
                maxLive = x.@maxlive;
            };
        }
        override public function clone():Event{
            var ret:TimeEventLive;
            ret = new TimeEventLive(null);
            ret.wallClock = wallClock;
            ret.lastFrame = lastFrame;
            ret.current = current;
            ret.maxLive = maxLive;
            ret.id = id;
            return (ret);
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.events.*;

    public class TimeEventOndemand extends TimeEvent {

        public static const TYPE:String = "TimeEventOndemand";

        public var byteOffset:Number;
        public var currentTime:Number;
        public var startTime:Number;
        public var endTime:Number;
        public var mediaIndex:Number;
        public var promilleOffset:Number;
        public var mediaSize:Number;
        public var skippedBytes:Number;
        public var fileSize:Number;

        public function TimeEventOndemand(x:XML){
            super(TYPE, x);
            if (x != null){
                promilleOffset = getVar(x, "pm");
                endTime = getVar(x, "endtime");
                startTime = getVar(x, "starttime");
                currentTime = getVar(x, "currenttime");
                byteOffset = getVar(x, "byteoffset");
                mediaIndex = getVar(x, "mediaindex");
                mediaSize = getVar(x, "mediasize");
                fileSize = getVar(x, "filesize");
                skippedBytes = getVar(x, "skippedbytes");
            };
        }
        override public function clone():Event{
            var ret:TimeEventOndemand;
            ret = new TimeEventOndemand(null);
            ret.wallClock = wallClock;
            ret.id = id;
            ret.endTime = endTime;
            ret.promilleOffset = promilleOffset;
            ret.startTime = startTime;
            ret.currentTime = currentTime;
            ret.byteOffset = byteOffset;
            ret.mediaIndex = mediaIndex;
            ret.mediaSize = mediaSize;
            ret.fileSize = fileSize;
            ret.skippedBytes = skippedBytes;
            return (ret);
        }
        private function getVar(x:XML, name:String):Number{
            if (x.VOD[("@" + name)] == null){
                return (-1);
            };
            return (x.VOD[("@" + name)]);
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.external.*;
    import flash.system.*;
    import octoshape.*;
    import flash.events.*;
    import flash.utils.*;

    class PluginLauncherJavaScript extends EventDispatcher implements OctoshapeLauncher {

        private var superTimeOut:Timer;
        private var installVar:String;
        private var stat:StatDirectLaunchSession;
        private var runningAutoLaunch:Boolean;
        private var os:OctoshapeSystemOcto;
        private var useAutoInstall:Boolean;
        private var progress:uint;
        private var superTimeOutTime:int;

        public function PluginLauncherJavaScript(useAutoInstall:Boolean, installVar:String, os:OctoshapeSystemOcto, superTimeoutMillis:int){
            super();
            this.useAutoInstall = useAutoInstall;
            this.installVar = installVar;
            this.os = os;
            this.progress = 0;
            this.runningAutoLaunch = false;
            this.superTimeOut = null;
            this.superTimeOutTime = superTimeoutMillis;
            Security.allowDomain("www.octoshape.com");
            ExternalInterface.addCallback("octopvAS_jsreply", jsreply);
            ExternalInterface.addCallback("octopvAS_jsmessage", jsmessage);
            ExternalInterface.addCallback("octopvAS_jsstat5", jsstat5);
        }
        static function supported():Boolean{
            if (ExternalInterface.available){
                return (true);
            };
            return (false);
        }

        private function jsreply(status:int, reply:String):void{
            var xml:String;
            var pBegin:int;
            var a:String;
            var p:String;
            var port:uint;
            var pe:ProblemEvent;
            os.logInfo(("Plugin status is: " + status));
            if (status == 0){
                xml = reply;
                pBegin = xml.indexOf(":", 0);
                a = xml.substring(0, pBegin);
                p = xml.substring((pBegin + 1), xml.length);
                port = parseInt(p);
                if (a == "127.0.0.1"){
                    a = null;
                };
                this.dispatchEvent(new PortFoundEvent(port, a));
                os.logInfo("Ready to send stat direct ... ");
                stat.send();
            } else {
                pe = ProblemList.JS_ERROR(status);
                this.dispatchEvent(pe);
                stat.send();
            };
            this.runningAutoLaunch = false;
        }
        private function setSuperTimeOut():void{
            if (((!((this.superTimeOut == null))) && (this.superTimeOut.running))){
                os.logWarning("Stopping super time-out.");
                this.superTimeOut.stop();
            };
            this.superTimeOut = new Timer(this.superTimeOutTime, 1);
            this.superTimeOut.addEventListener(TimerEvent.TIMER, function (e:Event):void{
                var p:ProblemEvent;
                if (runningAutoLaunch){
                    p = ProblemList.PLUGIN_LAUNCH_TIMEOUT();
                    stat.closeEntry("timeout", -1);
                    dispatchEvent(p);
                    stat.send();
                };
            });
            os.logWarning((("Starting super time-out (" + this.superTimeOutTime) + ")."));
            stat.openEntry("timeout");
            this.superTimeOut.start();
        }
        public function showEulaWindow():EulaWindow{
            return (null);
        }
        private function getConnectUrl(useInstall:Boolean):void{
            this.setSuperTimeOut();
            os.logInfo("Getting url from JavaScript ... ");
            this.runningAutoLaunch = true;
            ExternalInterface.call("octoGetConnectUrlOsa", ExternalInterface.objectID, useInstall);
        }
        private function jsmessage(mess:String):void{
            progressStep(mess);
        }
        private function progressStep(message:String):void{
            this.progress = (this.progress + 100);
            if (this.progress == 1000){
                this.progress = 500;
            };
            this.dispatchEvent(new OctoProgressEvent(progress, message));
        }
        public function start(stat:StatDirectLaunchSession):void{
            this.stat = stat;
            var ok:String = ExternalInterface.call("octopv_fileInitFunction");
            if (ok == null){
                os.logInfo("ERROR: correct javascript not included. TODO load it now? ");
            } else {
                os.logInfo(("Correct javascript included: " + ok));
            };
            this.getConnectUrl(this.useAutoInstall);
        }
        public function abortAutoLaunch():void{
            this.runningAutoLaunch = false;
            ExternalInterface.call("octoAbortAutoLaunch");
        }
        private function progressEnd():void{
            if (progress > 0){
                this.dispatchEvent(new OctoProgressEvent(1000, ""));
                progress = 0;
            };
        }
        public function manualLaunch():void{
            this.abortAutoLaunch();
            ExternalInterface.call("octoManualLaunch");
            os.logWarning("Have done manual protocol launch. ");
            var t:* = new Timer(2000, 1);
            t.addEventListener(TimerEvent.TIMER, function (e:Event):void{
                os.logWarning("tries auto-launch again.");
                getConnectUrl(useAutoInstall);
            });
            t.start();
            os.logWarning("Now waiting 2 secs ...");
        }
        public function canShowEula():Boolean{
            return (false);
        }
        public function startAgain():Boolean{
            return (false);
        }
        private function jsstat5(attId:String, ranId:String, jsId:String, cookieId:String, millis:Number, name:String, result:int):void{
            os.logInfo(((("Got stat:" + name) + ". Is open: ") + (result == 999)));
            if (this.stat == null){
                return;
            };
            if (result == 999){
                stat.setJsIds(ranId, jsId, cookieId);
                stat.openEntry(attId, millis, name);
            } else {
                stat.closeEntry(attId, result, millis, name);
            };
        }
        public function close():void{
            this.progressEnd();
        }

    }
}//package octoshape 
﻿package octoshape {

    public class OctoshapeSystemOcto extends OctoshapeSystemBase {

        private var noJs:Boolean = false;
        private var useAutoInstall:Boolean = false;
        private var jsLauncher:PluginLauncherJavaScript = null;
        private var installVariant:String = "";
        private var forcePluginReStartVar:int;

        public function OctoshapeSystemOcto(useAutoInstall:Boolean=true){
            super(false);
            _systemSupported = ((PluginLauncherJavaScript.supported()) || (PluginLauncherLinux.supported()));
            setForceRestartPlugin(true);
            this.useAutoInstall = useAutoInstall;
        }
        public function setForceRestartPlugin(forceRestart:Boolean, delay:int=3000):void{
            this.forcePluginReStartVar = ((forceRestart) ? delay : -1);
        }
        public function abortAutoLaunch():void{
            if (this.jsLauncher != null){
                this.jsLauncher.abortAutoLaunch();
            };
        }
        public function disableAllJavaScript():void{
            noJs = true;
        }
        override function newLauncher():OctoshapeLauncher{
            var ol:OctoshapeLauncher;
            if (((PluginLauncherLinux.supported()) || (noJs))){
                if (noJs){
                    logInfo("NB: Using linux launcher (no-js).");
                };
                ol = new PluginLauncherLinux(this);
            } else {
                jsLauncher = new PluginLauncherJavaScript(this.useAutoInstall, this.installVariant, this, (30 * 1000));
                ol = jsLauncher;
            };
            ol.addEventListener(OctoProgressEvent.TYPE, this.dispatchEvent);
            ol.addEventListener(ProblemEvent.TYPE, this.dispatchEvent);
            return (ol);
        }
        public function setPluginVariant(variant:String):void{
            this.installVariant = variant;
        }
        public function useAutoInstaller():void{
            this.useAutoInstall = true;
        }
        override protected function forcePluginReStart():int{
            return (this.forcePluginReStartVar);
        }
        public function manualLaunch():void{
            if (this.jsLauncher != null){
                this.jsLauncher.manualLaunch();
            };
        }
        override function playerXML():XML{
            var playerNode:XML = <player name='flashplayer'/>
            ;
            return (playerNode);
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.events.*;

    public class StatSession extends EventDispatcher {

        var link:String;
        private var os:OctoshapeSystemBase;
        private var message:String = null;
        private var currentStat:StatSuaSession;
        private var busyLoop:BusyLoopDetector;
        private var isClosed:Boolean = false;
        var id:String;

        public function StatSession(id:int, os:OctoshapeSystemBase, link:String){
            busyLoop = new BusyLoopDetector(3, (60 * 1000));
            super();
            this.link = link;
            this.os = os;
            this.id = (id + "");
        }
        private function sendMessage2(tryReestablish:Boolean):void{
            if (isClosed){
                return;
            };
            if (this.message == null){
                return;
            };
            var socketConnection:SocketConnection = os.getConnection(tryReestablish);
            if (socketConnection == null){
                return;
            };
            if (currentStat == null){
                currentStat = new StatSuaSession(os, this, socketConnection);
            };
            currentStat.sendMessage(message);
        }
        function socketConnectionUpdated():void{
            if (isClosed){
                return;
            };
            if (currentStat != null){
                currentStat.close();
            };
            currentStat = null;
            this.sendMessage2(false);
        }
        function childIsClosed(p:ProblemEvent):void{
            currentStat = null;
            if (((p.hasProblemIds("retry")) || (p.isEmpty()))){
                if (busyLoop.probe()){
                    os.logInfo((("We got problem " + p) + " and will try to recreate session"));
                    this.sendMessage2(true);
                    return;
                };
                os.logInfo((("We got problem " + p) + " but will not try to recreate session because we are busy doing so"));
            };
            dispatchEvent(p);
        }
        public function close():void{
            if (isClosed){
                return;
            };
            isClosed = true;
            if (currentStat != null){
                currentStat.close();
                currentStat = null;
            };
            os.unregister(this, false);
        }
        public function updateMessage(message:String):void{
            if (isClosed){
                return;
            };
            if (message.search(/[^A-Za-z0-9+\/=-,]/) >= 0){
                this.dispatchEvent(ProblemList.ILLIGAL_STRING(message));
            } else {
                this.message = message;
                this.sendMessage2(true);
            };
        }

    }
}//package octoshape 
﻿package octoshape {
    import octoshape.*;
    import flash.utils.*;

    class PullSuaSession extends SuaSession {

        private static const BASE64:String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

        private var streamPlayer:StreamPlayer;
        private var playPositionLive:Number = -1;
        private var pid:String = null;
        private var waitsUrlSetup:Boolean = false;
        private var setupNext:Boolean = false;
        private var playPositionOndScale:String = null;
        private var waitsIsOpen:Boolean = true;
        private var waitsAuth:Boolean = false;
        private var playPositionOnd:Number = -1;
        private var playLatency:Number = -1;
        private var os:OctoshapeSystemBase;
        private var noInitialUrl:Boolean = false;
        private var socketConnection:SocketConnection;

        public function PullSuaSession(os:OctoshapeSystemBase, streamPlayer:StreamPlayer, socketConnection:SocketConnection){
            super(socketConnection, os, streamPlayer.id);
            this.os = os;
            this.streamPlayer = streamPlayer;
            this.socketConnection = socketConnection;
            var baseNode:XML = <e cmd='open' type='pull' supportnewurls='true' externalplayer='false' noinitialurl='true'/>
            ;
            baseNode["@unexpandedoctolink"] = streamPlayer.link;
            sendXml(baseNode, true);
        }
        public function requestTimeEvent(id:String):void{
            if (pid == null){
                return;
            };
            var x:XML = <e cmd='probetime'/>
            ;
            if (id != null){
                x.@tid = id;
            };
            x.@pid = pid;
            sendXml(x);
        }
        private function decodeBase64(data:String):ByteArray{
            var base64Index1:uint;
            var base64Index2:uint;
            var base64Index3:uint;
            var base64Index4:uint;
            var resultByte1:uint;
            var resultByte2:uint;
            var resultByte3:uint;
            if ((data.length % 4) != 0){
                return (null);
            };
            var result:ByteArray = new ByteArray();
            var i:int;
            while (i < data.length) {
                base64Index1 = BASE64.indexOf(data.charAt(i));
                base64Index2 = BASE64.indexOf(data.charAt((i + 1)));
                base64Index3 = BASE64.indexOf(data.charAt((i + 2)));
                base64Index4 = BASE64.indexOf(data.charAt((i + 3)));
                resultByte1 = ((base64Index1 << 2) + ((base64Index2 & 48) >> 4));
                resultByte2 = (((base64Index2 & 15) << 4) + ((base64Index3 & 60) >> 2));
                resultByte3 = (((base64Index4 & 3) << 6) + base64Index4);
                result.writeByte(resultByte1);
                if (base64Index2 != 64){
                    result.writeByte(resultByte2);
                    if (base64Index3 == 64){
                        result.writeByte(resultByte3);
                    };
                };
                i = (i + 4);
            };
            result.position = 0;
            return (result);
        }
        private function noPlay():Boolean{
            return ((((((this.playLatency == -1)) && ((this.playPositionLive == -1)))) && ((this.playPositionOnd == -1))));
        }
        private function doSetupUrl():void{
            if (((((((((!(setupNext)) || (waitsIsOpen))) || (waitsAuth))) || (waitsUrlSetup))) || (noPlay()))){
                return;
            };
            if (((!((pid == null))) && (!((this.playPositionOnd == -1))))){
                this.sendXml(this.getSeekXml());
                setupNext = false;
                return;
            };
            var baseNode:XML = <e cmd='setupurl'/>
            ;
            if (streamPlayer.timeEventOnNewFrame){
                baseNode.@sendtime = "true";
            };
            if (this.playLatency == 0){
            } else {
                if (this.playLatency > 0){
                    baseNode.@extralatency = this.playLatency;
                } else {
                    if (this.playPositionLive != -1){
                        baseNode.@starttime = this.playPositionLive;
                    };
                };
            };
            var playerNode:XML = os.playerXML();
            baseNode.appendChild(playerNode);
            setupNext = false;
            waitsUrlSetup = true;
            sendXml(baseNode);
        }
        private function getSeekXml():XML{
            var xml:XML = <seek/>
            ;
            if (this.pid != null){
                xml.@pid = this.pid;
            };
            xml.@cmd = "seek";
            xml.@value = this.playPositionOnd.toFixed(0);
            if (this.playPositionOnd != 0){
                xml.@scale = this.playPositionOndScale;
            };
            return (xml);
        }
        override public function eventXml(xml:XML):void{
            var bitrate:int;
            var stream:String;
            var payload64:String;
            var umetaXml:XML;
            var um:MetaDataEvent;
            var url:String;
            var x:XML;
            var url2:String;
            var pid2:String;
            if (xml["@cmd"] == "statusupdate"){
                streamPlayer.sendProgress(xml.@permille);
                return;
            };
            if (xml["@cmd"] == "statusstream"){
                bitrate = -1;
                if (((((!((xml.@rateset == null))) && (!((xml.@rateset == ""))))) && (!((xml.@rateset == "-1"))))){
                    bitrate = parseInt(xml.@rateset);
                };
                stream = "";
                if (((!((xml.@stream == null))) && (!((xml.@stream == ""))))){
                    stream = xml.@stream;
                };
                streamPlayer.sendStreamStatus(bitrate, stream);
                return;
            };
            if (xml["@cmd"] == "umeta"){
                payload64 = xml["@payload64"];
                umetaXml = null;
                if (xml.child("umeta").length() == 1){
                    umetaXml = xml.child("umeta")[0];
                };
                if (umetaXml.children().length() == 1){
                    umetaXml = umetaXml.children()[0];
                };
                um = new MetaDataEvent(umetaXml, payload64);
                this.streamPlayer.dispatchEvent(um);
                return;
            };
            if (waitsIsOpen){
                if (xml["@cmd"] != "isopen"){
                    return;
                };
                waitsIsOpen = false;
                if (streamPlayer.doAuthorization){
                    waitsAuth = true;
                    streamPlayer.dispatchEvent(new AuthRequiredEvent(xml["@authid"]));
                };
                if (((!((xml["@noinitialurl"] == null))) && ((xml["@noinitialurl"] == "true")))){
                    noInitialUrl = true;
                    os.logInfo("We are in new 'noInitialUrl' protocol");
                };
                doSetupUrl();
            } else {
                if (waitsUrlSetup){
                    if (xml["@cmd"] != "urlissetup"){
                        return;
                    };
                    url = xml["@playerurl"];
                    if (url == null){
                        if (!(noInitialUrl)){
                            return;
                        };
                    };
                    waitsUrlSetup = false;
                    if (setupNext){
                        doSetupUrl();
                    } else {
                        x = <e cmd='prepare'/>
                        ;
                        if (this.playPositionOnd > 0){
                            x.appendChild(this.getSeekXml());
                        };
                        sendXml(x);
                        if (!(noInitialUrl)){
                            streamPlayer.dispatchEvent(new UrlEvent(url));
                        };
                    };
                } else {
                    if (xml["@cmd"] == "ispreparing"){
                        pid = xml.@pid;
                        streamPlayer.playStatus(true);
                    } else {
                        if (xml["@cmd"] == "isstopped"){
                            pid = null;
                            streamPlayer.playingStopped(new ProblemEvent(xml));
                        } else {
                            if (xml.@cmd == "timeinfo"){
                                streamPlayer.dispatchTimeEvent(xml);
                            } else {
                                if (xml.@cmd == "url"){
                                    url2 = xml["@playerurl"];
                                    pid2 = xml["@pid"];
                                    if ((((url2 == null)) || ((pid2 == null)))){
                                        os.logWarning(((("PROTOCOL ERROR: url message. pid:" + pid2) + " url: ") + url2));
                                        return;
                                    };
                                    pid = pid2;
                                    os.logInfo((("Got new url " + url2) + " (not from url-is-setup)"));
                                    streamPlayer.dispatchEvent(new UrlEvent(url2));
                                    streamPlayer.playStatus(true);
                                };
                            };
                        };
                    };
                };
            };
        }
        public function setAuthInfo(authInfo:String, authHash:String):void{
            var x:XML;
            if (waitsIsOpen){
                os.logWarning("Got an setAuthInfo while waiting for an open message");
                return;
            };
            x = <e cmd='setoptions'/>
            ;
            x.@authinfo = authInfo;
            x.@authhash = authHash;
            sendXml(x);
            if (waitsAuth){
                waitsAuth = false;
                doSetupUrl();
            };
        }
        override public function eventClose(allSessions:Boolean, problem:ProblemEvent):void{
            if (allSessions){
                return;
            };
            streamPlayer.childIsClosed(problem);
        }
        function updatePlay(playLat:Number, playPosLive:Number, playPosOnd:Number, playPosOndScale:String):void{
            this.setupNext = true;
            this.playLatency = playLat;
            this.playPositionLive = playPosLive;
            this.playPositionOnd = playPosOnd;
            this.playPositionOndScale = playPosOndScale;
            doSetupUrl();
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.events.*;

    public interface OctoshapeLauncher extends IEventDispatcher {

        function start(_arg1:StatDirectLaunchSession):void;
        function showEulaWindow():EulaWindow;
        function close():void;
        function canShowEula():Boolean;
        function startAgain():Boolean;

    }
}//package octoshape 
﻿package octoshape {
    import flash.events.*;

    public class TimeEvent extends Event {

        public var id:String;
        public var wallClock:Number;

        public function TimeEvent(idStr:String, x:XML){
            super(idStr);
            if (x != null){
                wallClock = x.@wallclock;
                id = x.@tid;
            };
        }
    }
}//package octoshape 
﻿package octoshape {
    import flash.events.*;

    public class OctoProgressEvent extends Event {

        public static const TYPE:String = "OctoProgressEvent";
        public static const TYPE_SEEK:String = "OctoProgressEventSeek";
        public static const PROGRESS:String = "OctoProgressEvent";

        var _message:String;
        var _permille:uint;

        public function OctoProgressEvent(permille:uint, message:String, id:String=null):void{
            super((((id == null)) ? TYPE : id));
            this._permille = permille;
            this._message = message;
        }
        public function get message():String{
            return (_message);
        }
        public function get permille():uint{
            return (_permille);
        }
        override public function clone():Event{
            return (new OctoProgressEvent(_permille, _message));
        }

    }
}//package octoshape 
﻿package octoshape {

    public class StreamPlayerLive extends StreamPlayer {

        public function StreamPlayerLive(id:int, os:OctoshapeSystemBase, link:String, timeEventOnNewFrame:Boolean, doAuthorization:Boolean){
            super(true, id, os, link, timeEventOnNewFrame, doAuthorization);
        }
        public function playLive():void{
            playLatency(0);
        }
        public function playLatency(latency:Number):void{
            updatePlay(true, latency, -1, -1);
        }
        override function dispatchTimeEvent(xml:XML):void{
            dispatchEvent(new TimeEventLive(xml));
        }
        public function playPosition(startPosition:Number):void{
            updatePlay(true, -1, startPosition, -1);
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.events.*;

    public class StreamPlayer extends EventDispatcher {

        var link:String;
        var statUpdateInterim:int;
        private var isClosed:Boolean = false;
        private var playLivePosition:Number = -1;
        private var isProgressing:Boolean = false;
        var isLive:Boolean;
        private var playOndPositionScale:String = null;
        var timeEventOnNewFrame:Boolean;
        private var playOndPosition:Number = -1;
        var id:String;
        private var playLiveLatency:Number = -1;
        protected var os:OctoshapeSystemBase;
        protected var currentPull:PullSuaSession;
        var doAuthorization:Boolean;
        private var busyLoop:BusyLoopDetector;

        public function StreamPlayer(isLive:Boolean, id:int, os:OctoshapeSystemBase, link:String, timeEventOnNewFrame:Boolean, doAuthorization:Boolean){
            busyLoop = new BusyLoopDetector(3, (60 * 1000));
            super();
            this.link = link;
            this.id = (id + "");
            this.doAuthorization = doAuthorization;
            this.timeEventOnNewFrame = timeEventOnNewFrame;
            this.os = os;
            this.isLive = isLive;
        }
        function childIsClosed(p:ProblemEvent):void{
            finishProgress();
            currentPull = null;
            if (((p.hasProblemIds("retry")) || (p.isEmpty()))){
                if (busyLoop.probe()){
                    os.logInfo((("We got problem " + p) + " and will try to recreate session"));
                    updatePlay(true);
                    return;
                };
                os.logInfo((("We got problem " + p) + " but will not try to recreate session because we are busy doing so"));
            };
            dispatchEvent(p);
        }
        function playStatus(playing:Boolean):void{
        }
        function socketConnectionUpdated():void{
            if (isClosed){
                return;
            };
            if (currentPull != null){
                currentPull.close();
            };
            currentPull = null;
            updatePlay(false);
        }
        function sendProgress(a:int):void{
            if (a == 1000){
                isProgressing = false;
            } else {
                isProgressing = true;
            };
            dispatchEvent(new OctoProgressEvent(a, "Preparing stream"));
        }
        protected function updatePlay(tryReestablish:Boolean, playLat:Number=-2, playPosLive:Number=-2, playPosOnd:Number=-2, playPosOndScale:String=null):void{
            if (isClosed){
                return;
            };
            if (playLat != -2){
                this.playLiveLatency = playLat;
                this.playLivePosition = playPosLive;
                this.playOndPosition = playPosOnd;
                this.playOndPositionScale = playPosOndScale;
            };
            var socketConnection:SocketConnection = os.getConnection(tryReestablish);
            if (socketConnection == null){
                return;
            };
            if (currentPull == null){
                currentPull = new PullSuaSession(os, this, socketConnection);
            };
            currentPull.updatePlay(this.playLiveLatency, this.playLivePosition, this.playOndPosition, this.playOndPositionScale);
        }
        public function playAbort():void{
            if (isClosed){
                return;
            };
            updatePlay(false, -1, -1, -1);
        }
        function sendStreamStatus(bitrate:int, stream:String):void{
            dispatchEvent(new StreamStatusEvent(bitrate, stream));
        }
        private function finishProgress():void{
            if (!(isProgressing)){
                return;
            };
            isProgressing = false;
            dispatchEvent(new OctoProgressEvent(1000, "Preparing stream"));
        }
        public function setAuthorization(authInfo:String, authHash:String):void{
            if (currentPull != null){
                currentPull.setAuthInfo(authInfo, authHash);
            };
        }
        public function close():void{
            if (isClosed){
                return;
            };
            isClosed = true;
            if (currentPull != null){
                currentPull.close();
                currentPull = null;
            };
            finishProgress();
            os.unregister(this);
        }
        function dispatchTimeEvent(xml:XML):void{
        }
        public function requestTimeEvent(id:String=null):void{
            if (currentPull != null){
                currentPull.requestTimeEvent(id);
            };
        }
        function playingStopped(problem:ProblemEvent):void{
            this.playLiveLatency = -1;
            this.playLivePosition = -1;
            this.playOndPosition = -1;
            this.playOndPositionScale = null;
            this.playStatus(false);
            dispatchEvent(problem);
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.system.*;
    import adobe.utils.*;

    public class OctoshapeSystemOph extends OctoshapeSystemBase {

        private var stage:Object = null;

        public function OctoshapeSystemOph(){
            super(true);
            var os:String = Capabilities.os;
            _systemSupported = (((((((((((((((((os.indexOf("Windows NT") == -1)) && ((os.indexOf("Windows ME") == -1)))) && ((os.indexOf("Windows 98") == -1)))) && ((os.indexOf("Windows 95") == -1)))) && ((os.indexOf("Windows CE") == -1)))) && ((os.indexOf("Mac OS 10.3") == -1)))) && ((os.indexOf("Mac OS 10.2") == -1)))) && ((os.indexOf("Mac OS 10.1") == -1)))) && ((os.indexOf("Linux") == -1)));
        }
        override function newLauncher():OctoshapeLauncher{
            return (new OctoshapeInstaller(this, stage, launch));
        }
        override function playerXML():XML{
            var playerNode:XML = <player name='flashplayer'/>
            ;
            playerNode["@version"] = Capabilities.version;
            return (playerNode);
        }
        public function isInstalled():Boolean{
            var octoshapepm:ProductManager = new ProductManager("octoshape");
            return (octoshapepm.installed);
        }
        public function setStage(stage:Object):void{
            if (stage != null){
                this.stage = stage;
                logInfo("Stage has been set.");
            };
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.events.*;

    class PortFoundEvent extends Event {

        public static const PORT:String = "octoshape.PortFoundEvent";

        private var _port:uint;
        private var _timeout:int;
        private var _ipAddr:String;

        public function PortFoundEvent(port:uint, ipAddr:String, timeout:int=0):void{
            super(PORT);
            this._port = port;
            this._ipAddr = ipAddr;
            this._timeout = timeout;
        }
        public function get port():uint{
            return (_port);
        }
        public function get timeout():int{
            return (_timeout);
        }
        public function get ipAddress():String{
            return ((((_ipAddr == null)) ? "localhost" : _ipAddr));
        }
        override public function clone():Event{
            return (new PortFoundEvent(_port, _ipAddr, _timeout));
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.system.*;
    import octoshape.*;
    import flash.events.*;

    class PluginLauncherLinux extends EventDispatcher implements OctoshapeLauncher {

        private var os:OctoshapeSystemBase;
        private var noLuck:Boolean;
        private var stat:StatDirectLaunchSession;
        private var numTry:int;
        private var standardPortConnectTimeout:int;

        public function PluginLauncherLinux(os:OctoshapeSystemBase){
            super();
            this.noLuck = false;
            this.numTry = 0;
            this.standardPortConnectTimeout = 0;
            this.os = os;
        }
        static function supported():Boolean{
            return (!((Capabilities.os.toLowerCase().search("linux") == -1)));
        }

        private function tryStandardPortConnect(noLuck:Boolean, timeout:int=0):void{
            this.noLuck = noLuck;
            this.standardPortConnectTimeout = timeout;
            this.startAgain();
        }
        public function start(stat:StatDirectLaunchSession):void{
            this.stat = stat;
            tryStandardPortConnect(false);
        }
        public function close():void{
            this.dispatchEvent(new OctoProgressEvent(1000, "Connecting"));
        }
        public function canShowEula():Boolean{
            return (false);
        }
        public function startAgain():Boolean{
            if (this.noLuck){
                return (false);
            };
            numTry++;
            switch (numTry){
                case 1:
                    this.dispatchEvent(new PortFoundEvent(6498, null, this.standardPortConnectTimeout));
                    this.dispatchEvent(new OctoProgressEvent(333, "Connecting"));
                    return (true);
                case 2:
                    this.dispatchEvent(new PortFoundEvent(9498, null, this.standardPortConnectTimeout));
                    this.dispatchEvent(new OctoProgressEvent(666, "Connecting"));
                    return (true);
                default:
                    numTry = 0;
                    if (!(this.noLuck)){
                        this.dispatchEvent(ProblemList.LINUX_NO_PLUGIN_DETECTION());
                        this.noLuck = false;
                    };
                    return (false);
            };
        }
        public function showEulaWindow():EulaWindow{
            return (null);
        }

    }
}//package octoshape 
﻿package octoshape {
    import octoshape.*;
    import flash.events.*;
    import flash.net.*;
    import flash.system.*;

    class StatDirectConnection {

        private var superStatHasBeenOpened:Boolean;
        private var superStatHasBeenClosed:Boolean;
        var os:OctoshapeSystemBase;
        private var superStatId:String;
        private var enableSuperStat:Boolean;
        private var enableLaunchStat:Boolean;
        private var conn:LocalConnection;
        private var someError:Boolean;
        private var connectionId:String;

        public function StatDirectConnection(os:OctoshapeSystemBase){
            super();
            this.os = os;
            superStatHasBeenOpened = false;
            superStatHasBeenClosed = false;
            someError = false;
            connectionId = "_octoshapeOsaDirectStatId";
        }
        public function makeLaunch():StatDirectLaunchSession{
            return (new StatDirectLaunchSession(this.enableLaunchStat, this));
        }
        public function start(enableLaunchStat:Boolean, enableSuperStat:Boolean):void{
            var enableLaunchStat:* = enableLaunchStat;
            var enableSuperStat:* = enableSuperStat;
            if (conn != null){
                return;
            };
            this.enableLaunchStat = enableLaunchStat;
            this.enableSuperStat = enableSuperStat;
            log("Creating direct stat connection object. ");
            if (enableSuperStat){
                this.superStatId = ("superStatFor" + os.statlink);
            };
            if (((enableSuperStat) || (enableLaunchStat))){
                log("Making direct stat connection. ");
                conn = new LocalConnection();
                conn.addEventListener(SecurityErrorEvent.SECURITY_ERROR, function (ev:SecurityErrorEvent):void{
                    someError = true;
                    os.logWarning(("Could not connect to direct-stat obj: " + ev.text));
                });
                conn.addEventListener(StatusEvent.STATUS, function (ev:StatusEvent):void{
                    if (ev.level == "status"){
                        log("Successful connection to direct-stat obj.");
                    } else {
                        someError = true;
                        os.logWarning(("Could not connect to direct-stat obj: " + ev.level));
                    };
                });
            };
        }
        public function openSuperStat():void{
            if (conn == null){
                return;
            };
            if (((((superStatHasBeenOpened) || (!(enableSuperStat)))) || (someError))){
                return;
            };
            superStatHasBeenOpened = true;
            var xml:* = <osadirectsession/>
            ;
            xml["@osatype"] = ("" + ((os.isOphSystem()) ? 1 : 2));
            xml["@os"] = Capabilities.os;
            xml["@browser"] = "-";
            xml["@player"] = Capabilities.version;
            xml["@statid"] = os.statTag();
            xml["@statlink"] = os.statlink;
            this.log(("Direct-stat sending open session: " + xml.toString()));
            try {
                conn.send(this.connectionId, "makeOpenSession", this.superStatId, os.statlink, xml);
            } catch(err:ArgumentError) {
                this.os.logWarning(("Error sending direct-super-stat open: " + err.message));
                superStatHasBeenClosed = true;
            };
        }
        private function log(s:String):void{
            this.os.logInfo(("DIRECT-conn | " + s));
        }
        public function closeSuperStat():void{
            if (conn == null){
                return;
            };
            if (((((superStatHasBeenClosed) || (!(enableSuperStat)))) || (someError))){
                return;
            };
            superStatHasBeenClosed = true;
            this.log("Direct-stat sending close");
            try {
                conn.send(this.connectionId, "closeOpenSession", this.superStatId);
            } catch(err:ArgumentError) {
                this.os.logWarning(("Error sending direct-super-stat close: " + err.message));
            };
        }
        function sendFinishedSession(xml:XML):void{
            var xml:* = xml;
            if (conn == null){
                return;
            };
            this.log("Direct-stat sendFinishedSession called. ");
            if (someError){
                return;
            };
            this.log(("Direct-stat sending finished session: " + xml.toString()));
            try {
                conn.send(this.connectionId, "makeFinishedSession", os.statlink, xml);
            } catch(err:ArgumentError) {
                this.os.logWarning(("Error sending direct-finished-stat: " + err.message));
            };
        }

    }
}//package octoshape 
﻿package octoshape {
    import octoshape.*;

    class StatSuaSession extends SuaSession {

        private var statSession:StatSession;
        private var os:OctoshapeSystemBase;
        private var message:String = null;
        private var setupNext:Boolean = false;
        private var socketConnection:SocketConnection;
        private var waitsIsOpen:Boolean = true;

        public function StatSuaSession(os:OctoshapeSystemBase, statSession:StatSession, socketConnection:SocketConnection){
            super(socketConnection, os, statSession.id);
            this.os = os;
            this.statSession = statSession;
            this.socketConnection = socketConnection;
            var baseNode:XML = <e cmd='open' type='stat' linkdomain='statlink' supportnewurls='true'/>
            ;
            baseNode["@unexpandedoctolink"] = statSession.link;
            sendXml(baseNode, true);
        }
        private function doMessage():void{
            if (((((!(setupNext)) || (waitsIsOpen))) || ((message == null)))){
                return;
            };
            var baseNode:XML = <e cmd='set' key='osadata'/>
            ;
            baseNode["@value"] = message;
            setupNext = false;
            sendXml(baseNode);
        }
        override public function eventXml(xml:XML):void{
            if (waitsIsOpen){
                if (xml["@cmd"] != "isopen"){
                    return;
                };
                waitsIsOpen = false;
                doMessage();
            };
        }
        override public function eventClose(allSessions:Boolean, problem:ProblemEvent):void{
            if (allSessions){
                return;
            };
            statSession.childIsClosed(problem);
        }
        function sendMessage(message:String):void{
            this.setupNext = true;
            this.message = message;
            this.doMessage();
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.utils.*;
    import octoshape.*;

    class BusyLoopDetector {

        private var recentProbes:Array;
        private var maxProbes:int;
        private var inMs:int;

        public function BusyLoopDetector(maxProbes:int, inMs:int){
            recentProbes = new Array();
            super();
            this.maxProbes = maxProbes;
            this.inMs = inMs;
        }
        public function probe():Boolean{
            var now:int = getTimer();
            while ((((recentProbes.length > 0)) && (((now - recentProbes[0]) > inMs)))) {
                recentProbes.shift();
            };
            if ((recentProbes.length + 1) <= maxProbes){
                recentProbes.push(now);
                return (true);
            };
            return (false);
        }
        public function reset():void{
            recentProbes = new Array();
        }

    }
}//package octoshape 
﻿package octoshape {
    import flash.utils.*;
    import flash.events.*;

    public class StreamPlayerOndemand extends StreamPlayer {

        private const ONDEMAND_TID_FIRST:String = "octopv_ondemand_id-FIRST";

        private var playedTime:Number = 0;
        private var seekPosition:Number = 0;
        private var playbackTimer:Timer = null;
        private var firstTimeEvent:TimeEventOndemand = null;

        public function StreamPlayerOndemand(id:int, os:OctoshapeSystemBase, link:String, timeEventLoopOnPlay:Boolean, doAuthorization:Boolean){
            super(false, id, os, link, false, doAuthorization);
            if (timeEventLoopOnPlay){
                playbackTimer = new Timer(1000);
                playbackTimer.addEventListener(TimerEvent.TIMER, playbackTimerHandler);
            };
        }
        override function playStatus(playing:Boolean):void{
            if (this.playbackTimer == null){
                return;
            };
            if (((playing) && ((this.firstTimeEvent == null)))){
                os.logInfo("Sending first time-event");
                this.requestTimeEvent(ONDEMAND_TID_FIRST);
            };
            if (!(playing)){
                playbackTimer.stop();
            };
        }
        public function playFromOctoTime(startPosition:Number):void{
            playedTime = 0;
            seekPosition = 0;
            updatePlay(true, -1, -1, startPosition, "ot");
        }
        private function playbackTimerHandler(evt:TimerEvent):void{
            if (firstTimeEvent == null){
                os.logWarning("UPS: we have no fist time event!");
                return;
            };
            playedTime++;
            var duration:Number = (firstTimeEvent.endTime - firstTimeEvent.startTime);
            var latestSeekTo_millis:Number = ((duration / 1000) * seekPosition);
            var playedSinceSeek_millis:Number = (playedTime * 1000);
            var currentPos_millis:Number = (latestSeekTo_millis + playedSinceSeek_millis);
            var currentPos_promille:Number = ((currentPos_millis / duration) * 1000);
            this.dispatchEvent(new OctoProgressEvent(currentPos_promille, "update", OctoProgressEvent.TYPE_SEEK));
        }
        public function playFromPermille(startPosition:Number):void{
            playedTime = 0;
            seekPosition = startPosition;
            updatePlay(true, -1, -1, startPosition, "pm");
        }
        override function dispatchTimeEvent(xml:XML):void{
            var t:* = null;
            var tim:* = null;
            var xml:* = xml;
            if (((!((xml.@tid == undefined))) && ((xml.@tid.indexOf(ONDEMAND_TID_FIRST) == 0)))){
                if (this.firstTimeEvent == null){
                    os.logInfo("got first time event");
                    t = new TimeEventOndemand(xml);
                    os.logInfo(("t.startTime " + t.startTime));
                    os.logInfo(("t.endTime " + t.endTime));
                    if ((((t.startTime <= 0)) && ((t.endTime <= 0)))){
                        os.logWarning("Start and end time is both 0");
                        tim = new Timer(1000, 1);
                        tim.addEventListener(TimerEvent.TIMER, function (evt:TimerEvent):void{
                            if (firstTimeEvent != null){
                                return;
                            };
                            requestTimeEvent(ONDEMAND_TID_FIRST);
                        });
                        tim.start();
                    } else {
                        this.firstTimeEvent = t;
                    };
                };
            } else {
                dispatchEvent(new TimeEventOndemand(xml));
            };
        }
        public function netStatusHandler(evt:NetStatusEvent):void{
            if (this.playbackTimer == null){
                return;
            };
            if (evt.info.code == "NetStream.Play.Start"){
                playbackTimer.start();
            };
            if (evt.info.code == "NetStream.Play.Stop"){
                this.seekPosition = 0;
                this.playedTime = 0;
                playbackTimer.stop();
            };
            if (evt.info.code == "NetStream.Pause.Notify"){
                playbackTimer.stop();
            };
        }
        public function playFromBeginning():void{
            playedTime = 0;
            seekPosition = 0;
            updatePlay(true, -1, -1, 0, null);
        }

    }
}//package octoshape 
﻿package gs {
    import flash.utils.*;
    import flash.display.*;
    import flash.events.*;
    import flash.geom.*;

    public class TweenLite {

        public static var version:Number = 8.02;
        public static var killDelayedCallsTo:Function = TweenLite.killTweensOf;
        public static var defaultEase:Function = TweenLite.easeOut;
        public static var overwriteManager:Object;
        protected static var _all:Dictionary = new Dictionary();
        protected static var _curTime:uint;
        private static var _classInitted:Boolean;
        private static var _sprite:Sprite = new Sprite();
        private static var _listening:Boolean;
        private static var _timer:Timer = new Timer(2000);

        public var duration:Number;
        public var vars:Object;
        public var delay:Number;
        public var startTime:int;
        public var initTime:int;
        public var tweens:Array;
        public var target:Object;
        protected var _active:Boolean;
        protected var _subTweens:Array;
        protected var _hst:Boolean;
        protected var _hasUpdate:Boolean;
        protected var _isDisplayObject:Boolean;
        protected var _initted:Boolean;

        public function TweenLite($target:Object, $duration:Number, $vars:Object){
            var v:*;
            super();
            if ($target == null){
                return;
            };
            if (!(_classInitted)){
                _curTime = getTimer();
                _sprite.addEventListener(Event.ENTER_FRAME, executeAll);
                if (overwriteManager == null){
                    overwriteManager = {
                        mode:1,
                        enabled:false
                    };
                };
                _classInitted = true;
            };
            var mode:int = ((((($vars.overwrite == undefined)) || (((!(overwriteManager.enabled)) && (($vars.overwrite > 1)))))) ? overwriteManager.mode : int($vars.overwrite));
            if ((((_all[$target] == undefined)) || (((!(($target == null))) && ((mode == 1)))))){
                delete _all[$target];
                _all[$target] = new Dictionary(true);
            };
            _all[$target][this] = this;
            this.vars = $vars;
            this.duration = (($duration) || (0.001));
            this.delay = (($vars.delay) || (0));
            this._active = ((($duration == 0)) && ((this.delay == 0)));
            this.target = $target;
            this._isDisplayObject = ($target is DisplayObject);
            if (!((this.vars.ease is Function))){
                this.vars.ease = defaultEase;
            };
            if (this.vars.easeParams != null){
                this.vars.proxiedEase = this.vars.ease;
                this.vars.ease = this.easeProxy;
            };
            if (!(isNaN(Number(this.vars.autoAlpha)))){
                this.vars.alpha = Number(this.vars.autoAlpha);
                this.vars.visible = (this.vars.alpha > 0);
            };
            this.tweens = [];
            this._subTweens = [];
            this._hst = (this._initted = false);
            this.initTime = _curTime;
            if ((((((this.vars.runBackwards == true)) && (!((this.vars.renderOnStart == true))))) || (this._active))){
                this.initTweenVals();
                this.startTime = _curTime;
                if (this._active){
                    this.render((this.startTime + 1));
                } else {
                    this.render(this.startTime);
                };
                v = this.vars.visible;
                if (this.vars.isTV == true){
                    v = this.vars.exposedProps.visible;
                };
                if (((((!((v == null))) && ((this.vars.runBackwards == true)))) && (this._isDisplayObject))){
                    this.target.visible = Boolean(v);
                };
            };
            if (((!(_listening)) && (!(this._active)))){
                _timer.addEventListener("timer", killGarbage);
                _timer.start();
                _listening = true;
            };
        }
        public static function to($target:Object, $duration:Number, $vars:Object):TweenLite{
            return (new TweenLite($target, $duration, $vars));
        }
        public static function from($target:Object, $duration:Number, $vars:Object):TweenLite{
            $vars.runBackwards = true;
            return (new TweenLite($target, $duration, $vars));
        }
        public static function delayedCall($delay:Number, $onComplete:Function, $onCompleteParams:Array=null):TweenLite{
            return (new TweenLite($onComplete, 0, {
                delay:$delay,
                onComplete:$onComplete,
                onCompleteParams:$onCompleteParams,
                overwrite:0
            }));
        }
        public static function executeAll($e:Event=null):void{
            var a:Dictionary;
            var p:Object;
            var tw:Object;
            var t:uint = (_curTime = getTimer());
            if (_listening){
                a = _all;
                for each (p in a) {
                    for (tw in p) {
                        if (((!((p[tw] == undefined))) && (p[tw].active))){
                            p[tw].render(t);
                        };
                    };
                };
            };
        }
        public static function removeTween($t:TweenLite=null):void{
            if (((!(($t == null))) && (!((_all[$t.target] == undefined))))){
                _all[$t.target][$t] = null;
                delete _all[$t.target][$t];
            };
        }
        public static function killTweensOf($tg:Object=null, $complete:Boolean=false):void{
            var o:Object;
            var tw:*;
            if (((!(($tg == null))) && (!((_all[$tg] == undefined))))){
                if ($complete){
                    o = _all[$tg];
                    for (tw in o) {
                        o[tw].complete(false);
                    };
                };
                delete _all[$tg];
            };
        }
        public static function killGarbage($e:TimerEvent):void{
            var found:Boolean;
            var p:Object;
            var twp:Object;
            var tw:Object;
            var tg_cnt:uint;
            for (p in _all) {
                found = false;
                for (twp in _all[p]) {
                    found = true;
                    break;
                };
                if (!(found)){
                    delete _all[p];
                } else {
                    tg_cnt++;
                };
            };
            if (tg_cnt == 0){
                _timer.removeEventListener("timer", killGarbage);
                _timer.stop();
                _listening = false;
            };
        }
        public static function easeOut($t:Number, $b:Number, $c:Number, $d:Number):Number{
            $t = ($t / $d);
            return ((((-($c) * $t) * ($t - 2)) + $b));
        }
        public static function tintProxy($o:Object):void{
            var n:Number = $o.target.progress;
            var r:Number = (1 - n);
            var sc:Object = $o.info.color;
            var ec:Object = $o.info.endColor;
            $o.info.target.transform.colorTransform = new ColorTransform(((sc.redMultiplier * r) + (ec.redMultiplier * n)), ((sc.greenMultiplier * r) + (ec.greenMultiplier * n)), ((sc.blueMultiplier * r) + (ec.blueMultiplier * n)), ((sc.alphaMultiplier * r) + (ec.alphaMultiplier * n)), ((sc.redOffset * r) + (ec.redOffset * n)), ((sc.greenOffset * r) + (ec.greenOffset * n)), ((sc.blueOffset * r) + (ec.blueOffset * n)), ((sc.alphaOffset * r) + (ec.alphaOffset * n)));
        }
        public static function frameProxy($o:Object):void{
            $o.info.target.gotoAndStop(Math.round($o.target.frame));
        }
        public static function volumeProxy($o:Object):void{
            $o.info.target.soundTransform = $o.target;
        }

        public function initTweenVals($hrp:Boolean=false, $reservedProps:String=""):void{
            var p:String;
            var i:int;
            var endArray:Array;
            var clr:ColorTransform;
            var endClr:ColorTransform;
            var tp:Object;
            var v:Object = this.vars;
            if (v.isTV == true){
                v = v.exposedProps;
            };
            if (((!($hrp)) && (overwriteManager.enabled))){
                overwriteManager.manageOverwrites(v, _all[this.target]);
            };
            if ((this.target is Array)){
                endArray = ((this.vars.endArray) || ([]));
                i = 0;
                while (i < endArray.length) {
                    if (((!((this.target[i] == endArray[i]))) && (!((this.target[i] == undefined))))){
                        this.tweens[this.tweens.length] = {
                            o:this.target,
                            p:i.toString(),
                            s:this.target[i],
                            c:(endArray[i] - this.target[i]),
                            name:i.toString()
                        };
                    };
                    i++;
                };
            } else {
                if (((((!((typeof(v.tint) == "undefined"))) || ((this.vars.removeTint == true)))) && (this._isDisplayObject))){
                    clr = this.target.transform.colorTransform;
                    endClr = new ColorTransform();
                    if (v.alpha != undefined){
                        endClr.alphaMultiplier = v.alpha;
                        delete v.alpha;
                    } else {
                        endClr.alphaMultiplier = this.target.alpha;
                    };
                    if (((!((this.vars.removeTint == true))) && (((((!((v.tint == null))) && (!((v.tint == ""))))) || ((v.tint == 0)))))){
                        endClr.color = v.tint;
                    };
                    this.addSubTween("tint", tintProxy, {progress:0}, {progress:1}, {
                        target:this.target,
                        color:clr,
                        endColor:endClr
                    });
                };
                if (((!((v.frame == null))) && (this._isDisplayObject))){
                    this.addSubTween("frame", frameProxy, {frame:this.target.currentFrame}, {frame:v.frame}, {target:this.target});
                };
                if (((!(isNaN(this.vars.volume))) && (this.target.hasOwnProperty("soundTransform")))){
                    this.addSubTween("volume", volumeProxy, this.target.soundTransform, {volume:this.vars.volume}, {target:this.target});
                };
                for (p in v) {
                    if ((((((((((((((((((((((((((((((((((((p == "ease")) || ((p == "delay")))) || ((p == "overwrite")))) || ((p == "onComplete")))) || ((p == "onCompleteParams")))) || ((p == "runBackwards")))) || ((p == "visible")))) || ((p == "autoOverwrite")))) || ((p == "persist")))) || ((p == "onUpdate")))) || ((p == "onUpdateParams")))) || ((p == "autoAlpha")))) || ((p == "onStart")))) || ((p == "onStartParams")))) || ((p == "renderOnStart")))) || ((p == "proxiedEase")))) || ((p == "easeParams")))) || ((($hrp) && (!(($reservedProps.indexOf(((" " + p) + " ")) == -1))))))){
                    } else {
                        if (((!(((this._isDisplayObject) && ((((((p == "tint")) || ((p == "removeTint")))) || ((p == "frame"))))))) && (!((((p == "volume")) && (this.target.hasOwnProperty("soundTransform"))))))){
                            if (typeof(v[p]) == "number"){
                                this.tweens[this.tweens.length] = {
                                    o:this.target,
                                    p:p,
                                    s:this.target[p],
                                    c:(v[p] - this.target[p]),
                                    name:p
                                };
                            } else {
                                this.tweens[this.tweens.length] = {
                                    o:this.target,
                                    p:p,
                                    s:this.target[p],
                                    c:Number(v[p]),
                                    name:p
                                };
                            };
                        };
                    };
                };
            };
            if (this.vars.runBackwards == true){
                i = (this.tweens.length - 1);
                while (i > -1) {
                    tp = this.tweens[i];
                    tp.s = (tp.s + tp.c);
                    tp.c = (tp.c * -1);
                    i--;
                };
            };
            if ((((v.visible == true)) && (this._isDisplayObject))){
                this.target.visible = true;
            };
            if (this.vars.onUpdate != null){
                this._hasUpdate = true;
            };
            this._initted = true;
        }
        protected function addSubTween($name:String, $proxy:Function, $target:Object, $props:Object, $info:Object=null):void{
            var p:String;
            var sub:Object = {
                name:$name,
                proxy:$proxy,
                target:$target,
                info:$info
            };
            this._subTweens[this._subTweens.length] = sub;
            for (p in $props) {
                if (typeof($props[p]) == "number"){
                    this.tweens[this.tweens.length] = {
                        o:$target,
                        p:p,
                        s:$target[p],
                        c:($props[p] - $target[p]),
                        sub:sub,
                        name:$name
                    };
                } else {
                    this.tweens[this.tweens.length] = {
                        o:$target,
                        p:p,
                        s:$target[p],
                        c:Number($props[p]),
                        sub:sub,
                        name:$name
                    };
                };
            };
            this._hst = true;
        }
        public function render($t:uint):void{
            var factor:Number;
            var tp:Object;
            var i:int;
            var time:Number = (($t - this.startTime) / 1000);
            if (time >= this.duration){
                time = this.duration;
                factor = 1;
            } else {
                factor = this.vars.ease(time, 0, 1, this.duration);
            };
            i = (this.tweens.length - 1);
            while (i > -1) {
                tp = this.tweens[i];
                tp.o[tp.p] = (tp.s + (factor * tp.c));
                i--;
            };
            if (this._hst){
                i = (this._subTweens.length - 1);
                while (i > -1) {
                    this._subTweens[i].proxy(this._subTweens[i]);
                    i--;
                };
            };
            if (this._hasUpdate){
                this.vars.onUpdate.apply(null, this.vars.onUpdateParams);
            };
            if (time == this.duration){
                this.complete(true);
            };
        }
        public function complete($skipRender:Boolean=false):void{
            if (!($skipRender)){
                if (!(this._initted)){
                    this.initTweenVals();
                };
                this.startTime = (_curTime - (this.duration * 1000));
                this.render(_curTime);
                return;
            };
            if (((!((this.vars.visible == undefined))) && (this._isDisplayObject))){
                if (((!(isNaN(this.vars.autoAlpha))) && ((this.target.alpha == 0)))){
                    this.target.visible = false;
                } else {
                    if (this.vars.runBackwards != true){
                        this.target.visible = this.vars.visible;
                    };
                };
            };
            if (this.vars.persist != true){
                removeTween(this);
            };
            if (this.vars.onComplete != null){
                this.vars.onComplete.apply(null, this.vars.onCompleteParams);
            };
        }
        public function killVars($vars:Object):void{
            if (overwriteManager.enabled){
                overwriteManager.killVars($vars, this.vars, this.tweens, this._subTweens, []);
            };
        }
        protected function easeProxy($t:Number, $b:Number, $c:Number, $d:Number):Number{
            return (this.vars.proxiedEase.apply(null, arguments.concat(this.vars.easeParams)));
        }
        public function get active():Boolean{
            if (this._active){
                return (true);
            };
            if (((_curTime - this.initTime) / 1000) > this.delay){
                this._active = true;
                this.startTime = (this.initTime + (this.delay * 1000));
                if (!(this._initted)){
                    this.initTweenVals();
                } else {
                    if (((!((this.vars.visible == undefined))) && (this._isDisplayObject))){
                        this.target.visible = true;
                    };
                };
                if (this.vars.onStart != null){
                    this.vars.onStart.apply(null, this.vars.onStartParams);
                };
                if (this.duration == 0.001){
                    this.startTime = (this.startTime - 1);
                };
                return (true);
            };
            return (false);
        }

    }
}//package gs 
﻿package {
    import flash.events.*;

    public class ConfigEvent extends Event {

        public static const LOADED:String = "loaded";

        public var info:Object;

        public function ConfigEvent(type:String, info:Object){
            super(type);
            this.info = info;
        }
        override public function clone():Event{
            return (new ConfigEvent(type, this.info));
        }

    }
}//package 
﻿package {
    import flash.display.*;

    public dynamic class TimelineMarkerDVR_MC extends MovieClip {

    }
}//package 
﻿package {
    import flash.net.*;
    import flash.events.*;
    import com.ibm.AS3util.*;

    public dynamic class Config extends EventDispatcher {

        private static var _instance:Config = null;

        private var _numChannels:int;
        private var _configXML:XML;
        private var _configDataLocation:String;
        private var _configDataURL:URLRequest;
        private var _configLoader:URLLoader;
        public var radioXMLLocation:String;
        public var radioURLLocation_0:String;
        public var radioURLLocation_1:String;
        public var radioURLLocation_2:String;
        public var radioInterval:int = 60;

        public function Config(h:Function):void{
            super();
            if (h != hidden){
                throw (new Error("Singleton and can only be accessed through Singleton.getInstance()"));
            };
        }
        public static function getInstance():Config{
            if (_instance == null){
                _instance = new Config(hidden);
            };
            return (_instance);
        }
        private static function hidden():void{
        }

        public function init(configLocation:String, numChannels:int):void{
            this._numChannels = numChannels;
            this.loadConfig(configLocation);
        }
        private function loadConfig(configLocation:String):void{
            this._configXML = new XML();
            this._configDataURL = new URLRequest(configLocation);
            this._configLoader = new URLLoader(this._configDataURL);
            this._configLoader.addEventListener(IOErrorEvent.IO_ERROR, this.ioErrorHandler);
            this._configLoader.addEventListener(Event.COMPLETE, this.configXmlLoaded);
        }
        private function ioErrorHandler(e:IOErrorEvent):void{
            Debug.getInstance().traceError(("Config.ioErrorHandler: " + e.text));
        }
        private function configXmlLoaded(event:Event):void{
            var event:* = event;
            Debug.getInstance().traceInfo("Config.configXlLoaded");
            this._configLoader.removeEventListener("complete", this.configXmlLoaded);
            try {
                this._configXML = XML(this._configLoader.data);
            } catch(e:Error) {
                Debug.getInstance().traceError(("Config.configXmlLoaded: XML Error, " + e));
            };
            Debug.getInstance().traceDebug(this._configXML);
            switch (this._numChannels){
                case 1:
                    this.radioURLLocation_0 = this._configXML.radioURLLocation_0.@loc;
                    break;
                case 2:
                    this.radioURLLocation_0 = this._configXML.radioURLLocation_0.@loc;
                    this.radioURLLocation_1 = this._configXML.radioURLLocation_1.@loc;
                    break;
                case 3:
                    this.radioURLLocation_0 = this._configXML.radioURLLocation_0.@loc;
                    this.radioURLLocation_1 = this._configXML.radioURLLocation_1.@loc;
                    this.radioURLLocation_2 = this._configXML.radioURLLocation_2.@loc;
                    break;
                default:
                    Debug.getInstance().traceFatal("Invalid number of radio channels. Must be 1,2, or 3.");
            };
            this.radioXMLLocation = this._configXML.radioXMLLocation.@loc;
            this.radioInterval = parseInt(this._configXML.radioInterval.@seconds);
            var loadedEvt:* = new ConfigEvent(ConfigEvent.LOADED, new Object());
            dispatchEvent(loadedEvt);
        }

    }
}//package 
﻿package org.osmf.logging {

    public class TraceLogger extends Logger {

        private static const LEVEL_DEBUG:String = "DEBUG";
        private static const LEVEL_WARN:String = "WARN";
        private static const LEVEL_INFO:String = "INFO";
        private static const LEVEL_ERROR:String = "ERROR";
        private static const LEVEL_FATAL:String = "FATAL";

        public function TraceLogger(_arg1:String){
            super(_arg1);
        }
        override public function debug(_arg1:String, ... _args):void{
            this.logMessage(LEVEL_DEBUG, _arg1, _args);
        }
        override public function info(_arg1:String, ... _args):void{
            this.logMessage(LEVEL_INFO, _arg1, _args);
        }
        override public function warn(_arg1:String, ... _args):void{
            this.logMessage(LEVEL_WARN, _arg1, _args);
        }
        override public function error(_arg1:String, ... _args):void{
            this.logMessage(LEVEL_ERROR, _arg1, _args);
        }
        override public function fatal(_arg1:String, ... _args):void{
            this.logMessage(LEVEL_FATAL, _arg1, _args);
        }
        protected function logMessage(_arg1:String, _arg2:String, _arg3:Array):void{
            var _local4:String = "";
            _local4 = (_local4 + (((new Date().toLocaleString() + " [") + _arg1) + "] "));
            _local4 = (_local4 + ((("[" + category) + "] ") + this.applyParams(_arg2, _arg3)));
            trace(_local4);
        }
        private function applyParams(_arg1:String, _arg2:Array):String{
            var _local3:String = _arg1;
            var _local4:int = _arg2.length;
            var _local5:int;
            while (_local5 < _local4) {
                _local3 = _local3.replace(new RegExp((("\\{" + _local5) + "\\}"), "g"), _arg2[_local5]);
                _local5++;
            };
            return (_local3);
        }

    }
}//package org.osmf.logging 
﻿package org.osmf.logging {

    public class LoggerFactory {

        public function getLogger(_arg1:String):Logger{
            return (null);
        }

    }
}//package org.osmf.logging 
﻿package org.osmf.logging {
    import flash.utils.*;

    public class TraceLoggerFactory extends LoggerFactory {

        private var loggers:Dictionary;
        private var _filter:String;

        public function TraceLoggerFactory(_arg1:String=null){
            this.loggers = new Dictionary();
            this._filter = _arg1;
        }
        public function get filter():String{
            return (this._filter);
        }
        public function set filter(_arg1:String):void{
            this._filter = _arg1;
        }
        override public function getLogger(_arg1:String):Logger{
            var _local2:Logger = this.loggers[_arg1];
            if (_local2 == null){
                if (((!((this.filter == null))) && ((_arg1.indexOf(this.filter) == -1)))){
                    _local2 = new Logger(_arg1);
                } else {
                    _local2 = new TraceLogger(_arg1);
                };
                this.loggers[_arg1] = _local2;
            };
            return (_local2);
        }

    }
}//package org.osmf.logging 
﻿package org.osmf.logging {

    public class Logger {

        private var _category:String;

        public function Logger(_arg1:String){
            this._category = _arg1;
        }
        public function get category():String{
            return (this._category);
        }
        public function debug(_arg1:String, ... _args):void{
        }
        public function info(_arg1:String, ... _args):void{
        }
        public function warn(_arg1:String, ... _args):void{
        }
        public function error(_arg1:String, ... _args):void{
        }
        public function fatal(_arg1:String, ... _args):void{
        }

    }
}//package org.osmf.logging 
﻿package org.osmf.logging {

    public class Log {

        private static var _loggerFactory:LoggerFactory;

        public static function get loggerFactory():LoggerFactory{
            return (_loggerFactory);
        }
        public static function set loggerFactory(_arg1:LoggerFactory):void{
            _loggerFactory = _arg1;
        }
        public static function getLogger(_arg1:String):Logger{
            if (_loggerFactory == null){
                _loggerFactory = new TraceLoggerFactory();
            };
            return (((_loggerFactory)==null) ? null : _loggerFactory.getLogger(_arg1));
        }

    }
}//package org.osmf.logging 
﻿package org.osmf.media {
    import __AS3__.vec.*;
    import flash.utils.*;

    public class MediaResourceBase {

        private var _metadata:Dictionary;
        private var _mediaType:String;
        private var _mimeType:String;

        public function get mediaType():String{
            return (this._mediaType);
        }
        public function set mediaType(_arg1:String):void{
            this._mediaType = _arg1;
        }
        public function get mimeType():String{
            return (this._mimeType);
        }
        public function set mimeType(_arg1:String):void{
            this._mimeType = _arg1;
        }
        public function get metadataNamespaceURLs():Vector.<String>{
            var _local2:String;
            var _local1:Vector.<String> = new Vector.<String>();
            if (this._metadata != null){
                for (_local2 in this._metadata) {
                    _local1.push(_local2);
                };
            };
            return (_local1);
        }
        public function addMetadataValue(_arg1:String, _arg2:Object):void{
            if (this._metadata == null){
                this._metadata = new Dictionary();
            };
            this._metadata[_arg1] = _arg2;
        }
        public function getMetadataValue(_arg1:String):Object{
            if (this._metadata != null){
                return (this._metadata[_arg1]);
            };
            return (null);
        }
        public function removeMetadataValue(_arg1:String):Object{
            var _local2:Object;
            if (this._metadata != null){
                _local2 = this._metadata[_arg1];
                delete this._metadata[_arg1];
                return (_local2);
            };
            return (null);
        }

    }
}//package org.osmf.media 
﻿package org.osmf.media {

    public class URLResource extends MediaResourceBase {

        private var _url:String;

        public function URLResource(_arg1:String){
            this._url = _arg1;
        }
        public function get url():String{
            return (this._url);
        }

    }
}//package org.osmf.media 
﻿package org.osmf.utils {

    public class URL {

        private var _rawUrl:String;
        private var _protocol:String;
        private var _userInfo:String;
        private var _host:String;
        private var _port:String;
        private var _path:String;
        private var _query:String;
        private var _fragment:String;

        public function URL(_arg1:String){
            this._rawUrl = _arg1;
            this._protocol = "";
            this._userInfo = "";
            this._host = "";
            this._port = "";
            this._path = "";
            this._query = "";
            this._fragment = "";
            if (((!((this._rawUrl == null))) && ((this._rawUrl.length > 0)))){
                this._rawUrl = this._rawUrl.replace(/^\s+|\s+$/g, "");
                this.parseUrl();
            };
        }
        public function get rawUrl():String{
            return (this._rawUrl);
        }
        public function get protocol():String{
            return (this._protocol);
        }
        public function set protocol(_arg1:String):void{
            if (_arg1 != null){
                this._protocol = _arg1.replace(/:\/?\/?$/, "");
                this._protocol = this._protocol.toLowerCase();
            };
        }
        public function get userInfo():String{
            return (this._userInfo);
        }
        public function set userInfo(_arg1:String):void{
            if (_arg1 != null){
                this._userInfo = _arg1.replace(/@$/, "");
            };
        }
        public function get host():String{
            return (this._host);
        }
        public function set host(_arg1:String):void{
            this._host = _arg1;
        }
        public function get port():String{
            return (this._port);
        }
        public function set port(_arg1:String):void{
            if (_arg1 != null){
                this._port = _arg1.replace(/(:)/, "");
            };
        }
        public function get path():String{
            return (this._path);
        }
        public function set path(_arg1:String):void{
            if (_arg1 != null){
                this._path = _arg1.replace(/^\//, "");
            };
        }
        public function get query():String{
            return (this._query);
        }
        public function set query(_arg1:String):void{
            if (_arg1 != null){
                this._query = _arg1.replace(/^\?/, "");
            };
        }
        public function get fragment():String{
            return (this._fragment);
        }
        public function set fragment(_arg1:String):void{
            if (_arg1 != null){
                this._fragment = _arg1.replace(/^#/, "");
            };
        }
        public function toString():String{
            return (this._rawUrl);
        }
        public function getParamValue(_arg1:String):String{
            if (this._query == null){
                return ("");
            };
            var _local2:RegExp = new RegExp((("[/?&]*" + _arg1) + "=([^&#]*)"), "i");
            var _local3:Array = this._query.match(_local2);
            var _local4:String = ((_local3)==null) ? "" : _local3[1];
            return (_local4);
        }
        public function get absolute():Boolean{
            return (!((this.protocol == "")));
        }
        public function get extension():String{
            var _local1:int = this.path.lastIndexOf(".");
            if (_local1 != -1){
                return (this.path.substr((_local1 + 1)));
            };
            return ("");
        }
        private function parseUrl():void{
            var _local1:RegExp;
            var _local2:Array;
            var _local3:String;
            var _local4:RegExp;
            var _local5:Array;
            var _local6:String;
            if ((((this._rawUrl == null)) || ((this._rawUrl.length == 0)))){
                return;
            };
            if ((((this._rawUrl.search(/:\//) == -1)) && (!((this._rawUrl.indexOf(":") == (this._rawUrl.length - 1)))))){
                this.path = this._rawUrl;
            } else {
                _local1 = /^(rtmp|rtmp[tse]|rtmpte)(:\/[^\/])/i;
                _local2 = this._rawUrl.match(_local1);
                _local3 = this._rawUrl;
                if (_local2 != null){
                    _local3 = this._rawUrl.replace(/:\//, "://localhost/");
                };
                _local4 = /^([a-z+\w\+\.\-]+:\/?\/?)?([^\/?#]*)?(\/[^?#]*)?(\?[^#]*)?(\#.*)?/i;
                _local5 = _local3.match(_local4);
                if (_local5 != null){
                    this.protocol = _local5[1];
                    _local6 = _local5[2];
                    this.path = _local5[3];
                    this.query = _local5[4];
                    this.fragment = _local5[5];
                    _local4 = /^([!-~]+@)?([^\/?#:]*)(:[\d]*)?/i;
                    _local5 = _local6.match(_local4);
                    if (_local5 != null){
                        this.userInfo = _local5[1];
                        this.host = _local5[2];
                        this.port = _local5[3];
                    };
                };
            };
        }

    }
}//package org.osmf.utils 
﻿package org.openvideoplayer.utilities {

    public class StringUtil {

        public static function trim(_arg1:String):String{
            if (_arg1 == null){
                return ("");
            };
            var _local2:int;
            while (isWhitespace(_arg1.charAt(_local2))) {
                _local2++;
            };
            var _local3:int = (_arg1.length - 1);
            while (isWhitespace(_arg1.charAt(_local3))) {
                _local3--;
            };
            if (_local3 >= _local2){
                return (_arg1.slice(_local2, (_local3 + 1)));
            };
            return ("");
        }
        public static function trimArrayElements(_arg1:String, _arg2:String):String{
            var _local3:Array;
            var _local4:int;
            var _local5:int;
            if (((!((_arg1 == ""))) && (!((_arg1 == null))))){
                _local3 = _arg1.split(_arg2);
                _local4 = _local3.length;
                _local5 = 0;
                while (_local5 < _local4) {
                    _local3[_local5] = StringUtil.trim(_local3[_local5]);
                    _local5++;
                };
                if (_local4 > 0){
                    _arg1 = _local3.join(_arg2);
                };
            };
            return (_arg1);
        }
        public static function isWhitespace(_arg1:String):Boolean{
            switch (_arg1){
                case " ":
                case "\t":
                case "\r":
                case "\n":
                case "\f":
                    return (true);
                default:
                    return (false);
            };
        }
        public static function substitute(_arg1:String, ... _args):String{
            var _local4:Array;
            if (_arg1 == null){
                return ("");
            };
            var _local3:uint = _args.length;
            if ((((_local3 == 1)) && ((_args[0] is Array)))){
                _local4 = (_args[0] as Array);
                _local3 = _local4.length;
            } else {
                _local4 = _args;
            };
            var _local5:int;
            while (_local5 < _local3) {
                _arg1 = _arg1.replace(new RegExp((("\\{" + _local5) + "\\}"), "g"), _local4[_local5]);
                _local5++;
            };
            return (_arg1);
        }
        public static function addPrefix(_arg1:String):String{
            var _local2:String;
            var _local3:String;
            var _local5:String;
            var _local8:uint;
            var _local4:int = _arg1.lastIndexOf(".");
            var _local6:Array = new Array();
            _local6 = [{
                ext:"mp3",
                prefix:"mp3"
            }, {
                ext:"mp4",
                prefix:"mp4"
            }, {
                ext:"m4v",
                prefix:"mp4"
            }, {
                ext:"f4v",
                prefix:"mp4"
            }, {
                ext:"3gpp",
                prefix:"mp4"
            }, {
                ext:"mov",
                prefix:"mp4"
            }];
            if (_local4 == -1){
                return (_arg1);
            };
            _local3 = _arg1.slice((_local4 + 1));
            _local3 = _local3.toLocaleLowerCase();
            _local4 = _arg1.indexOf(":");
            if (_local4 == 3){
                return (_arg1);
            };
            var _local7:String = _arg1;
            if (_local4 == -1){
                _local8 = 0;
                while (_local8 < _local6.length) {
                    if (_local3 == _local6[_local8].ext){
                        _local7 = ((_local6[_local8].prefix + ":") + _arg1);
                        break;
                    };
                    _local8++;
                };
            };
            return (_local7);
        }

    }
}//package org.openvideoplayer.utilities 
﻿package org.openvideoplayer.utilities {

    public class TimeUtil {

        public static function timeCode(_arg1:Number):String{
            var _local2:Number = Math.floor((_arg1 / 3600));
            var _local3:Number = Math.floor(((_arg1 % 3600) / 60));
            var _local4:Number = Math.floor(((_arg1 % 3600) % 60));
            return (((((((_local2 == 0)) ? "" : (((_local2 < 10)) ? (("0" + _local2.toString()) + ":") : (_local2.toString() + ":"))) + (((_local3 < 10)) ? ("0" + _local3.toString()) : _local3.toString())) + ":") + (((_local4 < 10)) ? ("0" + _local4.toString()) : _local4.toString())));
        }
        public static function parseTime(_arg1:String):Number{
            var _local4:int;
            var _local2:Number = 0;
            var _local3:Array = _arg1.split(":");
            if (_local3.length > 1){
                _local2 = (_local3[0] * 3600);
                _local2 = (_local2 + (_local3[1] * 60));
                _local2 = (_local2 + Number(_local3[2]));
            } else {
                _local4 = 0;
                switch (_arg1.charAt((_arg1.length - 1))){
                    case "h":
                        _local4 = 3600;
                        break;
                    case "m":
                        _local4 = 60;
                        break;
                    case "s":
                        _local4 = 1;
                        break;
                };
                if (_local4){
                    _local2 = (Number(_arg1.substr(0, (_arg1.length - 1))) * _local4);
                } else {
                    _local2 = Number(_arg1);
                };
            };
            return (_local2);
        }

    }
}//package org.openvideoplayer.utilities 
﻿package org.openvideoplayer.utilities {
    import flash.system.*;

    public class FlashPlayer {

        public static function version(_arg1:Object):void{
            var _local2:String = Capabilities.version;
            var _local3:Array = _local2.split(",");
            var _local4:Array = _local3[0].split(" ");
            _arg1.os = _local4[0];
            _arg1.major = parseInt(_local4[1]);
            _arg1.minor = parseInt(_local3[1]);
            _arg1.build = parseInt(_local3[2]);
        }

    }
}//package org.openvideoplayer.utilities 
﻿package org.openvideoplayer.parsers {
    import org.openvideoplayer.net.dynamicstream.*;
    import org.openvideoplayer.events.*;
    import org.openvideoplayer.utilities.*;

    public class DynamicSmilParser extends ParserBase {

        private var _hostName:String;
        private var _streamName:String;
        private var _dsi:DynamicStreamItem;
        private var _protocol:String;

        public function DynamicSmilParser():void{
        }
        public function get streamName():String{
            return (this._streamName);
        }
        public function get hostName():String{
            return (this._hostName);
        }
        public function get dsi():DynamicStreamItem{
            return (this._dsi);
        }
        public function get protocol():String{
            return (this._protocol);
        }
        override protected function parseXML():void{
            var _local1:Namespace;
            if (!(this.verifySMIL(_xml))){
                dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.XML_BOSS_MALFORMED)));
            } else {
                _local1 = _xml.namespace();
                this._hostName = _xml._local1::head._local1::meta.@base.slice((_xml._local1::head._local1::meta.@base.indexOf("://") + 3));
                this._protocol = _xml._local1::head._local1::meta.@base.slice(0, _xml._local1::head._local1::meta.@base.indexOf("://")).toLowerCase();
                this._dsi = this.parseDsi(_xml);
                this._streamName = this._dsi.streams[0].name;
                dispatchEvent(new OvpEvent(OvpEvent.PARSED));
            };
            _busy = false;
        }
        private function verifySMIL(_arg1:XML):Boolean{
            var _local2:Namespace = _arg1.namespace();
            var _local3:Boolean;
            if (_arg1._local2::body_local2::["switch"] != undefined){
                _local3 = !((((_arg1._local2::head._local2::meta.@base == undefined)) || ((_arg1._local2::body_local2::["switch"]._local2::video.length() < 1))));
            };
            return (_local3);
        }
        private function parseDsi(_arg1:XML):DynamicStreamItem{
            var _local5:String;
            var _local6:Number;
            var _local7:Number;
            var _local8:Number;
            var _local9:String;
            var _local2:Namespace = _arg1.namespace();
            var _local3:DynamicStreamItem = new DynamicStreamItem();
            var _local4:uint;
            while (_local4 < _arg1._local2::body_local2::["switch"]._local2::video.length()) {
                _local5 = _arg1._local2::body_local2::["switch"]._local2::video[_local4].@src;
                _local5 = StringUtil.addPrefix(_local5);
                _local6 = (Number(_arg1._local2::body_local2::["switch"]._local2::video[_local4].@["system-bitrate"]) / 1000);
                _local7 = NaN;
                _local8 = NaN;
                _local9 = String(_arg1._local2::body_local2::["switch"]._local2::video[_local4].@["clipBegin"]);
                if (((!((_local9 == null))) && ((_local9.length > 0)))){
                    _local7 = TimeUtil.parseTime(_local9);
                };
                _local9 = String(_arg1._local2::body_local2::["switch"]._local2::video[_local4].@["clipEnd"]);
                if (((!((_local9 == null))) && ((_local9.length > 0)))){
                    _local8 = TimeUtil.parseTime(_local9);
                };
                _local3.addStream(_local5, _local6);
                if (!(isNaN(_local7))){
                    _local3.start = _local7;
                };
                if (!(isNaN(_local8))){
                    _local3.len = (((_local3.start > 0)) ? (_local8 - _local3.start) : _local8);
                };
                _local4++;
            };
            return (_local3);
        }

    }
}//package org.openvideoplayer.parsers 
﻿package org.openvideoplayer.parsers {
    import flash.utils.*;
    import flash.events.*;
    import org.openvideoplayer.events.*;
    import flash.net.*;

    public class ParserBase extends EventDispatcher {

        private const TIMEOUT_MILLISECONDS:uint = 15000;

        protected var _xml:XML;
        protected var _busy:Boolean;
        protected var _timeoutTimer:Timer;
        protected var _rawData:String;

        public function ParserBase():void{
            this._busy = false;
            this._timeoutTimer = new Timer(this.TIMEOUT_MILLISECONDS, 1);
            this._timeoutTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.doTimeOut);
        }
        private function doTimeOut(_arg1:TimerEvent):void{
            dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.XML_LOAD_TIMEOUT)));
        }
        public function load(_arg1:String):Boolean{
            var _local2:URLLoader;
            if (!(this._busy)){
                this._busy = true;
                this._timeoutTimer.reset();
                this._timeoutTimer.start();
                _local2 = new URLLoader();
                _local2.addEventListener("complete", this.xmlLoaded);
                _local2.addEventListener(IOErrorEvent.IO_ERROR, this.catchIOError);
                _local2.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.catchSecurityError);
                _local2.load(new URLRequest(_arg1));
                return (true);
            };
            dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.CLASS_BUSY)));
            return (false);
        }
        public function get rawData():String{
            return (this._rawData);
        }
        public function get xml():XML{
            return (this._xml);
        }
        protected function xmlLoaded(_arg1:Event):void{
            var e:* = _arg1;
            this._timeoutTimer.stop();
            this._rawData = e.currentTarget.data.toString();
            try {
                this._xml = new XML(this._rawData);
                dispatchEvent(new OvpEvent(OvpEvent.LOADED));
                this.parseXML();
            } catch(err:Error) {
                _busy = false;
                dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.XML_MALFORMED)));
            };
        }
        protected function parseXML():void{
        }
        public function get isBusy():Boolean{
            return (this._busy);
        }
        private function catchIOError(_arg1:IOErrorEvent):void{
            this._timeoutTimer.stop();
            this._busy = false;
            dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.HTTP_LOAD_FAILED)));
        }
        private function catchSecurityError(_arg1:SecurityErrorEvent):void{
            this.catchIOError(null);
        }

    }
}//package org.openvideoplayer.parsers 
﻿package org.openvideoplayer.version {

    public class OvpVersion {

        private static const VERSION:String = "2.1.7-internal";

        public static function get version():String{
            return (VERSION);
        }

    }
}//package org.openvideoplayer.version 
﻿package org.openvideoplayer.events {

    public class OvpError {

        public static const HOSTNAME_EMPTY:uint = 1;
        public static const BUFFER_LENGTH:uint = 2;
        public static const PROTOCOL_NOT_SUPPORTED:uint = 3;
        public static const PORT_NOT_SUPPORTED:uint = 4;
        public static const IDENT_REQUEST_FAILED:uint = 5;
        public static const CONNECTION_TIMEOUT:uint = 6;
        public static const STREAM_NOT_DEFINED:uint = 8;
        public static const STREAM_NOT_FOUND:uint = 9;
        public static const STREAM_LENGTH_REQ_ERROR:uint = 10;
        public static const VOLUME_OUT_OF_RANGE:uint = 11;
        public static const NETWORK_FAILED:uint = 12;
        public static const HTTP_LOAD_FAILED:uint = 14;
        public static const XML_MALFORMED:uint = 15;
        public static const XML_MEDIARSS_MALFORMED:uint = 16;
        public static const CLASS_BUSY:uint = 17;
        public static const XML_BOSS_MALFORMED:uint = 18;
        public static const STREAM_FASTSTART_INVALID:uint = 19;
        public static const XML_LOAD_TIMEOUT:uint = 20;
        public static const STREAM_IO_ERROR:uint = 21;
        public static const STREAM_BUFFER_EMPTY:uint = 24;
        public static const INVALID_CUEPOINT_NAME:uint = 25;
        public static const INVALID_CUEPOINT_TIME:uint = 26;
        public static const INVALID_CUEPOINT:uint = 27;
        public static const INVALID_INDEX:uint = 28;
        public static const INVALID_ARGUMENT:uint = 29;
        public static const INVALID_CAPTION_FONT_SIZE:uint = 30;
        private static const _errorMap:Array = [{
            n:HOSTNAME_EMPTY,
            d:"Hostname cannot be empty"
        }, {
            n:BUFFER_LENGTH,
            d:"Buffer length must be > 0.1"
        }, {
            n:PROTOCOL_NOT_SUPPORTED,
            d:"Warning - this protocol is not supported"
        }, {
            n:PORT_NOT_SUPPORTED,
            d:"Warning - this port is not supported"
        }, {
            n:IDENT_REQUEST_FAILED,
            d:"Warning - unable to load XML data from ident request, will use domain name to connect"
        }, {
            n:CONNECTION_TIMEOUT,
            d:"Timed out while trying to connect"
        }, {
            n:STREAM_NOT_DEFINED,
            d:"Cannot play, pause, seek, or resume since the stream is not defined"
        }, {
            n:STREAM_NOT_FOUND,
            d:"Timed out trying to find the stream"
        }, {
            n:STREAM_LENGTH_REQ_ERROR,
            d:"Error requesting stream length"
        }, {
            n:VOLUME_OUT_OF_RANGE,
            d:"Volume value out of range"
        }, {
            n:NETWORK_FAILED,
            d:"Network failure - unable to play the live stream"
        }, {
            n:HTTP_LOAD_FAILED,
            d:"HTTP loading operation failed"
        }, {
            n:XML_MALFORMED,
            d:"XML is not well formed"
        }, {
            n:XML_MEDIARSS_MALFORMED,
            d:"XML does not conform to Media RSS standard"
        }, {
            n:CLASS_BUSY,
            d:"Class is busy and cannot process your request"
        }, {
            n:XML_BOSS_MALFORMED,
            d:"XML does not conform to BOSS standard"
        }, {
            n:STREAM_FASTSTART_INVALID,
            d:"The Fast Start feature cannot be used with live streams"
        }, {
            n:XML_LOAD_TIMEOUT,
            d:"Timed out trying to load the XML file"
        }, {
            n:STREAM_IO_ERROR,
            d:"NetStream IO Error event"
        }, {
            n:STREAM_BUFFER_EMPTY,
            d:"NetStream buffer has remained empty past timeout threshold"
        }, {
            n:INVALID_CUEPOINT_NAME,
            d:"Invalid cue point name - cannot be null or undefined"
        }, {
            n:INVALID_CUEPOINT_TIME,
            d:"Invalid cue point time - must be a number greater than zero"
        }, {
            n:INVALID_CUEPOINT,
            d:"Invalid cue point object - must contain a 'name' and 'time' properties"
        }, {
            n:INVALID_INDEX,
            d:"Attempting to switch to an invalid index in a multi-bitrate stream"
        }, {
            n:INVALID_ARGUMENT,
            d:"Invalid argument passed to property or method"
        }, {
            n:INVALID_CAPTION_FONT_SIZE,
            d:"Invalid caption font size specified. '%', '+', '-' are not supported"
        }];

        private var _num:uint;
        private var _desc:String;

        public function OvpError(_arg1:uint){
            this._num = _arg1;
            this._desc = "";
            var _local2:uint;
            while (_local2 < _errorMap.length) {
                if (_errorMap[_local2].n == this._num){
                    this._desc = _errorMap[_local2].d;
                    break;
                };
                _local2++;
            };
        }
        public function get errorNumber():uint{
            return (this._num);
        }
        public function get errorDescription():String{
            return (this._desc);
        }

    }
}//package org.openvideoplayer.events 
﻿package org.openvideoplayer.events {
    import flash.events.*;

    public class OvpEvent extends Event {

        public static const ERROR:String = "error";
        public static const TIMEOUT:String = "timeout";
        public static const BANDWIDTH:String = "bandwidth";
        public static const COMPLETE:String = "complete";
        public static const STREAM_LENGTH:String = "streamlength";
        public static const PROGRESS:String = "progress";
        public static const LOADED:String = "loaded";
        public static const PARSED:String = "parsed";
        public static const MP3_ID3:String = "id3";
        public static const NETSTREAM_METADATA:String = "metadata";
        public static const NETSTREAM_CUEPOINT:String = "cuepoint";
        public static const NETSTREAM_IMAGEDATA:String = "imagedata";
        public static const NETSTREAM_TEXTDATA:String = "textdata";
        public static const NETSTREAM_XMPDATA:String = "xmpdata";
        public static const NETSTREAM_PLAYSTATUS:String = "playstatus";
        public static const SUBSCRIBED:String = "subscribed";
        public static const UNSUBSCRIBED:String = "unsubscribed";
        public static const SUBSCRIBE_ATTEMPT:String = "subscribeattempt";
        public static const FCSUBSCRIBE:String = "fcsubscribe";
        public static const FCUNSUBSCRIBE:String = "fcunsubscribe";
        public static const DEBUG:String = "debug";
        public static const ASYNC_ERROR:String = "asyncerror";
        public static const ONFI:String = "onfi";
        public static const ONLASTSECOND:String = "onLastSecond";
        public static const CAPTION:String = "caption";
        public static const SWITCH_REQUESTED:String = "switchRequested";
        public static const SWITCH_ACKNOWLEDGED:String = "switchAcknowledged";
        public static const SWITCH_COMPLETE:String = "switchComplete";
        public static const DATA_MESSAGE:String = "datamessage";
        public static const NET_STATUS:String = "netstatus";
        public static const STREAM_NOT_FOUND:String = "streamnotfound";
        public static const IS_LIVE_STREAM:String = "islivestream";
        public static const IS_PLAYING_LIVE:String = "isplayinglive";
        public static const FAILURE:String = "failure";
        public static const IS_BUFFERING:String = "isbuffering";
        public static const SWITCH_START:String = "switchstart";
        public static const RESUME:String = "resume";
        public static const PAUSE:String = "pause";
        public static const SEEK:String = "seek";
        public static const METADATA:String = "metadata";
        public static const SUCCESS:String = "success";
        public static const REJECTED:String = "rejected";
        public static const RENDITION_CHANGE:String = "renditionchange";
        public static const RTT:String = "rtt";
        public static const STREAM_NAME_CHANGE:String = "streamnamechange";
        public static const STREAM_TYPE_CHANGE:String = "streamtypechange";
        public static const FAIL_OVER_TO_RTMP:String = "failovertortmp";
        public static const LOOP:String = "loop";
        public static const PLAY:String = "play";
        public static const CPU:String = "cpu";
        public static const REBUFFER:String = "rebuffer";
        public static const TAT:String = "tat";
        public static const SESSION_ID:String = "sessionid";
        public static const NETSESSION_CLIENT:String = "netsessionclient";
        public static const NETSESSION_EULA:String = "netsessioneula";
        public static const STREAM_START_TIME:String = "streamstarttime";
        public static const DEAD_CONNECTION:String = "deadconnection";
        public static const TRICK_MODE_TIMER_TICK:String = "trickModeTimerTick";

        private var _data:Object;

        public function OvpEvent(_arg1:String, _arg2:Object=null){
            this._data = _arg2;
            super(_arg1);
        }
        public function get data():Object{
            return (this._data);
        }
        override public function clone():Event{
            return (new OvpEvent(type, this.data));
        }

    }
}//package org.openvideoplayer.events 
﻿package org.openvideoplayer.net {
    import flash.net.*;
    import flash.utils.*;
    import flash.events.*;
    import org.openvideoplayer.events.*;
    import org.openvideoplayer.utilities.*;

    public class OvpConnection extends EventDispatcher implements INetConnection {

        private const TIMEOUT:uint = 15000;

        protected var _hostName:String;
        protected var _appNameInstName:String;
        protected var _port:String;
        protected var _protocol:String;
        protected var _actualPort:String;
        protected var _actualProtocol:String;
        protected var _urlLoader:URLLoader;
        protected var _nc:NetConnection;
        protected var _aConnections:Array;
        protected var _connectionTimer:Timer;
        protected var _timeOutTimer:Timer;
        protected var _timeOutTimerDelay:Number;
        protected var _bufferFailureTimer:Timer;
        protected var _liveStreamMasterTimeout:uint;
        protected var _connectionAttempt:uint;
        protected var _aNC:Array;
        protected var _aboutToStop:uint;
        protected var _connectionEstablished:Boolean;
        protected var _pendingLiveStreamName:String;
        protected var _playingLiveStream:Boolean;
        protected var _successfullySubscribed:Boolean;
        protected var _authParams:String;
        protected var _liveStreamAuthParams:String;
        protected var _isProgressive:Boolean;
        protected var _serverVersion:String;
        protected var _cacheable:Boolean;
        protected var _attemptInterval:uint;
        protected var _connectionArgs:Array;

        public function OvpConnection(){
            NetConnection.defaultObjectEncoding = ObjectEncoding.AMF3;
            this._liveStreamMasterTimeout = 3600000;
            this._port = "any";
            this._protocol = "any";
            this._authParams = "";
            this._liveStreamAuthParams = "";
            this._aboutToStop = 0;
            this._isProgressive = false;
            this._serverVersion = "";
            this._cacheable = false;
            this._attemptInterval = 200;
            this._timeOutTimerDelay = this.TIMEOUT;
            this._timeOutTimer = new Timer(this._timeOutTimerDelay, 1);
            this._timeOutTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.masterTimeout);
            this._connectionTimer = new Timer(200);
            this._connectionTimer.addEventListener(TimerEvent.TIMER, this.tryToConnect);
        }
        public function get netConnection():NetConnection{
            return (this._nc);
        }
        public function get connected():Boolean{
            if (((this._nc) && ((this._nc is NetConnection)))){
                return (this._nc.connected);
            };
            return (false);
        }
        public function get connectedProxyType():String{
            if (((this._nc) && ((this._nc is NetConnection)))){
                return (this._nc.connectedProxyType);
            };
            return ("");
        }
        public function get defaultObjectEncoding():uint{
            return (NetConnection.defaultObjectEncoding);
        }
        public function set defaultObjectEncoding(_arg1:uint):void{
            switch (_arg1){
                case ObjectEncoding.AMF0:
                case ObjectEncoding.AMF3:
                case ObjectEncoding.DEFAULT:
                    NetConnection.defaultObjectEncoding = _arg1;
                    break;
                default:
                    dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.INVALID_ARGUMENT)));
            };
        }
        public function get objectEncoding():uint{
            if (((this._nc) && ((this._nc is NetConnection)))){
                return (this._nc.objectEncoding);
            };
            return (ObjectEncoding.DEFAULT);
        }
        public function set objectEncoding(_arg1:uint):void{
            if (((this._nc) && ((this._nc is NetConnection)))){
                this._nc.objectEncoding = _arg1;
            };
        }
        public function get proxyType():String{
            if (((this._nc) && ((this._nc is NetConnection)))){
                return (this._nc.proxyType);
            };
            return ("");
        }
        public function set proxyType(_arg1:String):void{
            if (((this._nc) && ((this._nc is NetConnection)))){
                this._nc.proxyType = _arg1;
            };
        }
        public function get uri():String{
            if (((this._nc) && ((this._nc is NetConnection)))){
                return (this._nc.uri);
            };
            return ("");
        }
        public function get usingTLS():Boolean{
            if (((this._nc) && ((this._nc is NetConnection)))){
                return (this._nc.usingTLS);
            };
            return (false);
        }
        public function get actualPort():String{
            return (((this._connectionEstablished) ? this._actualPort : null));
        }
        public function get actualProtocol():String{
            return (((this._connectionEstablished) ? this._actualProtocol : null));
        }
        public function get timeout():Number{
            return (this._timeOutTimerDelay);
        }
        public function set timeout(_arg1:Number):void{
            this._timeOutTimerDelay = _arg1;
        }
        public function get serverIPaddress():String{
            return (((this._connectionEstablished) ? this._hostName : null));
        }
        public function get requestedPort():String{
            return (this._port);
        }
        public function set requestedPort(_arg1:String):void{
            this._port = _arg1;
        }
        public function get requestedProtocol():String{
            return (this._protocol);
        }
        public function set requestedProtocol(_arg1:String):void{
            this._protocol = _arg1;
        }
        public function get isProgressive():Boolean{
            return (this._isProgressive);
        }
        public function get hostName():String{
            return (this._hostName);
        }
        public function get appNameInstanceName():String{
            return (this._appNameInstName);
        }
        public function get cacheable():Boolean{
            return (this._cacheable);
        }
        public function set cacheable(_arg1:Boolean):void{
            this._cacheable = _arg1;
        }
        public function get attemptInterval():uint{
            return (this._attemptInterval);
        }
        public function set attemptInterval(_arg1:uint):void{
            this._attemptInterval = _arg1;
        }
        public function addHeader(_arg1:String, _arg2:Boolean=false, _arg3:Object=null):void{
            if (((this._nc) && ((this._nc is NetConnection)))){
                this._nc.addHeader(_arg1, _arg2, _arg3);
            };
        }
        public function call(_arg1:String, _arg2:Responder, ... _args):void{
            var _local4:Array;
            if (((this._nc) && ((this._nc is NetConnection)))){
                _local4 = [_arg1, _arg2].concat(_args);
                this._nc.call.apply(this._nc, _local4);
            };
        }
        public function close():void{
            if (((this._nc) && (this._connectionEstablished))){
                this._nc.close();
                this._connectionEstablished = false;
            };
        }
        public function connect(_arg1:String, ... _args):void{
            this._connectionArgs = _args;
            if ((((_arg1 == null)) || ((_arg1 == "null")))){
                this.setUpProgressiveConnection();
                return;
            };
            if (_arg1 == ""){
                dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.HOSTNAME_EMPTY)));
                return;
            };
            this._isProgressive = false;
            this._hostName = ((!((_arg1.indexOf("/") == -1))) ? _arg1.slice(0, _arg1.indexOf("/")) : _arg1);
            this._appNameInstName = ((((!((_arg1.indexOf("/") == -1))) && (!((_arg1.indexOf("/") == (_arg1.length - 1)))))) ? _arg1.slice((_arg1.indexOf("/") + 1)) : "");
            this._connectionEstablished = false;
            this.buildConnectionSequence();
        }
        public function reconnect():void{
            this._connectionEstablished = false;
            this.buildConnectionSequence();
        }
        public function detectBandwidth():Boolean{
            if (((this._nc) && (this._connectionEstablished))){
                this._nc.call("_checkbw", null);
            };
            return (this._connectionEstablished);
        }
        public function requestStreamLength(_arg1:String):Boolean{
            var _local2:String;
            if (((!(this._connectionEstablished)) || ((_arg1 == "")))){
                return (false);
            };
            if (((this._nc) && ((this._nc is NetConnection)))){
                _local2 = ((!((_arg1.indexOf("?") == -1))) ? _arg1.slice(0, _arg1.indexOf("?")) : _arg1);
                this._nc.call("getStreamLength", new Responder(this.onStreamLengthResult, this.onStreamLengthFault), StringUtil.addPrefix(_local2));
            };
            return (true);
        }
        public function streamLengthAsTimeCode(_arg1:Number):String{
            return (TimeUtil.timeCode(_arg1));
        }
        public function serverVersion(_arg1:Object):String{
            if (!(_arg1)){
                return (this._serverVersion);
            };
            if (((((!(this._serverVersion)) || (!(this._serverVersion.length)))) || ((this._serverVersion == "")))){
                _arg1.major = (_arg1.minor = (_arg1.subMinor = (_arg1.build = 0)));
                return (this._serverVersion);
            };
            var _local2:Array = this._serverVersion.split(",");
            _arg1.major = parseInt(_local2[0]);
            _arg1.minor = parseInt(_local2[1]);
            _arg1.subMinor = parseInt(_local2[2]);
            _arg1.build = parseInt(_local2[3]);
            return (this._serverVersion);
        }
        protected function contains(_arg1:String, _arg2:String):Boolean{
            var _local4:String;
            var _local3:Array = _arg1.split(",");
            for each (_local4 in _local3) {
                if (_local4.toLowerCase() == _arg2){
                    return (true);
                };
            };
            return (false);
        }
        protected function buildPortProtocolSequence():Array{
            var _local2:Array;
            var _local3:Array;
            var _local4:Number;
            var _local5:Number;
            var _local1:Array = new Array();
            if ((((this._port == "any")) && ((this._protocol == "any")))){
                _local1 = [{
                    port:"1935",
                    protocol:"rtmp"
                }, {
                    port:"443",
                    protocol:"rtmp"
                }, {
                    port:"80",
                    protocol:"rtmp"
                }, {
                    port:"80",
                    protocol:"rtmpt"
                }, {
                    port:"443",
                    protocol:"rtmpt"
                }, {
                    port:"1935",
                    protocol:"rtmpt"
                }, {
                    port:"1935",
                    protocol:"rtmpe"
                }, {
                    port:"443",
                    protocol:"rtmpe"
                }, {
                    port:"80",
                    protocol:"rtmpe"
                }, {
                    port:"80",
                    protocol:"rtmpte"
                }, {
                    port:"443",
                    protocol:"rtmpte"
                }, {
                    port:"1935",
                    protocol:"rtmpte"
                }];
            } else {
                if (this.contains(this._port, "any")){
                    this._port = "1935,443,80";
                };
                if (this.contains(this._protocol, "any")){
                    this._protocol = "rtmp,rtmpt,rtmpe,rtmpte";
                };
                _local2 = this._port.split(",");
                _local3 = this._protocol.split(",");
                _local4 = 0;
                while (_local4 < _local3.length) {
                    _local5 = 0;
                    while (_local5 < _local2.length) {
                        _local1.push({
                            port:_local2[_local5],
                            protocol:_local3[_local4]
                        });
                        _local5++;
                    };
                    _local4++;
                };
            };
            return (_local1);
        }
        protected function buildConnectionAddress(_arg1:String, _arg2:String):String{
            var _local3:String = ((((((_arg1 + "://") + this._hostName) + ":") + _arg2) + "/") + this._appNameInstName);
            return (_local3);
        }
        protected function buildConnectionSequence():void{
            var _local3:Object;
            var _local4:String;
            var _local1:Array = this.buildPortProtocolSequence();
            this._aConnections = new Array();
            this._aNC = new Array();
            var _local2:uint;
            while (_local2 < _local1.length) {
                _local3 = new Object();
                _local4 = this.buildConnectionAddress(_local1[_local2].protocol, _local1[_local2].port);
                _local3.address = _local4;
                _local3.port = _local1[_local2].port;
                _local3.protocol = _local1[_local2].protocol;
                this._aConnections.push(_local3);
                _local2++;
            };
            this._timeOutTimer.delay = this._timeOutTimerDelay;
            this._timeOutTimer.reset();
            this._timeOutTimer.start();
            this._connectionAttempt = 0;
            this._connectionTimer.reset();
            this._connectionTimer.delay = (((this._authParams == "")) ? this._attemptInterval : (this._attemptInterval + 150));
            this._connectionTimer.start();
            this.tryToConnect(null);
        }
        protected function tryToConnect(_arg1:TimerEvent):void{
            var arg:* = null;
            var evt:* = _arg1;
            this._aNC[this._connectionAttempt] = new NetConnection();
            this._aNC[this._connectionAttempt].addEventListener(NetStatusEvent.NET_STATUS, this.netStatus);
            this._aNC[this._connectionAttempt].addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.netSecurityError);
            this._aNC[this._connectionAttempt].addEventListener(AsyncErrorEvent.ASYNC_ERROR, this.asyncError);
            this._aNC[this._connectionAttempt].client = new Object();
            this._aNC[this._connectionAttempt].client.id = this._connectionAttempt;
            this._aNC[this._connectionAttempt].client._onbwcheck = this._onbwcheck;
            this._aNC[this._connectionAttempt].client._onbwdone = this._onbwdone;
            this._aNC[this._connectionAttempt].client.onFCSubscribe = this.onFCSubscribe;
            this._aNC[this._connectionAttempt].client.onFCUnsubscribe = this.onFCUnsubscribe;
            var args:* = [this._aConnections[this._connectionAttempt].address];
            if (this._connectionArgs != null){
                for each (arg in this._connectionArgs) {
                    args.push(arg);
                };
            };
            try {
                NetConnection(this._aNC[this._connectionAttempt]).connect.apply(this._aNC[this._connectionAttempt], args);
            } catch(error:Error) {
            } finally {
                this._connectionAttempt++;
                if (this._connectionAttempt >= this._aConnections.length){
                    this._connectionTimer.stop();
                };
            };
        }
        protected function handleGoodConnect():void{
            this._connectionEstablished = true;
            var _local1:Object = new Object();
            _local1.code = "NetConnection.Connect.Success";
            _local1.description = "Connection succeeded.";
            _local1.level = "status";
            dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, _local1));
        }
        protected function handleRejectedOrInvalid(_arg1:NetStatusEvent):void{
            dispatchEvent(_arg1);
        }
        protected function setUpProgressiveConnection():void{
            this._isProgressive = true;
            this._nc = new NetConnection();
            this._nc.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.netSecurityError);
            this._nc.addEventListener(AsyncErrorEvent.ASYNC_ERROR, this.asyncError);
            this._nc.connect(null);
            this.handleGoodConnect();
        }
        protected function masterTimeout(_arg1:Event):void{
            var _local2:uint;
            while (_local2 < this._aNC.length) {
                this._aNC[_local2].close();
                this._aNC[_local2] = null;
                _local2++;
            };
            dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.CONNECTION_TIMEOUT)));
        }
        protected function netStatus(_arg1:NetStatusEvent):void{
            var _local2:uint;
            if (this._connectionEstablished){
                dispatchEvent(_arg1);
            };
            switch (_arg1.info.code){
                case "NetConnection.Connect.InvalidApp":
                case "NetConnection.Connect.Rejected":
                    this.handleRejectedOrInvalid(_arg1);
                    break;
                case "NetConnection.Call.Failed":
                    if (_arg1.info.description.indexOf("_checkbw") != -1){
                        _arg1.target.expectBWDone = true;
                        _arg1.target.call("checkBandwidth", null);
                    };
                    break;
                case "NetConnection.Connect.Success":
                    this._timeOutTimer.stop();
                    this._connectionTimer.stop();
                    _local2 = 0;
                    while (_local2 < this._aNC.length) {
                        if (((this._aNC[_local2]) && (!((_local2 == _arg1.target.client.id))))){
                            this._aNC[_local2].close();
                            this._aNC[_local2] = null;
                        };
                        _local2++;
                    };
                    this._nc = NetConnection(_arg1.target);
                    this._actualPort = this._aConnections[this._nc.client.id].port;
                    this._actualProtocol = this._aConnections[this._nc.client.id].protocol;
                    if (((_arg1.info.data) && (_arg1.info.data.version))){
                        this._serverVersion = _arg1.info.data.version;
                    };
                    this.handleGoodConnect();
                    break;
            };
        }
        protected function netSecurityError(_arg1:SecurityErrorEvent):void{
            dispatchEvent(_arg1);
        }
        protected function asyncError(_arg1:AsyncErrorEvent):void{
            dispatchEvent(_arg1);
        }
        public function _onbwcheck(_arg1:Object, _arg2:Number):Number{
            return (_arg2);
        }
        public function onFCSubscribe(_arg1:Object):void{
            dispatchEvent(new OvpEvent(OvpEvent.FCSUBSCRIBE, _arg1));
        }
        public function onFCUnsubscribe(_arg1:Object):void{
            if (_arg1.code == "NetStream.Play.Stop"){
                dispatchEvent(new OvpEvent(OvpEvent.FCUNSUBSCRIBE, _arg1));
            };
        }
        public function _onbwdone(_arg1:Number, _arg2:Number):void{
            var _local3:Object = new Object();
            _local3.bandwidth = _arg2;
            _local3.latency = _arg1;
            dispatchEvent(new OvpEvent(OvpEvent.BANDWIDTH, _local3));
        }
        private function onStreamLengthResult(_arg1:Number):void{
            var _local2:Object = new Object();
            _local2.streamLength = _arg1;
            dispatchEvent(new OvpEvent(OvpEvent.STREAM_LENGTH, _local2));
        }
        private function onStreamLengthFault(_arg1:Object):void{
            dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.STREAM_LENGTH_REQ_ERROR)));
        }

    }
}//package org.openvideoplayer.net 
﻿package org.openvideoplayer.net.dynamicstream {
    import flash.utils.*;

    public class DynamicStreamItem {

        private const LOCK_INTERVAL:Number = 30000;

        private var _lockLevel:Number;
        private var _lastLockTime:Number;
        private var streamArray:Array;
        public var start:Number;
        public var streamAuth:String;
        public var len:Number;
        public var reset:Boolean;
        public var startingIndex:Number;
        public var streamCount:Number;

        public function DynamicStreamItem(){
            this.streamArray = new Array();
            this.streamCount = NaN;
            this.start = -2;
            this.len = -1;
            this.reset = true;
            this.streamAuth = "";
            this.startingIndex = -1;
            this._lastLockTime = 0;
            this._lockLevel = int.MAX_VALUE;
        }
        public function addStream(_arg1:String, _arg2:Number):void{
            this.streamArray.push(new DynamicStreamBitrate(_arg1, _arg2));
            this.streamArray.sortOn("rate", Array.NUMERIC);
            this.streamCount = this.streamArray.length;
        }
        public function get streams():Array{
            return (this.streamArray);
        }
        public function indexFromName(_arg1:String):int{
            var _local2:int;
            while (_local2 < this.streamCount) {
                if ((((_arg1 == this.streamArray[_local2].name)) || ((("mp4:" + _arg1) == this.streamArray[_local2].name)))){
                    return (_local2);
                };
                _local2++;
            };
            return (undefined);
        }
        public function getRateAt(_arg1:int):Number{
            return ((((((_arg1 >= 0)) && ((_arg1 < this.streamArray.length)))) ? (this.streamArray[_arg1].rate as Number) : undefined));
        }
        public function getNameAt(_arg1:uint):String{
            return ((this.streamArray[_arg1].name as String));
        }
        public function getBitrateAt(_arg1:uint):DynamicStreamBitrate{
            return ((this.streamArray[_arg1] as DynamicStreamBitrate));
        }
        public function incrementFailCountAt(_arg1:uint):void{
            this.getBitrateAt(_arg1).incrementFailCount();
        }
        public function lock(_arg1:int):void{
            this._lockLevel = _arg1;
            this._lastLockTime = getTimer();
        }
        public function isLockedAt(_arg1:int):Boolean{
            return ((((_arg1 >= this._lockLevel)) && (((getTimer() - this._lastLockTime) < this.LOCK_INTERVAL))));
        }
        public function isAvailable(_arg1:int):Boolean{
            return (((!(this.isLockedAt(_arg1))) && (this.streamArray[_arg1].isAvailable)));
        }

    }
}//package org.openvideoplayer.net.dynamicstream 
﻿package org.openvideoplayer.net.dynamicstream {
    import flash.events.*;

    public interface ISwitchingRule extends IEventDispatcher {

        function getNewIndex():int;
        function get reason():String;

    }
}//package org.openvideoplayer.net.dynamicstream 
﻿package org.openvideoplayer.net.dynamicstream {
    import flash.events.*;
    import flash.net.*;
    import flash.utils.*;
    import org.openvideoplayer.events.*;

    public class MetricsProvider extends EventDispatcher implements INetStreamMetrics {

        private const DEFAULT_UPDATE_INTERVAL:Number = 100;
        private const DEFAULT_AVG_BANDWIDTH_SAMPLE_SIZE:int = 50;
        private const DEFAULT_AVG_FRAMERATE_SAMPLE_SIZE:Number = 50;
        private const DEFAULT_SMOOTH_STARTUP_SAMPLE_SIZE:int = 10;

        private var _ns:NetStream;
        private var _timer:Timer;
        private var _reachedTargetBufferFull:Boolean;
        private var _currentBufferSize:Number;
        private var _maxBufferSize:Number;
        private var _lastMaxBitrate:Number;
        private var _avgMaxBitrateArray:Array;
        private var _avgMaxBitrate:Number;
        private var _avgDroppedFrameRateArray:Array;
        private var _avgDroppedFrameRate:Number;
        private var _frameDropRate:Number;
        private var _lastFrameDropValue:Number;
        private var _lastFrameDropCounter:Number;
        private var _maxFrameRate:Number;
        private var _currentIndex:uint;
        private var _dsi:DynamicStreamItem;
        private var _so:SharedObject;
        private var _targetBufferTime:Number;
        private var _enabled:Boolean;
        private var _optimizeForLivebandwidthEstimate:Boolean;
        private var _framerateChecked:int;
        private var _smoothStartup:Boolean;
        private var _smoothStartupCap:Number;
        private var _smoothStartupValue:Number;
        private var _startupCount:int;
        private var _smoothStartupSampleSize:int;
        private var _avgBandwidthSampleSize:int;
        private var _avgFramerateSampleSize:int;
        private var _autoFramerateUpdate:Boolean;
        private var _qualityRating:Number;

        public function MetricsProvider(_arg1:NetStream){
            super(null);
            this._ns = _arg1;
            this._ns.addEventListener(NetStatusEvent.NET_STATUS, this.netStatus);
            this._frameDropRate = 0;
            this._reachedTargetBufferFull = false;
            this._lastFrameDropCounter = 0;
            this._lastFrameDropValue = 0;
            this._maxFrameRate = 0;
            this._optimizeForLivebandwidthEstimate = false;
            this._avgMaxBitrateArray = new Array();
            this._avgDroppedFrameRateArray = new Array();
            this._enabled = true;
            this._targetBufferTime = 0;
            this._smoothStartup = true;
            this._smoothStartupValue = 0;
            this._so = SharedObject.getLocal("OVPMetricsProvider", "/", false);
            if (this._so.data.avgMaxBitrate != undefined){
                this._avgMaxBitrate = this._so.data.avgMaxBitrate;
            };
            this._timer = new Timer(this.DEFAULT_UPDATE_INTERVAL);
            this._timer.addEventListener(TimerEvent.TIMER, this.update);
            this._startupCount = 0;
            this._smoothStartupSampleSize = this.DEFAULT_SMOOTH_STARTUP_SAMPLE_SIZE;
            this._avgBandwidthSampleSize = this.DEFAULT_AVG_BANDWIDTH_SAMPLE_SIZE;
            this._avgFramerateSampleSize = this.DEFAULT_AVG_FRAMERATE_SAMPLE_SIZE;
            this._autoFramerateUpdate = true;
        }
        public function get updateInterval():Number{
            return (this._timer.delay);
        }
        public function set updateInterval(_arg1:Number):void{
            this._timer.delay = _arg1;
        }
        public function get netStream():NetStream{
            return (this._ns);
        }
        public function get currentIndex():uint{
            return (this._currentIndex);
        }
        public function set currentIndex(_arg1:uint):void{
            this._currentIndex = _arg1;
        }
        public function get maxIndex():uint{
            return (((this._dsi.streamCount - 1) as uint));
        }
        public function get dynamicStreamItem():DynamicStreamItem{
            return (this._dsi);
        }
        public function set dynamicStreamItem(_arg1:DynamicStreamItem):void{
            this._dsi = _arg1;
        }
        public function get reachedTargetBufferFull():Boolean{
            return (this._reachedTargetBufferFull);
        }
        public function get bufferLength():Number{
            return (this._ns.bufferLength);
        }
        public function get bufferTime():Number{
            return (this._ns.bufferTime);
        }
        public function get targetBufferTime():Number{
            return (this._targetBufferTime);
        }
        public function set targetBufferTime(_arg1:Number):void{
            this._targetBufferTime = _arg1;
        }
        public function get optimizeForLivebandwidthEstimate():Boolean{
            return (this._optimizeForLivebandwidthEstimate);
        }
        public function set optimizeForLivebandwidthEstimate(_arg1:Boolean):void{
            this._optimizeForLivebandwidthEstimate = _arg1;
        }
        public function get expectedFPS():Number{
            return (this._maxFrameRate);
        }
        public function get droppedFPS():Number{
            return (this._frameDropRate);
        }
        public function get averageDroppedFPS():Number{
            return (this._avgDroppedFrameRate);
        }
        public function get maxBandwidth():Number{
            return (this._lastMaxBitrate);
        }
        public function get averageMaxBandwidth():Number{
            return (this._avgMaxBitrate);
        }
        public function get info():NetStreamInfo{
            return (this._ns.info);
        }
        public function get autoFramerateUpdate():Boolean{
            return (this._autoFramerateUpdate);
        }
        public function set autoFramerateUpdate(_arg1:Boolean):void{
            this._autoFramerateUpdate = _arg1;
        }
        public function get avgFramerateSampleSize():int{
            return (this._avgFramerateSampleSize);
        }
        public function set avgFramerateSampleSize(_arg1:int):void{
            this._avgFramerateSampleSize = _arg1;
        }
        public function get avgBandwidthSampleSize():int{
            return (this._avgBandwidthSampleSize);
        }
        public function set avgBandwidthSampleSize(_arg1:int):void{
            this._avgBandwidthSampleSize = _arg1;
        }
        public function get smoothStartupCap():Number{
            return (this._smoothStartupCap);
        }
        public function set smoothStartupCap(_arg1:Number):void{
            this._smoothStartupCap = _arg1;
        }
        public function get smoothStartup():Boolean{
            return (this._smoothStartup);
        }
        public function set smoothStartup(_arg1:Boolean):void{
            this._smoothStartup = _arg1;
        }
        public function get smoothStartupValue():Number{
            return (this._smoothStartupValue);
        }
        public function set smoothStartupValue(_arg1:Number):void{
            this._smoothStartupValue = _arg1;
        }
        public function get smoothStartupSampleSize():int{
            return (this._smoothStartupSampleSize);
        }
        public function set smoothStartupSampleSize(_arg1:int):void{
            this._smoothStartupSampleSize = _arg1;
        }
        public function enable():void{
            this._enabled = true;
        }
        public function disable():void{
            this._enabled = false;
            this._timer.stop();
        }
        private function netStatus(_arg1:NetStatusEvent):void{
            switch (_arg1.info.code){
                case "NetStream.Buffer.Full":
                    this._reachedTargetBufferFull = (this._ns.bufferLength >= this._targetBufferTime);
                    break;
                case "NetStream.Buffer.Empty":
                    this._reachedTargetBufferFull = false;
                    break;
                case "NetStream.Play.Start":
                    this._reachedTargetBufferFull = false;
                    if (((!(this._timer.running)) && (this._enabled))){
                        this._timer.start();
                    };
                    break;
                case "NetStream.Seek.Notify":
                    this._reachedTargetBufferFull = false;
                    break;
                case "NetStream.Play.Stop":
                    this._timer.stop();
                    break;
            };
        }
        protected function update(_arg1:TimerEvent):void{
            var currentMaxBitrate:* = NaN;
            var totalMaxBitrate:* = NaN;
            var peakMaxBitrate:* = NaN;
            var b:* = 0;
            var e:* = _arg1;
            try {
                currentMaxBitrate = ((this.info.maxBytesPerSecond * 8) / 0x0400);
                if (currentMaxBitrate != 0){
                    if (this._smoothStartup){
                        this._startupCount++;
                        if (!(this._smoothStartupCap)){
                            this._smoothStartupCap = Number.MAX_VALUE;
                        };
                        if (currentMaxBitrate > this._smoothStartupCap){
                            currentMaxBitrate = this._smoothStartupCap;
                        };
                        this._smoothStartupValue = (this._smoothStartupValue + currentMaxBitrate);
                        this._avgMaxBitrate = (((this._startupCount >= this._smoothStartupSampleSize)) ? (this._smoothStartupValue / this._startupCount) : 0);
                        if (this._startupCount >= this._avgBandwidthSampleSize){
                            this._smoothStartup = false;
                        };
                    };
                    this._avgMaxBitrateArray.unshift(currentMaxBitrate);
                    if (this._avgMaxBitrateArray.length > this._avgBandwidthSampleSize){
                        this._avgMaxBitrateArray.pop();
                    };
                    totalMaxBitrate = 0;
                    peakMaxBitrate = 0;
                    b = 0;
                    while (b < this._avgMaxBitrateArray.length) {
                        totalMaxBitrate = (totalMaxBitrate + this._avgMaxBitrateArray[b]);
                        peakMaxBitrate = (((this._avgMaxBitrateArray[b] > peakMaxBitrate)) ? this._avgMaxBitrateArray[b] : peakMaxBitrate);
                        b = (b + 1);
                    };
                    if (!(this._smoothStartup)){
                        this._avgMaxBitrate = (((this._avgMaxBitrateArray.length < this._avgBandwidthSampleSize)) ? 0 : ((this._optimizeForLivebandwidthEstimate) ? peakMaxBitrate : (totalMaxBitrate / this._avgMaxBitrateArray.length)));
                    };
                    this._so.data.avgMaxBitrate = this._avgMaxBitrate;
                    if (this._autoFramerateUpdate){
                        this.updateFramerate();
                    };
                };
                this._lastMaxBitrate = currentMaxBitrate;
            } catch(e:Error) {
                debug(((("org.openvideoplayer.net.dynamicstream.MetricsProvider.update() eating this exception: id=" + e.errorID) + " ") + e.message));
            };
        }
        public function updateFramerate():void{
            var currentTime:* = 0;
            var framerateDelay:* = 0;
            var totalDroppedFrameRate:* = NaN;
            var f:* = 0;
            try {
                this._maxFrameRate = (((this._ns.currentFPS > this._maxFrameRate)) ? this._ns.currentFPS : this._maxFrameRate);
                currentTime = new Date().time;
                framerateDelay = (currentTime - this._framerateChecked);
                this._framerateChecked = currentTime;
                if (framerateDelay > 0){
                    this._frameDropRate = ((this._ns.info.droppedFrames - this._lastFrameDropValue) / framerateDelay);
                    this._lastFrameDropValue = this._ns.info.droppedFrames;
                    this._avgDroppedFrameRateArray.unshift(this._frameDropRate);
                    if (this._avgDroppedFrameRateArray.length > this._avgFramerateSampleSize){
                        this._avgDroppedFrameRateArray.pop();
                    };
                    totalDroppedFrameRate = 0;
                    f = 0;
                    while (f < this._avgDroppedFrameRateArray.length) {
                        totalDroppedFrameRate = (totalDroppedFrameRate + this._avgDroppedFrameRateArray[f]);
                        f = (f + 1);
                    };
                };
                this._avgDroppedFrameRate = (((this._avgDroppedFrameRateArray.length < this._avgFramerateSampleSize)) ? 0 : (totalDroppedFrameRate / this._avgDroppedFrameRateArray.length));
            } catch(e:Error) {
                debug(((("org.openvideoplayer.net.dynamicstream.MetricsProvider.updateFramerate() eating this exception: id=" + e.errorID) + " ") + e.message));
            };
        }
        protected function debug(_arg1:String):void{
            dispatchEvent(new OvpEvent(OvpEvent.DEBUG, _arg1));
        }

    }
}//package org.openvideoplayer.net.dynamicstream 
﻿package org.openvideoplayer.net.dynamicstream {
    import flash.utils.*;
    import flash.events.*;

    public class DynamicStreamBitrate {

        private const DEFAULT_CLEAR_FAILED_COUNTS_INTERVAL:Number = 300000;

        private var _clearFailedCountsInterval:Number;
        private var _bitrate:Number;
        private var _stream:String;
        private var _failedCount:Number = 0;
        private var _allowedFails:Number = 3;
        private var _enabled:Boolean = true;
        private var _timeToSteadyState:Number = 4000;
        private var _startedPlay:Number;
        private var clearFailedCountTimer:Timer;

        public function DynamicStreamBitrate(_arg1:String, _arg2:Number){
            this._stream = _arg1;
            this._bitrate = _arg2;
            this._clearFailedCountsInterval = this.DEFAULT_CLEAR_FAILED_COUNTS_INTERVAL;
        }
        public function set clearFailedCountsInterval(_arg1:Number):void{
            this._clearFailedCountsInterval = _arg1;
        }
        public function get clearFailedCountsInterval():Number{
            return (this._clearFailedCountsInterval);
        }
        public function get startedPlay():Number{
            return (this._startedPlay);
        }
        public function set startedPlay(_arg1:Number):void{
            this._startedPlay = _arg1;
        }
        public function get timeToSteadyState():Number{
            return ((this._timeToSteadyState / 1000));
        }
        public function set timeToSteadyState(_arg1:Number):void{
            this._timeToSteadyState = (_arg1 * 1000);
        }
        public function get failedCount():Number{
            return (this._failedCount);
        }
        public function set failedCount(_arg1:Number):void{
            this._failedCount = _arg1;
        }
        public function get allowedFails():Number{
            return (this._allowedFails);
        }
        public function set allowedFails(_arg1:Number):void{
            this._allowedFails = _arg1;
        }
        public function get rate():Number{
            return (this._bitrate);
        }
        public function get name():String{
            return (this._stream);
        }
        public function start():void{
            this._startedPlay = getTimer();
        }
        public function get isSteadyState():Boolean{
            return ((this._startedPlay > (getTimer() - this._timeToSteadyState)));
        }
        public function get isAvailable():Boolean{
            return ((this._failedCount <= this._allowedFails));
        }
        public function incrementFailCount():void{
            this._failedCount++;
            if (this._failedCount > this._allowedFails){
                if (this.clearFailedCountTimer == null){
                    this.clearFailedCountTimer = new Timer(this._clearFailedCountsInterval, 1);
                    this.clearFailedCountTimer.addEventListener(TimerEvent.TIMER, this.clearFailedCount);
                };
                this.clearFailedCountTimer.start();
            };
        }
        private function clearFailedCount(_arg1:TimerEvent):void{
            this.clearFailedCountTimer.removeEventListener(TimerEvent.TIMER, this.clearFailedCount);
            this.clearFailedCountTimer = null;
            this._failedCount = 0;
        }
        public function get enabled():Boolean{
            return (this._enabled);
        }
        public function set enabled(_arg1:Boolean):void{
            this._enabled = _arg1;
        }

    }
}//package org.openvideoplayer.net.dynamicstream 
﻿package org.openvideoplayer.net.dynamicstream {
    import org.openvideoplayer.events.*;
    import flash.events.*;

    public class FrameDropRule extends EventDispatcher implements ISwitchingRule {

        private const DROP_ONE_FRAMEDROP_FPS:Number = 10;
        private const DROP_TWO_FRAMEDROP_FPS:Number = 20;
        private const PANIC_FRAMEDROP_FPS:Number = 24;

        private var _metrics:INetStreamMetrics;
        private var _reason:String;

        public function FrameDropRule(_arg1:INetStreamMetrics):void{
            super(null);
            this._metrics = _arg1;
        }
        public function getNewIndex():int{
            var _local1:int = -1;
            if (this._metrics.averageDroppedFPS > this.PANIC_FRAMEDROP_FPS){
                this._reason = ((("Average droppedFPS of " + Math.round(this._metrics.averageDroppedFPS)) + " > ") + this.PANIC_FRAMEDROP_FPS);
                _local1 = 0;
            } else {
                if (this._metrics.averageDroppedFPS > this.DROP_TWO_FRAMEDROP_FPS){
                    _local1 = ((((this._metrics.currentIndex - 2) < 0)) ? 0 : (this._metrics.currentIndex - 2));
                    this._reason = ((("Average droppedFPS of " + Math.round(this._metrics.averageDroppedFPS)) + " > ") + this.DROP_TWO_FRAMEDROP_FPS);
                } else {
                    if (this._metrics.averageDroppedFPS > this.DROP_ONE_FRAMEDROP_FPS){
                        _local1 = ((((this._metrics.currentIndex - 1) < 0)) ? 0 : (this._metrics.currentIndex - 1));
                        this._reason = ((("Average droppedFPS of " + Math.round(this._metrics.averageDroppedFPS)) + " > ") + this.DROP_ONE_FRAMEDROP_FPS);
                    };
                };
            };
            if (((!((_local1 == -1))) && ((_local1 < this._metrics.currentIndex)))){
                if (!(this._metrics.dynamicStreamItem.isLockedAt(this._metrics.currentIndex))){
                    this._metrics.dynamicStreamItem.lock(this._metrics.currentIndex);
                    dispatchEvent(new OvpEvent(OvpEvent.DEBUG, ("Frame drop rule locking at index level " + this._metrics.currentIndex)));
                };
            };
            return (_local1);
        }
        public function get reason():String{
            return (this._reason);
        }

    }
}//package org.openvideoplayer.net.dynamicstream 
﻿package org.openvideoplayer.net.dynamicstream {
    import flash.events.*;

    public class BandwidthRule extends EventDispatcher implements ISwitchingRule {

        private const BANDWIDTH_SAFETY_MULTIPLE:Number = 1.15;

        private var _metrics:INetStreamMetrics;
        private var _panicMode:Boolean;
        private var _reason:String;

        public function BandwidthRule(_arg1:INetStreamMetrics):void{
            super(null);
            this._metrics = _arg1;
        }
        public function getNewIndex():int{
            var _local2:int;
            var _local1:int = -1;
            if (this._metrics.averageMaxBandwidth != 0){
                _local2 = (this._metrics.dynamicStreamItem.streamCount - 1);
                while (_local2 >= 0) {
                    if (this._metrics.averageMaxBandwidth > (this._metrics.dynamicStreamItem.getRateAt(_local2) * this.BANDWIDTH_SAFETY_MULTIPLE)){
                        _local1 = _local2;
                        this._reason = (((("Average bandwidth of " + Math.round(this._metrics.averageMaxBandwidth)) + " < ") + this.BANDWIDTH_SAFETY_MULTIPLE) + " * rendition bitrate");
                        break;
                    };
                    _local2--;
                };
                if (_local1 > this._metrics.currentIndex){
                    _local1 = (((((this._metrics.droppedFPS < 2)) && ((this._metrics.bufferLength > this._metrics.targetBufferTime)))) ? _local1 : -1);
                    this._reason = ((("Move up since avg dropped FPS " + Math.round(this._metrics.droppedFPS)) + " < 2 and bufferLength > ") + this._metrics.targetBufferTime);
                };
            };
            return (_local1);
        }
        public function get reason():String{
            return (this._reason);
        }

    }
}//package org.openvideoplayer.net.dynamicstream 
﻿package org.openvideoplayer.net.dynamicstream {
    import flash.events.*;

    public class BufferRule extends EventDispatcher implements ISwitchingRule {

        private const PANIC_BUFFER_LEVEL:Number = 2;

        private var _metrics:INetStreamMetrics;
        private var _panic:Boolean;
        private var _reason:String;

        public function BufferRule(_arg1:INetStreamMetrics):void{
            super(null);
            this._metrics = _arg1;
            this._metrics.netStream.addEventListener(NetStatusEvent.NET_STATUS, this.monitorNetStatus);
            this._panic = false;
        }
        public function getNewIndex():int{
            if (!(this._panic)){
                this._reason = (((("Buffer  of " + Math.round(this._metrics.bufferLength)) + " < ") + this.PANIC_BUFFER_LEVEL) + " seconds");
            };
            return (((((this._panic) || ((((this._metrics.bufferLength < this.PANIC_BUFFER_LEVEL)) && (this._metrics.reachedTargetBufferFull))))) ? 0 : -1));
        }
        private function monitorNetStatus(_arg1:NetStatusEvent):void{
            switch (_arg1.info.code){
                case "NetStream.Buffer.Full":
                    this._panic = false;
                    break;
                case "NetStream.Buffer.Empty":
                    if (Math.round(this._metrics.netStream.time) != 0){
                        this._panic = true;
                        this._reason = "Buffer was empty";
                    };
                    break;
                case "NetStream.Play.InsufficientBW":
                    this._panic = true;
                    this._reason = "Stream had insufficient bandwidth";
                    break;
            };
        }
        public function get reason():String{
            return (this._reason);
        }

    }
}//package org.openvideoplayer.net.dynamicstream 
﻿package org.openvideoplayer.net.dynamicstream {
    import flash.net.*;

    public interface INetStreamMetrics {

        function get reachedTargetBufferFull():Boolean;
        function set targetBufferTime(_arg1:Number):void;
        function get targetBufferTime():Number;
        function get expectedFPS():Number;
        function get droppedFPS():Number;
        function get maxBandwidth():Number;
        function get averageMaxBandwidth():Number;
        function get averageDroppedFPS():Number;
        function get currentIndex():uint;
        function get maxIndex():uint;
        function get dynamicStreamItem():DynamicStreamItem;
        function get bufferLength():Number;
        function get bufferTime():Number;
        function get netStream():NetStream;
        function get optimizeForLivebandwidthEstimate():Boolean;
        function set optimizeForLivebandwidthEstimate(_arg1:Boolean):void;
        function enable():void;
        function disable():void;

    }
}//package org.openvideoplayer.net.dynamicstream 
﻿package org.openvideoplayer.net {
    import flash.events.*;
    import org.openvideoplayer.net.dynamicstream.*;
    import org.openvideoplayer.events.*;
    import flash.utils.*;
    import flash.net.*;

    public class OvpDynamicNetStream extends OvpNetStream {

        private const RULE_CHECK_INTERVAL_IN_MS:Number = 500;
        private const BUFFER_STABLE:Number = 8;
        private const BUFFER_START:Number = 1;

        protected var _checkRulesTimer:Timer;
        protected var _switchingRules:Array;
        protected var _metricsProvider:MetricsProvider;
        protected var _streamIndex:int;
        protected var _oldStreamName:String;
        protected var _dsi:DynamicStreamItem;
        protected var _useManualSwitchMode:Boolean;
        protected var _switchUnderway:Boolean;
        protected var _renderingIndex:int;
        protected var _pendingIndex:Number;
        protected var _isMultibitrate:Boolean;
        protected var _reason:String;
        protected var _startingBuffer:Number;
        protected var _autoRateLimits:Boolean;
        protected var _rateLimits:Number;

        public function OvpDynamicNetStream(_arg1:NetConnection){
            super(_arg1);
            this.addEventListener(NetStatusEvent.NET_STATUS, this.handleNetStatus);
            _maxBufferLength = this.BUFFER_STABLE;
            this._startingBuffer = this.BUFFER_START;
            this._metricsProvider = new MetricsProvider(this);
            this._metricsProvider.targetBufferTime = _maxBufferLength;
            this._metricsProvider.addEventListener(OvpEvent.DEBUG, this.handleDebugEvents);
            this._checkRulesTimer = new Timer(this.RULE_CHECK_INTERVAL_IN_MS);
            this._checkRulesTimer.addEventListener(TimerEvent.TIMER, this.checkRules);
            this._autoRateLimits = true;
            this._useManualSwitchMode = false;
            this._switchingRules = new Array();
            this.addRule(new BandwidthRule(this._metricsProvider));
            this.addRule(new FrameDropRule(this._metricsProvider));
            this.addRule(new BufferRule(this._metricsProvider));
        }
        override public function close():void{
            _progressTimer.stop();
            _streamTimer.stop();
            this._metricsProvider.disable();
            super.close();
        }
        public function set autoRateLimits(_arg1:Boolean):void{
            this._autoRateLimits = _arg1;
        }
        public function get autoRateLimits():Boolean{
            return (this._autoRateLimits);
        }
        public function set rateLimits(_arg1:Number):void{
            if (!(this._autoRateLimits)){
                this._rateLimits = _arg1;
                this.setRateLimitsManual(this._rateLimits);
            } else {
                this.debug("autoRateLimits must be disabled before manual setting");
            };
        }
        public function get rateLimits():Number{
            return (this._rateLimits);
        }
        public function addRule(_arg1:ISwitchingRule):void{
            _arg1.addEventListener(OvpEvent.DEBUG, this.handleDebugEvents);
            this._switchingRules.push(_arg1);
        }
        public function addAndReplaceRule(_arg1:ISwitchingRule):void{
            this._switchingRules = new Array(_arg1);
        }
        public function clearRules():void{
            this._switchingRules = new Array();
        }
        public function get metricsProvider():INetStreamMetrics{
            return (this._metricsProvider);
        }
        public function get startingBuffer():Number{
            return (this._startingBuffer);
        }
        public function set startingBuffer(_arg1:Number):void{
            this._startingBuffer = _arg1;
        }
        override public function set maxBufferLength(_arg1:Number):void{
            _maxBufferLength = _arg1;
            this._metricsProvider.targetBufferTime = _maxBufferLength;
        }
        override public function play(... _args):void{
            if (!(_progressTimer.running)){
                _progressTimer.start();
            };
            if (!(_streamTimer.running)){
                _streamTimer.start();
            };
            if ((_args[0] is DynamicStreamItem)){
                this._dsi = (_args[0] as DynamicStreamItem);
                this._isMultibitrate = true;
                this._metricsProvider.enable();
                this._metricsProvider.optimizeForLivebandwidthEstimate = isLive;
                this.startPlay();
            } else {
                if ((_args[0] is String)){
                    this._metricsProvider.disable();
                    this._isMultibitrate = false;
                    super.play.apply(this, _args);
                };
            };
        }
        public function get maxIndex():int{
            return ((this._dsi.streamCount - 1));
        }
        public function get renderingIndex():uint{
            return (this._renderingIndex);
        }
        public function get playbackKiloBitsPerSecond():int{
            return (Math.round(((this.info.playbackBytesPerSecond * 8) / 0x0400)));
        }
        public function useManualSwitchMode(_arg1:Boolean):void{
            this._useManualSwitchMode = _arg1;
            if (this._useManualSwitchMode){
                this.debug("Manual switching enabled");
                this._checkRulesTimer.stop();
            } else {
                this.debug("Auto switching enabled");
                this._checkRulesTimer.start();
            };
        }
        public function switchUp():void{
            if (this._useManualSwitchMode){
                if ((this._streamIndex + 1) > (this._dsi.streamCount - 1)){
                    this.debug("Already playing the highest stream");
                    dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.INVALID_INDEX)));
                } else {
                    this.debug("Manually switching up");
                    this._reason = "Manual switch request.";
                    this.switchToIndex((this._streamIndex + 1), false);
                };
            };
        }
        public function switchDown():void{
            if (this._useManualSwitchMode){
                if ((this._streamIndex - 1) < 0){
                    this.debug("Already playing the lowest stream");
                    dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.INVALID_INDEX)));
                } else {
                    this.debug("Manually switching down");
                    this._reason = "Manual switch request.";
                    this.switchToIndex((this._streamIndex - 1), false);
                };
            };
        }
        public function switchTo(_arg1:int):void{
            if (this._useManualSwitchMode){
                if ((((_arg1 < 0)) || ((_arg1 > this.maxIndex)))){
                    this.debug("Requested switch index is out of range");
                    dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.INVALID_INDEX)));
                } else {
                    this.debug(("Manually switching to index " + _arg1));
                    this._reason = "Manual switch request.";
                    this.switchToIndex(_arg1, false);
                };
            };
        }
        public function get maxBandwidth():Number{
            return (this._metricsProvider.averageMaxBandwidth);
        }
        public function get currentStreamBitRate():Number{
            if ((((this._streamIndex < 0)) || ((this._streamIndex > this._dsi.streamCount)))){
                this.debug(("Error with currentStreamBitRate for " + this._streamIndex));
            };
            return (this._dsi.streams[this._streamIndex].rate);
        }
        override protected function onPlayStatus(_arg1:Object):void{
            var _local2:Object;
            switch (_arg1.code){
                case "NetStream.Play.TransitionComplete":
                    this._renderingIndex = this._pendingIndex;
                    this.debug((((("Transition complete to index " + this._renderingIndex) + " at ") + Math.round(this._dsi.getRateAt(this._renderingIndex))) + " kbps"));
                    _local2 = new Object();
                    _local2.renderingIndex = this._renderingIndex;
                    _local2.renderingBitrate = Math.round(this._dsi.getRateAt(this._renderingIndex));
                    dispatchEvent(new OvpEvent(OvpEvent.SWITCH_COMPLETE, _local2));
                    break;
                case "NetStream.Play.Complete":
                    dispatchEvent(new OvpEvent(OvpEvent.COMPLETE));
                    break;
            };
            dispatchEvent(new OvpEvent(OvpEvent.NETSTREAM_PLAYSTATUS, _arg1));
        }
        override public function play2(_arg1:NetStreamPlayOptions):void{
        }
        private function startPlay():void{
            var _local1:int;
            this._metricsProvider.dynamicStreamItem = this._dsi;
            this.bufferTime = ((isLive) ? _maxBufferLength : this._startingBuffer);
            this._streamIndex = 0;
            this._pendingIndex = NaN;
            if ((((this._dsi.startingIndex >= 0)) && ((this._dsi.startingIndex < this._dsi.streamCount)))){
                this._streamIndex = this._dsi.startingIndex;
            } else {
                if (this._metricsProvider.averageMaxBandwidth > 0){
                    _local1 = (this._dsi.streamCount - 1);
                    while (_local1 >= 0) {
                        if (this._metricsProvider.averageMaxBandwidth > this._dsi.getRateAt(_local1)){
                            this._streamIndex = _local1;
                            break;
                        };
                        _local1--;
                    };
                };
            };
            if (this._streamIndex == 0){
                this.chooseDefaultStartingIndex();
            } else {
                this.makeFirstSwitch();
            };
        }
        protected function chooseDefaultStartingIndex():void{
            var _local1:int;
            while (_local1 < this._dsi.streamCount) {
                if (300 < this._dsi.getRateAt(_local1)){
                    this._streamIndex = _local1;
                    break;
                };
                _local1++;
            };
            this.makeFirstSwitch();
        }
        protected function makeFirstSwitch():void{
            if (!(this._useManualSwitchMode)){
                this._checkRulesTimer.start();
            };
            if (this._autoRateLimits){
                this.setRateLimits((this._dsi.streamCount - 1));
            };
            this.debug((((("Starting with stream index " + this._streamIndex) + " at ") + Math.round(this._dsi.getRateAt(this._streamIndex))) + " kbps"));
            this.switchToIndex(this._streamIndex, true);
            this._metricsProvider.currentIndex = this._streamIndex;
        }
        private function setRateLimits(_arg1:int):void{
            this._rateLimits = (this._dsi.getRateAt(_arg1) * 1.4);
            this.debug((("Set rate limit to " + Math.round(this._rateLimits)) + " kbps"));
            _nc.call("setBandwidthLimit", null, ((this._rateLimits * 0x0400) / 8), ((this._rateLimits * 0x0400) / 8));
        }
        private function setRateLimitsManual(_arg1:Number):void{
            this._rateLimits = _arg1;
            this.debug((("Manually setting rate limit to " + this._rateLimits) + " kbps"));
            _nc.call("setBandwidthLimit", null, ((this._rateLimits * 0x0400) / 8), ((this._rateLimits * 0x0400) / 8));
        }
        protected function prepareNetStreamPlayOptions(_arg1:uint, _arg2:Boolean):NetStreamPlayOptions{
            var _local3:NetStreamPlayOptions = new NetStreamPlayOptions();
            _local3.start = this._dsi.start;
            _local3.len = this._dsi.len;
            _local3.streamName = this._dsi.getNameAt(_arg1);
            _local3.oldStreamName = this._oldStreamName;
            _local3.transition = ((_arg2) ? NetStreamPlayTransitions.RESET : NetStreamPlayTransitions.SWITCH);
            this._oldStreamName = this._dsi.getNameAt(_arg1);
            this.debug((((("Switching to index " + _arg1) + " at ") + Math.round(this._dsi.getRateAt(_arg1))) + " kbps"));
            return (_local3);
        }
        private function switchToIndex(_arg1:uint, _arg2:Boolean=false):void{
            var _local3:NetStreamPlayOptions = this.prepareNetStreamPlayOptions(_arg1, _arg2);
            var _local4:Object = new Object();
            _local4.targetIndex = _arg1;
            _local4.streamName = _local3.streamName;
            _local4.firstPlay = _arg2;
            _local4.reason = this._reason;
            dispatchEvent(new OvpEvent(OvpEvent.SWITCH_REQUESTED, _local4));
            if (_arg2){
                super.play(_local3.streamName, _local3.start, _local3.len);
            } else {
                super.play2(_local3);
            };
            if (((((!(_arg2)) && ((_arg1 < this._streamIndex)))) && (!(this._useManualSwitchMode)))){
                this._dsi.incrementFailCountAt(this._streamIndex);
            };
            if (_arg2){
                this._switchUnderway = false;
                this._renderingIndex = _arg1;
                this._streamIndex = _arg1;
                this._pendingIndex = _arg1;
                this.client.onPlayStatus({code:"NetStream.Play.TransitionComplete"});
            } else {
                this._switchUnderway = true;
            };
        }
        private function checkRules(_arg1:TimerEvent):void{
            var _local4:int;
            var _local2:int = int.MAX_VALUE;
            this._reason = "";
            var _local3:int;
            while (_local3 < this._switchingRules.length) {
                _local4 = this._switchingRules[_local3].getNewIndex();
                if (((!((_local4 == -1))) && ((_local4 < _local2)))){
                    _local2 = _local4;
                    this._reason = this._switchingRules[_local3].reason;
                };
                _local3++;
            };
            if (((((((((!((_local2 == -1))) && (!((_local2 == int.MAX_VALUE))))) && (!((_local2 == this._streamIndex))))) && (!(this._switchUnderway)))) && (this._dsi.isAvailable(_local2)))){
                this.debug(((("Calling for switch to " + _local2) + " at ") + this._dsi.getRateAt(_local2)));
                this.debug(("Reason: " + this._reason));
                this.switchToIndex(_local2);
            };
        }
        private function handleNetStatus(_arg1:NetStatusEvent):void{
            var _local2:Object;
            if (this._isMultibitrate){
                switch (_arg1.info.code){
                    case "NetStream.Buffer.Full":
                        if (((this._isMultibitrate) || (_useFastStartBuffer))){
                            this.bufferTime = _maxBufferLength;
                        };
                        break;
                    case "NetStream.Play.Start":
                        this.bufferTime = ((isLive) ? _maxBufferLength : this._startingBuffer);
                        break;
                    case "NetStream.Play.Transition":
                        this._switchUnderway = false;
                        this._streamIndex = this._dsi.indexFromName(_arg1.info.details);
                        if (this.autoRateLimits){
                            this.setRateLimits(this._streamIndex);
                        };
                        this._metricsProvider.currentIndex = this._streamIndex;
                        this._pendingIndex = this._streamIndex;
                        _local2 = new Object();
                        _local2.nsInfo = _arg1.info;
                        dispatchEvent(new OvpEvent(OvpEvent.SWITCH_ACKNOWLEDGED, _local2));
                        break;
                    case "NetStream.Play.Failed":
                        this._switchUnderway = false;
                        break;
                    case "NetStream.Seek.Notify":
                        this.bufferTime = ((isLive) ? _maxBufferLength : this._startingBuffer);
                        this._switchUnderway = false;
                        if (!(isNaN(this._pendingIndex))){
                            this._renderingIndex = this._pendingIndex;
                            this._pendingIndex = NaN;
                        };
                        break;
                    case "NetStream.Play.Stop":
                        this._checkRulesTimer.stop();
                        this.debug("Stopping rules since server has stopped sending data");
                        break;
                };
            };
        }
        protected function debug(_arg1:String):void{
            dispatchEvent(new OvpEvent(OvpEvent.DEBUG, _arg1));
        }
        private function handleDebugEvents(_arg1:OvpEvent):void{
            this.debug(_arg1.data.toString());
        }

    }
}//package org.openvideoplayer.net 
﻿package org.openvideoplayer.net {
    import flash.utils.*;

    public dynamic class OvpClientProxy extends Proxy {

        private var handlers:Dictionary;

        public function OvpClientProxy(){
            this.handlers = new Dictionary();
            super();
        }
        public function addHandler(_arg1:String, _arg2:Function):void{
            var _local3:Array = ((this.handlers.hasOwnProperty(_arg1)) ? this.handlers[_arg1] : this.handlers[_arg1] = []);
            if (_local3.indexOf(_arg2) == -1){
                _local3.push(_arg2);
            };
        }
        public function removeHandler(_arg1:String, _arg2:Function):Boolean{
            var _local3:Boolean;
            var _local4:Array;
            var _local5:int;
            if (this.handlers.hasOwnProperty(_arg1)){
                _local4 = this.handlers[_arg1];
                _local5 = _local4.indexOf(_arg2);
                if (_local5 != -1){
                    _local4.splice(_local5, 1);
                    _local3 = true;
                };
            };
            return (_local3);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function callProperty(_arg1, ... _args){
            return (this.invokeHandlers(_arg1, _args));
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function getProperty(_arg1){
            var result:* = undefined;
            var name:* = _arg1;
            result = function (){
                return (invokeHandlers(arguments.callee.name, arguments));
            };
            result.name = name;
            return (result);
        }
        private function invokeHandlers(_arg1:String, _arg2:Array){
            var _local3:Array;
            var _local4:Function;
            var _local5:Array;
            if (this.handlers.hasOwnProperty(_arg1)){
                _local3 = [];
                _local5 = this.handlers[_arg1];
                for each (_local4 in _local5) {
                    _local3.push(_local4.apply(null, _arg2));
                };
            };
            if (this.handlers.hasOwnProperty("all")){
                _local3 = [];
                _local5 = this.handlers["all"];
                for each (_local4 in _local5) {
                    _arg2.unshift(_arg1);
                    _local3.push(_local4.apply(null, _arg2));
                };
            };
            return (_local3);
        }

    }
}//package org.openvideoplayer.net 
﻿package org.openvideoplayer.net {
    import flash.net.*;
    import flash.events.*;

    public interface INetConnection extends IEventDispatcher {

        function get connected():Boolean;
        function get connectedProxyType():String;
        function get objectEncoding():uint;
        function set objectEncoding(_arg1:uint):void;
        function get proxyType():String;
        function set proxyType(_arg1:String):void;
        function get uri():String;
        function get usingTLS():Boolean;
        function addHeader(_arg1:String, _arg2:Boolean=false, _arg3:Object=null):void;
        function call(_arg1:String, _arg2:Responder, ... _args):void;
        function close():void;
        function connect(_arg1:String, ... _args):void;

    }
}//package org.openvideoplayer.net 
﻿package org.openvideoplayer.net {
    import flash.net.*;
    import flash.events.*;
    import flash.utils.*;
    import org.openvideoplayer.events.*;
    import org.openvideoplayer.utilities.*;
    import flash.media.*;

    public class OvpNetStream extends NetStream {

        private const DEFAULT_PROGRESS_INTERVAL:Number = 100;
        private const DEFAULT_STREAM_TIMEOUT:Number = 5000;

        protected var _progressTimer:Timer;
        protected var _streamTimer:Timer;
        protected var _isProgressive:Boolean;
        protected var _maxBufferLength:uint;
        protected var _useFastStartBuffer:Boolean;
        protected var _aboutToStop:uint;
        protected var _isBuffering:Boolean;
        protected var _nc:NetConnection;
        protected var _nsId3:OvpNetStream;
        protected var _volume:Number;
        protected var _panning:Number;
        protected var _streamTimeout:uint;
        protected var _streamLength:Number;
        protected var _isLive:Boolean;
        protected var _clientObject:Object;
        protected var _fastStartMinBufferLength:Number;
        protected var _createPDLPauseAndResumeEvents:Boolean;
        private var trickTimer:Timer;
        private var frameStepAmount:int;
        private var _slowMotionFrameStepAmount:uint = 1;
        private var _fastMotionFrameStepAmount:uint = 25;
        private var _slowMotionStepInterval:Number = 100;
        private var _fastMotionStepInterval:Number = 10;

        public function OvpNetStream(_arg1:Object){
            var _local2:NetConnection;
            if ((_arg1 is NetConnection)){
                _local2 = NetConnection(_arg1);
            } else {
                if ((_arg1 is OvpConnection)){
                    _local2 = NetConnection(_arg1.netConnection);
                };
            };
            super(_local2);
            this._isProgressive = (((((_local2.uri == null)) || ((_local2.uri == "null")))) ? true : false);
            this._nc = _local2;
            this._clientObject = null;
            this._maxBufferLength = 3;
            this.bufferTime = this._maxBufferLength;
            this._useFastStartBuffer = false;
            this._fastStartMinBufferLength = 0.5;
            this._aboutToStop = 0;
            this._isBuffering = false;
            this._volume = 1;
            this._panning = 0;
            this._streamLength = 0;
            this._isLive = false;
            this._createPDLPauseAndResumeEvents = false;
            this._nc.addEventListener(NetStatusEvent.NET_STATUS, this.connectionStatus);
            addEventListener(NetStatusEvent.NET_STATUS, this.streamStatus);
            addEventListener(AsyncErrorEvent.ASYNC_ERROR, this.asyncErrorHandler);
            this._progressTimer = new Timer(this.DEFAULT_PROGRESS_INTERVAL);
            this._progressTimer.addEventListener(TimerEvent.TIMER, this.updateProgress);
            this._streamTimer = new Timer(this.DEFAULT_STREAM_TIMEOUT);
            this._streamTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.streamTimeoutHandler);
            var _local3:OvpClientProxy = new OvpClientProxy();
            _local3.addHandler("all", this.onAllCallBacks);
            super.client = _local3;
        }
        public function get isProgressive():Boolean{
            return (this._isProgressive);
        }
        public function get fastStartMinBufferLength():Number{
            return (this._fastStartMinBufferLength);
        }
        public function set fastStartMinBufferLength(_arg1:Number):void{
            this._fastStartMinBufferLength = _arg1;
        }
        public function get progressInterval():Number{
            return (this._progressTimer.delay);
        }
        public function set progressInterval(_arg1:Number):void{
            this._progressTimer.delay = _arg1;
        }
        public function get maxBufferLength():Number{
            return (this._maxBufferLength);
        }
        public function set maxBufferLength(_arg1:Number):void{
            if (_arg1 < 0.1){
                dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.BUFFER_LENGTH)));
            } else {
                this._maxBufferLength = _arg1;
                this.bufferTime = this._maxBufferLength;
            };
        }
        public function get useFastStartBuffer():Boolean{
            return (this._useFastStartBuffer);
        }
        public function set useFastStartBuffer(_arg1:Boolean):void{
            this._useFastStartBuffer = _arg1;
            if (!(_arg1)){
                this.bufferTime = this._maxBufferLength;
            };
        }
        public function get isBuffering():Boolean{
            return (this._isBuffering);
        }
        public function get bufferTimeout():Number{
            return (NaN);
        }
        public function set bufferTimeout(_arg1:Number):void{
        }
        public function get bufferPercentage():Number{
            return (Math.min(100, Math.round(((bufferLength * 100) / bufferTime))));
        }
        public function get timeAsTimeCode():String{
            return (TimeUtil.timeCode(this.time));
        }
        public function get volume():Number{
            return (this._volume);
        }
        public function set volume(_arg1:Number):void{
            if ((((_arg1 < 0)) || ((_arg1 > 1)))){
                dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.VOLUME_OUT_OF_RANGE)));
                return;
            };
            this._volume = _arg1;
            soundTransform = new SoundTransform(this._volume, this._panning);
        }
        public function get panning():Number{
            return (this._panning);
        }
        public function set panning(_arg1:Number):void{
            if ((((_arg1 < -1)) || ((_arg1 > 1)))){
                dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.VOLUME_OUT_OF_RANGE)));
                return;
            };
            this._panning = _arg1;
            soundTransform = new SoundTransform(this._volume, this._panning);
        }
        public function get streamTimeout():Number{
            return ((this._streamTimeout / 1000));
        }
        public function set streamTimeout(_arg1:Number):void{
            this._streamTimeout = (_arg1 * 1000);
            this._streamTimer.delay = this._streamTimeout;
        }
        public function get streamLength():Number{
            return (this._streamLength);
        }
        override public function set client(_arg1:Object):void{
            this._clientObject = _arg1;
        }
        public function get netConnection():NetConnection{
            return (this._nc);
        }
        public function get isLive():Boolean{
            return (this._isLive);
        }
        public function set isLive(_arg1:Boolean):void{
            this._isLive = _arg1;
        }
        public function get createProgressivePauseEvents():Boolean{
            return (this._createPDLPauseAndResumeEvents);
        }
        public function set createProgressivePauseEvents(_arg1:Boolean):void{
            this._createPDLPauseAndResumeEvents = _arg1;
        }
        public function getMp3Id3Info(_arg1:String):Boolean{
            if (((!(this._nc)) || (!(this._nc.connected)))){
                return (false);
            };
            if (!((this._nsId3 is OvpNetStream))){
                this._nsId3 = new OvpNetStream(this._nc);
                this._nsId3.addEventListener(Event.ID3, this.onId3);
            };
            if ((((_arg1.slice(0, 4) == "mp3:")) || ((_arg1.slice(0, 4) == "id3:")))){
                _arg1 = _arg1.slice(4);
            };
            this._nsId3.play(("id3:" + _arg1));
            return (true);
        }
        override public function play(... _args):void{
            super.play.apply(this, _args);
            if (!(this._progressTimer.running)){
                this._progressTimer.start();
            };
            if (!(this._streamTimer.running)){
                this._streamTimer.start();
            };
        }
        override public function pause():void{
            var _local1:Object;
            super.pause();
            if (((this._isProgressive) && (this._createPDLPauseAndResumeEvents))){
                _local1 = new Object();
                _local1.code = "NetStream.Pause.Notify";
                _local1.description = "The stream is paused.";
                _local1.level = "status";
                dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, _local1));
            };
        }
        override public function resume():void{
            var _local1:Object;
            super.resume();
            if (((this._isProgressive) && (this._createPDLPauseAndResumeEvents))){
                _local1 = new Object();
                _local1.code = "NetStream.Unpause.Notify";
                _local1.description = "The stream is resumed.";
                _local1.level = "status";
                dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, _local1));
            };
        }
        override public function close():void{
            this._progressTimer.stop();
            this._streamTimer.stop();
            super.close();
        }
        protected function handleEnd():void{
            if (((this._nc) && ((this._nc.uri == "null")))){
                dispatchEvent(new OvpEvent(OvpEvent.COMPLETE));
            };
        }
        protected function updateProgress(_arg1:TimerEvent):void{
            dispatchEvent(new OvpEvent(OvpEvent.PROGRESS));
        }
        protected function connectionStatus(_arg1:NetStatusEvent):void{
            switch (_arg1.info.code){
                case "NetConnection.Connect.Closed":
                    this.close();
                    break;
            };
        }
        protected function streamStatus(_arg1:NetStatusEvent):void{
            if (this._useFastStartBuffer){
                if ((((_arg1.info.code == "NetStream.Play.Start")) || ((_arg1.info.code == "NetStream.Buffer.Empty")))){
                    this.bufferTime = this._fastStartMinBufferLength;
                };
                if (_arg1.info.code == "NetStream.Buffer.Full"){
                    this.bufferTime = this._maxBufferLength;
                };
            };
            switch (_arg1.info.code){
                case "NetStream.Pause.Notify":
                    break;
                case "NetStream.Play.Start":
                    this._aboutToStop = 0;
                    this._isBuffering = true;
                    this._streamTimer.stop();
                    break;
                case "NetStream.Play.Stop":
                    if (this._aboutToStop == 2){
                        this._aboutToStop = 0;
                        this.handleEnd();
                    } else {
                        this._aboutToStop = 1;
                    };
                    break;
                case "NetStream.Buffer.Empty":
                    this._isBuffering = true;
                    if (this._aboutToStop == 1){
                        this._aboutToStop = 0;
                        this.handleEnd();
                    } else {
                        this._aboutToStop = 2;
                    };
                    break;
                case "NetStream.Buffer.Full":
                    this._isBuffering = false;
                    break;
                case "NetStream.Buffer.Flush":
                    this._isBuffering = false;
                    if (this._aboutToStop == 1){
                        this._aboutToStop = 0;
                        this.handleEnd();
                    } else {
                        this._aboutToStop = 2;
                    };
                    break;
            };
        }
        protected function onMetaData(_arg1:Object):void{
            var _local2:Object;
            dispatchEvent(new OvpEvent(OvpEvent.NETSTREAM_METADATA, _arg1));
            if (((this._isProgressive) && (!(isNaN(_arg1["duration"]))))){
                _local2 = new Object();
                _local2.streamLength = Number(_arg1["duration"]);
                this._streamLength = _local2.streamLength;
                dispatchEvent(new OvpEvent(OvpEvent.STREAM_LENGTH, _local2));
            };
        }
        protected function onXMPData(_arg1:Object):void{
            dispatchEvent(new OvpEvent(OvpEvent.NETSTREAM_XMPDATA, _arg1));
        }
        protected function onImageData(_arg1:Object):void{
            dispatchEvent(new OvpEvent(OvpEvent.NETSTREAM_IMAGEDATA, _arg1));
        }
        protected function onTextData(_arg1:Object):void{
            dispatchEvent(new OvpEvent(OvpEvent.NETSTREAM_TEXTDATA, _arg1));
        }
        protected function onCuePoint(_arg1:Object):void{
            dispatchEvent(new OvpEvent(OvpEvent.NETSTREAM_CUEPOINT, _arg1));
        }
        protected function onPlayStatus(_arg1:Object):void{
            dispatchEvent(new OvpEvent(OvpEvent.NETSTREAM_PLAYSTATUS, _arg1));
            if (_arg1.code == "NetStream.Play.Complete"){
                dispatchEvent(new OvpEvent(OvpEvent.COMPLETE));
            };
        }
        protected function handleBufferFailure(_arg1:TimerEvent):void{
            if (((!(this._isProgressive)) && ((super.bufferLength == 0)))){
                dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.STREAM_BUFFER_EMPTY)));
            };
        }
        protected function onId3(_arg1:Object):void{
            dispatchEvent(new OvpEvent(OvpEvent.MP3_ID3, _arg1));
        }
        protected function streamTimeoutHandler(_arg1:TimerEvent):void{
            dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.STREAM_NOT_FOUND)));
        }
        protected function asyncErrorHandler(_arg1:AsyncErrorEvent):void{
            dispatchEvent(new OvpEvent(OvpEvent.ASYNC_ERROR, _arg1.text));
        }
        protected function onFI(_arg1:Object):void{
            dispatchEvent(new OvpEvent(OvpEvent.ONFI, _arg1));
        }
        protected function onLastSecond(_arg1:Object):void{
            dispatchEvent(new OvpEvent(OvpEvent.ONLASTSECOND, _arg1));
        }
        protected function onAllCallBacks(... _args):void{
            var _local2:Object = _args[1];
            var _local3:String = (_args[0] as String);
            if (((!((this._clientObject == null))) && (this._clientObject.hasOwnProperty(_local3)))){
                (this._clientObject[_local3] as Function).apply(this, [_local2]);
            };
            switch (_local3){
                case "onMetaData":
                    this.onMetaData(_local2);
                    break;
                case "onCuePoint":
                    this.onCuePoint(_local2);
                    break;
                case "onPlayStatus":
                    this.onPlayStatus(_local2);
                    break;
                case "onXMPData":
                    this.onXMPData(_local2);
                    break;
                case "onImageData":
                    this.onImageData(_local2);
                    break;
                case "onTextData":
                    this.onTextData(_local2);
                    break;
                case "onFI":
                    this.onFI(_local2);
                    break;
                case "onId3":
                    this.onId3(_local2);
                    break;
                case "onLastSecond":
                    this.onLastSecond(_local2);
                    break;
                default:
                    dispatchEvent(new OvpEvent(OvpEvent.DATA_MESSAGE, {
                        name:_local3,
                        value:_local2
                    }));
            };
        }
        public function slowMotionOn(_arg1:Boolean=true, _arg2:Number=NaN, _arg3:Number=NaN):void{
            this._slowMotionStepInterval = ((isNaN(_arg3)) ? this._slowMotionStepInterval : _arg3);
            this._slowMotionFrameStepAmount = ((isNaN(_arg2)) ? this._slowMotionFrameStepAmount : _arg2);
            this.frameStepAmount = ((_arg1) ? this._slowMotionFrameStepAmount : (this._slowMotionFrameStepAmount * -1));
            this.doTrickMode(this._slowMotionStepInterval);
        }
        public function fastMotionOn(_arg1:Boolean=true, _arg2:Number=NaN, _arg3:Number=NaN):void{
            this._fastMotionStepInterval = ((isNaN(_arg3)) ? this._fastMotionStepInterval : _arg3);
            this._fastMotionFrameStepAmount = ((isNaN(_arg2)) ? this._fastMotionFrameStepAmount : _arg2);
            this.frameStepAmount = ((_arg1) ? this._fastMotionFrameStepAmount : (this._fastMotionFrameStepAmount * -1));
            this.doTrickMode(this._fastMotionStepInterval);
        }
        public function trickMotionModeOff():void{
            this.killTrickTimer();
        }
        public function set slowMotionFrameStepAmount(_arg1:uint):void{
            this._slowMotionFrameStepAmount = _arg1;
        }
        public function get slowMotionFrameStepAmount():uint{
            return (this._slowMotionFrameStepAmount);
        }
        public function set fastMotionFrameStepAmount(_arg1:uint):void{
            this._fastMotionFrameStepAmount = _arg1;
        }
        public function get fastMotionFrameStepAmount():uint{
            return (this._fastMotionFrameStepAmount);
        }
        public function set slowMotionStepInterval(_arg1:uint):void{
            this._slowMotionStepInterval = _arg1;
        }
        public function get slowMotionStepInterval():uint{
            return (this._slowMotionStepInterval);
        }
        public function set fastMotionStepInterval(_arg1:uint):void{
            this._fastMotionStepInterval = _arg1;
        }
        public function get fastMotionStepInterval():uint{
            return (this._fastMotionStepInterval);
        }
        private function doTrickMode(_arg1:Number):void{
            this.killTrickTimer();
            this.getTrickTimer(_arg1).start();
        }
        private function onTrickMotion(_arg1:TimerEvent):void{
            step(this.frameStepAmount);
            dispatchEvent(new OvpEvent(OvpEvent.TRICK_MODE_TIMER_TICK));
        }
        private function getTrickTimer(_arg1:Number):Timer{
            this.trickTimer = new Timer(_arg1);
            this.trickTimer.addEventListener(TimerEvent.TIMER, this.onTrickMotion);
            return (this.trickTimer);
        }
        private function killTrickTimer():void{
            if (this.trickTimer != null){
                if (this.trickTimer.running){
                    this.trickTimer.stop();
                };
                this.trickTimer.removeEventListener(TimerEvent.TIMER, this.onTrickMotion);
                this.trickTimer = null;
            };
        }

    }
}//package org.openvideoplayer.net 
﻿package com.akamai.playeranalytics {
    import com.akamai.playeranalytics.handler.*;
    import flash.utils.*;
    import com.akamai.playeranalytics.loader.*;
    import com.akamai.playeranalytics.loader.events.*;
    import flash.events.*;
    import flash.external.*;
    import flash.system.*;

    public class AnalyticsPluginLoader {

        public static const JS_LOG_WINDOW:String = "2";
        public static const NO_LOG_WINDOW:String = "0";
        public static const FLEX_LOG_WINDOW:String = "1";

        private static var _loadStartTime:int;
        private static var loader:ClassLoader;
        private static var _akamaiAnalyticsHandler:AkamaiAnalyticsHandler = new AkamaiAnalyticsHandler();
        private static var AnalyticsPlugin:Object;
        public static var loadDelay:Number = 0;
        private static var _loaderVersion:String;
        private static var _loaderName:String;
        private static var _analyticsPluginDispatcher:AnalyticsPluginDispatcher;
        private static var _configurationXmlPath:Object;

        public function AnalyticsPluginLoader(){
            super();
        }
        public static function handleConnectSuccess():void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.handleConnectSuccess();
            } else {
                _akamaiAnalyticsHandler.insertFunction0("handleConnectSuccess");
            };
        }
        public static function setVisitId(visitId:String):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setVisitId(visitId);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("setVisitId", visitId);
            };
        }
        public static function setAttemptId(attemptId:String):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setAttemptId(attemptId);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("setAttemptId", attemptId);
            };
        }
        public static function onApplicationClose(e:Event):void{
            var e:* = e;
            if (AnalyticsPlugin != null){
                try {
                    AnalyticsPlugin.onApplicationClose(e);
                } catch(e:Error) {
                };
            } else {
                _akamaiAnalyticsHandler.insertFunction1("onApplicationClose", e);
            };
        }
        public static function setStreamLength(streamLength:Number):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setStreamLength(streamLength);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("setStreamLength", streamLength);
            };
        }
        public static function setNetStreamInfo(ns:Object, playString:Object):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setNetStreamInfo(ns, playString);
            } else {
                _akamaiAnalyticsHandler.setNetStreamInfo(ns, playString);
            };
        }
        public static function init(configurationXmlPath:Object):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.init(configurationXmlPath);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("init", configurationXmlPath);
            };
        }
        public static function setDebug(value:Boolean):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setDebug(value);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("setDebug", value);
            };
        }
        public static function setLogWindow(logWindowType:String):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setLogWindow(logWindowType);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("setLogWindow", logWindowType);
            };
        }
        private static function onPluginLoaded(e:Event):void{
            setTimeout(callPlugin, loadDelay);
        }
        public static function handleMetaData(metaDataObject:Object, streamTime:Number=-1):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.handleMetaData(metaDataObject, -1, streamTime);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("handleMetaData", metaDataObject, streamTime);
            };
        }
        public static function setConnectUri(connectUri:String):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setConnectUri(connectUri);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("setConnectUri", connectUri);
            };
        }
        public static function handleBufferEmpty(streamTime:Number=-1):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.handleBufferEmpty(-1, streamTime);
            } else {
                _akamaiAnalyticsHandler.insertFunction0("handleBufferEmpty", streamTime);
            };
        }
        public static function getPlugin():Object{
            return (AnalyticsPlugin);
        }
        public static function setDynamicStreamInfo(dynamicStreamInfo:Object):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setDynamicStreamInfo(dynamicStreamInfo);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("setDynamicStreamInfo", dynamicStreamInfo);
            };
        }
        public static function setData(name:String, value:Object):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setData(name, value);
            } else {
                _akamaiAnalyticsHandler.insertFunction2("setData", name, value);
            };
        }
        public static function resume():void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.resume();
            } else {
                _akamaiAnalyticsHandler.insertFunction0("resume");
            };
        }
        public static function handlePause(streamTime:Number=-1):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.handlePause(-1, streamTime);
            } else {
                _akamaiAnalyticsHandler.insertFunction0("handlePause", streamTime);
            };
        }
        private static function loadErrorHandler(e:Event):void{
            AkamaiAnalyticsTimer.destroy();
            _analyticsPluginDispatcher.dispatchEvent(new AnalyticsEvent(AnalyticsEvent.ON_PLUGIN_ERROR));
        }
        private static function callPlugin():void{
            var loadTime:* = (getTimer() - _loadStartTime);
            AnalyticsPlugin = loader.getClass("com.akamai.playeranalytics.AnalyticsPlugin");
            try {
                AnalyticsPlugin.loaderTime = getTimer();
            } catch(e:Error) {
            };
            AnalyticsPlugin.loadTime = loadTime;
            AnalyticsPlugin.setLoaderInfo({
                name:loaderName,
                version:loaderVersion,
                csmaLoader:AnalyticsPluginLoaderVersion.VERSION
            });
            if (_configurationXmlPath != null){
                AnalyticsPlugin.init(_configurationXmlPath);
            };
            if (_akamaiAnalyticsHandler != null){
                AnalyticsPlugin.connectDelay = (getTimer() - _akamaiAnalyticsHandler.initTime);
                AnalyticsPlugin.setInitTimerData(AkamaiAnalyticsTimer.getData());
                _akamaiAnalyticsHandler.callFunctions(AnalyticsPlugin);
            };
            try {
                AnalyticsPlugin.setContentLoaderInfo(loader.getContentLoaderInfo());
            } catch(e:Error) {
            };
            if (_analyticsPluginDispatcher != null){
                _analyticsPluginDispatcher.dispatchEvent(new AnalyticsEvent(AnalyticsEvent.ON_PLUGIN_LOAD));
            };
            AkamaiAnalyticsTimer.destroy();
        }
        public static function handleBufferFull(streamTime:Number=-1):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.handleBufferFull(-1, streamTime);
            } else {
                _akamaiAnalyticsHandler.insertFunction0("handleBufferFull", streamTime);
            };
        }
        public static function handleFirstPlay(playObject:Object):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.handleFirstPlay(playObject);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("handleFirstPlay", playObject);
            };
        }
        public static function get loaderName():String{
            if (((!((_loaderName == null))) && (!((_loaderName == ""))))){
                return (_loaderName);
            };
            return ("csmaLoader");
        }
        public static function handlePlayEnd(streamTime:Number=-1):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.handlePlayEnd(-1, streamTime);
            } else {
                _akamaiAnalyticsHandler.insertFunction0("handlePlayEnd", streamTime);
            };
        }
        public static function loadPlugin(pluginPath:String, configurationXmlPath:Object):void{
            _loadStartTime = getTimer();
            _configurationXmlPath = configurationXmlPath;
            loader = new ClassLoader();
            loader.addEventListener(ClassLoader.LOAD_ERROR, loadErrorHandler);
            loader.addEventListener(ClassLoader.CLASS_LOADED, onPluginLoaded);
            loader.load(pluginPath);
            if (_analyticsPluginDispatcher == null){
                _analyticsPluginDispatcher = new AnalyticsPluginDispatcher();
            };
        }
        public static function get loaderVersion():String{
            if (((!((_loaderVersion == null))) && (!((_loaderVersion == ""))))){
                return (_loaderVersion);
            };
            return (AnalyticsPluginLoaderVersion.VERSION);
        }
        public static function handleError(errorObject:Object, streamTime:Number=-1):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.handleError(errorObject, -1, streamTime);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("handleError", errorObject, streamTime);
            };
        }
        public static function addEventListener(type:String, listener:Function, useCapture:Boolean=false, priority:int=0, useWeakReference:Boolean=false):void{
            if (_analyticsPluginDispatcher == null){
                _analyticsPluginDispatcher = new AnalyticsPluginDispatcher();
            };
            _analyticsPluginDispatcher.addEventListener(type, listener, useCapture, priority, useWeakReference);
        }
        public static function setViewerId(viewerId:String):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setViewerId(viewerId);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("setViewerId", viewerId);
            };
        }
        public static function setMetaData(metaDataObject:Object):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setMetaData(metaDataObject);
            } else {
                AkamaiAnalyticsTimer.setMetaData(metaDataObject);
                _akamaiAnalyticsHandler.insertFunction1("setMetaData", metaDataObject);
            };
        }
        public static function handlePlayStart(streamTime:Number=-1):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.handlePlayStart(-1, streamTime);
            } else {
                _akamaiAnalyticsHandler.insertFunction0("handlePlayStart", streamTime);
            };
        }
        public static function handleSeek(streamTime:Number=-1):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.handleSeek(-1, streamTime);
            } else {
                _akamaiAnalyticsHandler.insertFunction0("handleSeek", streamTime);
            };
        }
        private static function logLineHandler(e:Object):void{
            if (((((!((e == null))) && (e.hasOwnProperty("data")))) && (!((e.data == null))))){
                _analyticsPluginDispatcher.dispatchEvent(new AnalyticsEvent(AnalyticsEvent.LOGLINE, e.data));
            };
        }
        public static function setDynamicStreamInitInfo(dynamicStreamInitInfo:Array):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setDynamicStreamInitInfo(dynamicStreamInitInfo);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("setDynamicStreamInitInfo", dynamicStreamInitInfo);
            };
        }
        public static function setupNetConnection(nc:Object, connectString:String):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setupNetConnection(nc, connectString);
            } else {
                _akamaiAnalyticsHandler.insertFunction2("setupNetConnection", nc, connectString);
            };
        }
        public static function setPlayUrl(playUrl:Object):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setPlayUrl(playUrl);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("setPlayUrl", playUrl);
            };
        }
        public static function setLoaderInfo(loaderInfo:Object):void{
            if (loaderInfo != null){
                if (loaderInfo.hasOwnProperty("version")){
                    _loaderVersion = loaderInfo.version;
                };
                if (loaderInfo.hasOwnProperty("name")){
                    _loaderName = loaderInfo.name;
                };
            };
        }
        public static function setNetConnectionInfo(nc:Object, connectString:String):void{
            var Application:* = null;
            var nc:* = nc;
            var connectString:* = connectString;
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setNetConnectionInfo(nc, connectString);
                AnalyticsPlugin.addEventListener("logline", logLineHandler);
                AnalyticsPlugin.addEventListener("debug", debugHandler);
            } else {
                _akamaiAnalyticsHandler.setNetConnectionInfo(nc, connectString);
                _akamaiAnalyticsHandler.insertFunction2("addEventListener", "logline", logLineHandler);
                _akamaiAnalyticsHandler.insertFunction2("addEventListener", "debug", debugHandler);
            };
            if (!(ExternalInterface.available)){
                try {
                    Application = (ApplicationDomain.currentDomain.getDefinition("mx.core.Application") as Class);
                    if (((!((Application == null))) && (!((Application.application == null))))){
                        Application.application.addEventListener("closing", onApplicationClose);
                    };
                } catch(e:Error) {
                };
            };
        }
        public static function handleSwitchStart(switchObject:Object, streamTime:Number=-1):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.handleSwitchStart(switchObject, -1, streamTime);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("handleSwitchStart", switchObject, streamTime);
            };
        }
        public static function setConnectionStart():void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setConnectionStart();
            } else {
                _akamaiAnalyticsHandler.insertFunction0("setConnectionStart");
            };
        }
        public static function setCDN(cdn:String):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setCDN(cdn);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("setCDN", cdn);
            };
        }
        public static function setAdData(adArray:Array):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.setAdData(adArray);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("setAdData", adArray);
            };
        }
        public static function handleResume(streamTime:Number=-1):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.handleResume(-1, streamTime);
            } else {
                _akamaiAnalyticsHandler.insertFunction0("handleResume", streamTime);
            };
        }
        public static function pause():void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.pause();
            } else {
                _akamaiAnalyticsHandler.insertFunction0("pause");
            };
        }
        private static function debugHandler(e:Object):void{
            if (((((!((e == null))) && (e.hasOwnProperty("data")))) && (!((e.data == null))))){
                _analyticsPluginDispatcher.dispatchEvent(new AnalyticsEvent(AnalyticsEvent.DEBUG, e.data));
            };
        }
        public static function seek(seekToTime:Number=-1):void{
            if (AnalyticsPlugin != null){
                AnalyticsPlugin.seek(seekToTime);
            } else {
                _akamaiAnalyticsHandler.insertFunction1("seek", seekToTime);
            };
        }
        public static function getPluginVersion():String{
            if (AnalyticsPlugin != null){
                return (AnalyticsPlugin.getVersion());
            };
            return ("");
        }

    }
}//package com.akamai.playeranalytics 

import flash.events.*;

class AnalyticsPluginDispatcher extends EventDispatcher {

    public function AnalyticsPluginDispatcher(){
        super();
    }
}
﻿package com.akamai.playeranalytics.handler {
    import flash.utils.*;
    import flash.events.*;

    public class AkamaiAnalyticsHandler {

        private var _nc:Object;
        public var functions:Array;
        private var _ns:Object;
        public var initTime:Number;

        public function AkamaiAnalyticsHandler(){
            super();
            functions = new Array();
        }
        private function getTime():Number{
            return (getTimer());
        }
        public function onStreamLength(e:Object):void{
            insertFunction1("onStreamLength", e);
        }
        public function setNetStreamInfo(ns:Object, playString:Object):void{
            _ns = ns;
            insertFunction2("setNetStreamInfo", ns, playString);
            _ns.addEventListener(NetStatusEvent.NET_STATUS, onStreamStatus);
            _ns.addEventListener("isbuffering", onIsBuffering);
            _ns.addEventListener("play", onPlay);
            _ns.addEventListener("play_start", onPlay);
            _ns.addEventListener("parsed", onSmilParse);
            _ns.addEventListener("metadata", onMetaData);
            _ns.addEventListener("streamlength", onStreamLength);
            _ns.addEventListener("pause", onPause);
            _ns.addEventListener("resume", onResume);
            _ns.addEventListener("seek", onSeek);
            _ns.addEventListener("switchstart", onSwitchStart);
            _ns.addEventListener("switchcomplete", onSwitchComplete);
            _ns.addEventListener("switchRequested", onSwitchRequested);
            _ns.addEventListener("switchAcknowledged", onSwitchAcknowledged);
            _ns.addEventListener("switchComplete", onSwitchComplete);
            _ns.addEventListener("playstatus", onPlayStatus);
            _ns.addEventListener("error", onHDError);
            _ns.addEventListener("complete", onComplete);
            _ns.addEventListener("loop", onLoop);
            _ns.addEventListener("datamessage", onHDDataMessage);
            _ns.addEventListener("rebuffer", onHDRebuffer);
            _ns.addEventListener("rtt", onHDRTT);
        }
        public function onPlayStatus(e:Object):void{
            insertFunction1("onPlayStatus", e);
        }
        public function onMetaData(e:Object):void{
            AkamaiAnalyticsTimer.setMetaData(e);
            insertFunction1("onMetaData", e);
        }
        public function onNetStatus(event:NetStatusEvent):void{
            insertFunction1("onNetStatus", event);
        }
        public function onStreamStatus(event:NetStatusEvent):void{
            if (event.info.code == "NetStream.Buffer.Full"){
                AkamaiAnalyticsTimer.init(_ns);
            };
            insertFunction1("onStreamStatus", event);
        }
        public function onSwitchComplete(e:Object):void{
            insertFunction1("onSwitchComplete", e);
        }
        public function onPause(e:Object):void{
            insertFunction1("onPause", e);
        }
        public function callFunctions(AnalyticsPlugin:Object):void{
            var functionObject:* = null;
            var functionName:* = null;
            var functionArgs:* = NaN;
            var fn:* = null;
            var AnalyticsPlugin:* = AnalyticsPlugin;
            if (functions != null){
                while (functions.length != 0) {
                    functionObject = functions.shift();
                    if (functionObject != null){
                        functionName = String(functionObject.name);
                        functionArgs = Number(functionObject.args);
                        fn = (AnalyticsPlugin[functionName] as Function);
                        if (fn != null){
                            try {
                                if (functionArgs == 2){
                                    fn.call(null, functionObject.arg1, functionObject.arg2);
                                } else {
                                    if (functionArgs == 3){
                                        fn.call(null, functionObject.arg1, functionObject.arg2, functionObject.arg3);
                                    } else {
                                        if (functionArgs == 4){
                                            fn.call(null, functionObject.arg1, functionObject.arg2, functionObject.arg3, functionObject.arg4);
                                        };
                                    };
                                };
                            } catch(e:Error) {
                            };
                        };
                    };
                };
            };
        }
        public function onSmilParse(e:Object):void{
            insertFunction1("onSmilParse", e);
        }
        public function insertFunction0(name:String, streamTime:Number=-1):void{
            if (streamTime == -1){
                functions.push({
                    name:name,
                    args:2,
                    arg1:getTime(),
                    arg2:nsTime
                });
            } else {
                functions.push({
                    name:name,
                    args:2,
                    arg1:getTime(),
                    arg2:streamTime
                });
            };
        }
        public function insertFunction1(name:String, arg1:Object, streamTime:Number=-1):void{
            if (streamTime == -1){
                functions.push({
                    name:name,
                    args:3,
                    arg1:arg1,
                    arg2:getTime(),
                    arg3:nsTime
                });
            } else {
                functions.push({
                    name:name,
                    args:3,
                    arg1:arg1,
                    arg2:getTime(),
                    arg3:streamTime
                });
            };
        }
        public function insertFunction2(name:String, arg1:Object, arg2:Object):void{
            functions.push({
                name:name,
                args:4,
                arg1:arg1,
                arg2:arg2,
                arg3:getTime(),
                arg4:nsTime
            });
        }
        public function onSwitchAcknowledged(e:Object):void{
            insertFunction1("onSwitchAcknowledged", e);
        }
        public function onLoop(e:Object):void{
            insertFunction1("onLoop", e);
        }
        public function onHDRTT(e:Object):void{
            insertFunction1("onHDRTT", e);
        }
        public function setNetConnectionInfo(nc:Object, connectString:String):void{
            initTime = getTimer();
            insertFunction2("setNetConnectionInfo", nc, connectString);
            _nc = nc;
            if (nc != null){
                nc.addEventListener(NetStatusEvent.NET_STATUS, onNetStatus);
                nc.addEventListener("streamlength", onStreamLength);
            };
        }
        public function onHDDataMessage(e:Object):void{
            insertFunction1("onHDDataMessage", e);
        }
        public function removeListeners():void{
            if (_nc != null){
                _nc.removeEventListener(NetStatusEvent.NET_STATUS, onNetStatus);
                _nc.removeEventListener("streamlength", onStreamLength);
            };
            if (_ns != null){
                _ns.removeEventListener(NetStatusEvent.NET_STATUS, onStreamStatus);
                _ns.removeEventListener("isbuffering", onIsBuffering);
                _ns.removeEventListener("play", onPlay);
                _ns.removeEventListener("play_start", onPlay);
                _ns.removeEventListener("parsed", onSmilParse);
                _ns.removeEventListener("metadata", onMetaData);
                _ns.removeEventListener("streamlength", onStreamLength);
                _ns.removeEventListener("pause", onPause);
                _ns.removeEventListener("resume", onResume);
                _ns.removeEventListener("seek", onSeek);
                _ns.removeEventListener("switchstart", onSwitchStart);
                _ns.removeEventListener("switchcomplete", onSwitchComplete);
                _ns.removeEventListener("switchRequested", onSwitchRequested);
                _ns.removeEventListener("switchAcknowledged", onSwitchAcknowledged);
                _ns.removeEventListener("switchComplete", onSwitchComplete);
                _ns.removeEventListener("playstatus", onPlayStatus);
                _ns.removeEventListener("error", onHDError);
                _ns.removeEventListener("complete", onComplete);
                _ns.removeEventListener("loop", onLoop);
                _ns.removeEventListener("datamessage", onHDDataMessage);
                _ns.removeEventListener("rebuffer", onHDRebuffer);
                _ns.removeEventListener("rtt", onHDRTT);
            };
        }
        public function onResume(e:Object):void{
            insertFunction1("onResume", e);
        }
        public function onHDError(e:Object):void{
            insertFunction1("onHDError", e);
        }
        public function onHDRebuffer(e:Object):void{
            insertFunction1("onHDRebuffer", e);
        }
        public function onSwitchStart(e:Object):void{
            insertFunction1("onSwitchStart", e);
        }
        public function get nsTime():Number{
            if (_ns != null){
                return (Number(_ns.time));
            };
            return (0);
        }
        public function onPlay(e:Object):void{
            insertFunction1("onPlay", e);
        }
        public function onSeek(e:Object):void{
            insertFunction1("onSeek", e);
        }
        public function onComplete(e:Object):void{
            insertFunction1("onComplete", e);
        }
        public function onIsBuffering(e:Object):void{
            insertFunction1("onIsBuffering", e);
        }
        public function onSwitchRequested(e:Object):void{
            insertFunction1("onSwitchRequested", e);
        }

    }
}//package com.akamai.playeranalytics.handler 
﻿package com.akamai.playeranalytics.handler {
    import flash.utils.*;
    import flash.events.*;

    public class AkamaiAnalyticsTimer {

        private static var oAkamaiAnalyticsTimer:AkamaiAnalyticsTimer;
        private static var _metaData:Object;

        private var _ns:Object;
        public var playTimerCount:uint;
        private var _playTimer:Timer;
        public var playTimerData:Object;
        private var _prevBytesLoaded:Number = 0;

        public function AkamaiAnalyticsTimer(){
            super();
        }
        public static function init(ns:Object):void{
            if (oAkamaiAnalyticsTimer == null){
                oAkamaiAnalyticsTimer = new (AkamaiAnalyticsTimer)();
                oAkamaiAnalyticsTimer.startTimer(ns);
            };
        }
        public static function setMetaData(e:Object):void{
            if (e.hasOwnProperty("data")){
                _metaData = e.data;
            } else {
                _metaData = e;
            };
        }
        public static function getData():Object{
            if (oAkamaiAnalyticsTimer != null){
                if (oAkamaiAnalyticsTimer.playTimerData != null){
                    oAkamaiAnalyticsTimer.playTimerData["timerCount"] = oAkamaiAnalyticsTimer.playTimerCount;
                };
                return (oAkamaiAnalyticsTimer.playTimerData);
            };
            return (null);
        }
        public static function destroy():void{
            if (oAkamaiAnalyticsTimer != null){
                oAkamaiAnalyticsTimer.stopTimer();
            };
        }

        public function startTimer(ns:Object):void{
            _ns = ns;
            _playTimer = new Timer(500);
            _playTimer.addEventListener(TimerEvent.TIMER, playTimeHandler);
            playTimerData = new Object();
            _playTimer.start();
        }
        private function playTimeHandler(event:TimerEvent):void{
            var _bytesLoaded:* = NaN;
            var encodedFPS:* = NaN;
            var bandwidthPercent:* = NaN;
            var event:* = event;
            try {
                if (_ns != null){
                    playTimerCount++;
                    addData("currentFPS", _ns.currentFPS);
                    addData("bufferTime", _ns.bufferTime);
                    addData("bufferLength", _ns.bufferLength);
                    _bytesLoaded = Number(_ns.bytesLoaded);
                    addData("totalBandwidth_PD", ((_bytesLoaded - _prevBytesLoaded) / 0.5));
                    _prevBytesLoaded = _bytesLoaded;
                    if (_metaData != null){
                        encodedFPS = 0;
                        if (_metaData.hasOwnProperty("framerate")){
                            encodedFPS = Number(_metaData["framerate"]);
                        } else {
                            if (_metaData.hasOwnProperty("videoframerate")){
                                encodedFPS = Number(_metaData["videoframerate"]);
                            };
                        };
                        if (((!(isNaN(encodedFPS))) && (!((encodedFPS == 0))))){
                            addData("fpsPercent", (_ns.currentFPS / encodedFPS));
                            addData("fpsPercentCount", 1);
                        };
                    };
                    if (_ns.hasOwnProperty("info")){
                        addData("playbackBytesPerSecond", _ns.info.playbackBytesPerSecond);
                        addData("currentBytesPerSecond", _ns.info.currentBytesPerSecond);
                        addData("maxBytesPerSecond", _ns.info.maxBytesPerSecond);
                        addData("audioBytesPerSecond", _ns.info.audioBytesPerSecond);
                        addData("videoBytesPerSecond", _ns.info.videoBytesPerSecond);
                        addData("dataBytesPerSecond", _ns.info.dataBytesPerSecond);
                        addData("audioBufferLength", _ns.info.audioBufferLength);
                        addData("videoBufferLength", _ns.info.videoBufferLength);
                        addData("dataBufferLength", _ns.info.dataBufferLength);
                        addData("audioBufferByteLength", _ns.info.audioBufferByteLength);
                        addData("videoBufferByteLength", _ns.info.videoBufferByteLength);
                        addData("dataBufferByteLength", _ns.info.dataBufferByteLength);
                        addData("audioLossRate", _ns.info.audioLossRate);
                        if (((!((_ns.info.maxBytesPerSecond == 0))) && (!((_ns.info.playbackBytesPerSecond == 0))))){
                            bandwidthPercent = (_ns.info.currentBytesPerSecond / Math.min(_ns.info.maxBytesPerSecond, _ns.info.playbackBytesPerSecond));
                            addData("bandwidthPercent", bandwidthPercent);
                            addData("bandwidthPercentCount", 1);
                        };
                    };
                };
            } catch(e:Error) {
            };
        }
        public function stopTimer():void{
            if (_playTimer != null){
                _playTimer.stop();
                _playTimer.removeEventListener(TimerEvent.TIMER, playTimeHandler);
            };
        }
        private function addData(property:String, value:Number):void{
            if (isNaN(Number(playTimerData[property]))){
                playTimerData[property] = 0;
            };
            playTimerData[property] = (Number(playTimerData[property]) + value);
        }

    }
}//package com.akamai.playeranalytics.handler 
﻿package com.akamai.playeranalytics.handler {
    import flash.system.*;

    public class ParentSandboxHandler {

        public function ParentSandboxHandler(){
            super();
        }
        public function getStageDisplayState():Object{
            var Application:Class = (ApplicationDomain.currentDomain.getDefinition("mx.core.Application") as Class);
            if (((!((Application == null))) && (!((Application.application == null))))){
                return (Application.application.stage.displayState);
            };
            return ("normal");
        }

    }
}//package com.akamai.playeranalytics.handler 
﻿package com.akamai.playeranalytics.loader.events {
    import flash.events.*;

    public class AnalyticsEvent extends Event {

        public static var ON_PLUGIN_LOAD:String = "onPluginLoad";
        public static var DEBUG:String = "debug";
        public static var ON_PLUGIN_ERROR:String = "onPluginError";
        public static var LOGLINE:String = "logline";

        private var _data:Object;

        public function AnalyticsEvent(type:String, data:Object=null){
            _data = data;
            super(type);
        }
        public function get data():Object{
            return (_data);
        }
        override public function clone():Event{
            return (new AnalyticsEvent(type, data));
        }

    }
}//package com.akamai.playeranalytics.loader.events 
﻿package com.akamai.playeranalytics.loader {
    import flash.display.*;
    import flash.events.*;
    import com.akamai.playeranalytics.handler.*;
    import flash.system.*;
    import flash.net.*;
    import flash.errors.*;

    public class ClassLoader extends EventDispatcher {

        public static var CLASS_LOADED:String = "classLoaded";
        public static var LOAD_ERROR:String = "loadError";

        private var swfLib:String;
        private var request:URLRequest;
        private var loadedClass:Class;
        private var loader:Loader;

        public function ClassLoader(){
            super();
            loader = new Loader();
            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
            loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            loader.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
            try {
                if (loader.contentLoaderInfo.hasOwnProperty("parentSandboxBridge")){
                    loader.contentLoaderInfo["parentSandboxBridge"] = new ParentSandboxHandler();
                };
            } catch(e:Error) {
            };
        }
        public function getClass(className:String):Class{
            var className:* = className;
            var byteArray:* = loader.contentLoaderInfo.bytes;
            return ((loader.contentLoaderInfo.applicationDomain.getDefinition(className) as Class));
            var _slot1:* = e;
            throw (new IllegalOperationError(((className + " definition not found in ") + swfLib)));
        }
        public function getContentLoaderInfo():LoaderInfo{
            if (loader != null){
                return (loader.contentLoaderInfo);
            };
            return (null);
        }
        private function ioErrorHandler(e:Event):void{
            dispatchEvent(new Event(ClassLoader.LOAD_ERROR));
        }
        private function securityErrorHandler(e:Event):void{
            dispatchEvent(new Event(ClassLoader.LOAD_ERROR));
        }
        private function completeHandler(e:Event):void{
            dispatchEvent(new Event(ClassLoader.CLASS_LOADED));
        }
        public function load(lib:String):void{
            var context:* = null;
            var lib:* = lib;
            swfLib = lib;
            request = new URLRequest(swfLib);
            context = new LoaderContext();
            context.applicationDomain = ApplicationDomain.currentDomain;
            try {
                context.securityDomain = SecurityDomain.currentDomain;
                loader.load(request, context);
            } catch(e:Error) {
                context.securityDomain = null;
                loader.load(request, context);
            };
        }

    }
}//package com.akamai.playeranalytics.loader 
﻿package com.akamai.playeranalytics {

    public class AnalyticsPluginLoaderVersion {

        public static const VERSION:String = "1.4.3";

        public function AnalyticsPluginLoaderVersion(){
            super();
        }
    }
}//package com.akamai.playeranalytics 
﻿package com.akamai.hd {
    import flash.events.*;
    import flash.system.*;
    import flash.net.*;

    public class HDNetSessionInterface extends EventDispatcher {

        private static const SERVICE_URL:String = "http://127.0.0.1:9421/api?function=";
        private static const CROSSDOMAIN_LOCATION:String = "http://127.0.0.1:9421/crossdomain.xml";
        private static const CLIENT_INSTALL_DOMAIN:String = "client.akamai.com";

        public var cpCode:String = "unknown";
        public var netSessionClientInstalled:Boolean = false;
        public var acceptedEULA:Boolean = false;
        public var eulaVersion:String = "Unknown";
        private var xmlLoader:URLLoader;
        private var sentNetSessionEvent:Boolean = false;
        private var mustAcceptEula:Boolean = false;

        public function HDNetSessionInterface(_arg1:IEventDispatcher=null){
            super(_arg1);
        }
        public function requestCPU():void{
            this.makeRequest("cpu");
        }
        public function installCheck():void{
            this.makeRequest("clientattributes");
        }
        public function acceptEULA():void{
            this.makeRequest("acceptEULA");
        }
        public function installClient(_arg1:String, _arg2:Boolean, _arg3:String):void{
            var _local4:String = Capabilities.version;
            var _local5:RegExp = /^(\w*) (\d*),(\d*),(\d*),(\d*)$/;
            var _local6:Object = _local5.exec(_local4);
            var _local7:String = _local6[1].toString().toLowerCase();
            var _local8:String = ((((("https://" + CLIENT_INSTALL_DOMAIN) + "/conf/install_") + _local7) + ".html?file=") + _arg1);
            navigateToURL(new URLRequest(_local8), "_self");
            this.eulaVersion = _arg3;
            this.mustAcceptEula = _arg2;
        }
        private function makeRequest(_arg1:String):void{
            var _local2:String = "";
            if (!((this.xmlLoader is URLLoader))){
                Security.loadPolicyFile(CROSSDOMAIN_LOCATION);
                this.xmlLoader = new URLLoader();
                this.xmlLoader.addEventListener("complete", this.xmlLoaded);
                this.xmlLoader.addEventListener(IOErrorEvent.IO_ERROR, this.catchIOError);
                this.xmlLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.catchSecurityError);
            };
            switch (_arg1){
                case "cpu":
                    _local2 = ((SERVICE_URL + "getPerformanceAttributes&cid=") + this.cpCode);
                    break;
                case "acceptEULA":
                    _local2 = ((((SERVICE_URL + "acceptEULA&cid=") + this.cpCode) + "&version=") + this.eulaVersion);
                    break;
                case "clientattributes":
                    _local2 = ((SERVICE_URL + "getClientAttributes&cid=") + this.cpCode);
                    break;
            };
            if (_local2 != ""){
                this.xmlLoader.load(new URLRequest(_local2));
            } else {
                dispatchEvent(new HDEvent(HDEvent.FAILURE, "Command not recognized"));
            };
        }
        protected function xmlLoaded(_arg1:Event):void{
            var _local3:Number;
            var _local2:String = _arg1.currentTarget.data.toString();
            if (this.mustAcceptEula){
                this.mustAcceptEula = false;
                this.acceptEULA();
            };
            if (_local2.indexOf("cpu") != -1){
                _local3 = (Math.round((Number(_local2.split(":")[1].slice(0, -1)) * 100)) / 100);
                dispatchEvent(new HDEvent(HDEvent.CPU, _local3));
                if (!(this.sentNetSessionEvent)){
                    this.netSessionClientInstalled = true;
                    dispatchEvent(new HDEvent(HDEvent.NETSESSION_CLIENT, this.netSessionClientInstalled));
                    this.sentNetSessionEvent = true;
                };
            } else {
                if (_local2.indexOf("\"acceptedeula\":true") != -1){
                    this.acceptedEULA = true;
                    if (!(this.sentNetSessionEvent)){
                        this.netSessionClientInstalled = true;
                        dispatchEvent(new HDEvent(HDEvent.NETSESSION_CLIENT, this.netSessionClientInstalled));
                        this.sentNetSessionEvent = true;
                    };
                } else {
                    if (_local2.indexOf("\"acceptedeula\":false") != -1){
                        this.acceptedEULA = false;
                        if (!(this.sentNetSessionEvent)){
                            this.netSessionClientInstalled = true;
                            dispatchEvent(new HDEvent(HDEvent.NETSESSION_CLIENT, this.netSessionClientInstalled));
                            this.sentNetSessionEvent = true;
                        };
                    } else {
                        if (_local2.indexOf("\"eulaAccepted\":null") != -1){
                            this.acceptedEULA = true;
                            dispatchEvent(new HDEvent(HDEvent.NETSESSION_EULA, this.acceptedEULA));
                            if (!(this.sentNetSessionEvent)){
                                this.netSessionClientInstalled = true;
                                dispatchEvent(new HDEvent(HDEvent.NETSESSION_CLIENT, this.netSessionClientInstalled));
                                this.sentNetSessionEvent = true;
                            };
                        } else {
                            if (_local2.indexOf("error") != -1){
                                dispatchEvent(new HDEvent(HDEvent.FAILURE, _local2));
                            } else {
                                dispatchEvent(new HDEvent(HDEvent.FAILURE, "NetSession response not understood"));
                            };
                        };
                    };
                };
            };
        }
        private function catchIOError(_arg1:IOErrorEvent):void{
            dispatchEvent(new HDEvent(HDEvent.FAILURE, _arg1.text));
            dispatchEvent(new HDEvent(HDEvent.NETSESSION_CLIENT, this.netSessionClientInstalled));
        }
        private function catchSecurityError(_arg1:SecurityErrorEvent):void{
            dispatchEvent(new HDEvent(HDEvent.FAILURE, _arg1.text));
            dispatchEvent(new HDEvent(HDEvent.NETSESSION_CLIENT, this.netSessionClientInstalled));
        }

    }
}//package com.akamai.hd 
﻿package com.akamai.hd {
    import flash.utils.*;
    import flash.events.*;
    import flash.net.*;
    import mx.events.*;

    public class HDSMILParser extends EventDispatcher {

        private const TIMEOUT_MILLISECONDS:uint = 15000;

        public var xml:XML;
        public var rawData:String;
        public var title:String;
        private var _134873303mbrObjects:Array;
        private var busy:Boolean;
        private var timeoutTimer:Timer;
        private var isVOD:Boolean;

        public function HDSMILParser():void{
            this.busy = false;
            this.timeoutTimer = new Timer(this.TIMEOUT_MILLISECONDS, 1);
            this.timeoutTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.doTimeOut);
        }
        private function doTimeOut(_arg1:TimerEvent):void{
            dispatchEvent(new HDEvent(HDEvent.FAILURE, "Parser timed-out loading SMIL file"));
        }
        public function load(_arg1:String):Boolean{
            var _local2:URLLoader;
            if (!(this.busy)){
                this.busy = true;
                this.timeoutTimer.reset();
                this.timeoutTimer.start();
                _local2 = new URLLoader();
                _local2.addEventListener("complete", this.xmlLoaded);
                _local2.addEventListener(IOErrorEvent.IO_ERROR, this.catchIOError);
                _local2.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.catchSecurityError);
                _local2.load(new URLRequest(_arg1));
                return (true);
            };
            dispatchEvent(new HDEvent(HDEvent.FAILURE, "Parser is busy and cannot load another file until the prior load is complete"));
            return (false);
        }
        protected function xmlLoaded(_arg1:Event):void{
            var e:* = _arg1;
            this.timeoutTimer.stop();
            this.rawData = e.currentTarget.data.toString();
            try {
                this.xml = new XML(this.rawData);
                this.parseXML();
            } catch(err:Error) {
                busy = false;
                dispatchEvent(new HDEvent(HDEvent.FAILURE, ("Cannot cast the raw data to XML - " + err.message)));
            };
        }
        protected function parseXML():void{
            var ns:* = null;
            var rtmpAuthBase:* = null;
            var rtmpPlaybackBase:* = null;
            var httpBase:* = null;
            var i:* = 0;
            var mbrObject:* = null;
            var j:* = 0;
            var streamName:* = null;
            var bitrate:* = NaN;
            var width:* = NaN;
            var height:* = NaN;
            var clipBegin:* = NaN;
            var clipEnd:* = NaN;
            var tempSubClip:* = null;
            if (!(this.verifySMIL(this.xml))){
                dispatchEvent(new HDEvent(HDEvent.FAILURE, "SMIL loaded but failed verification"));
            } else {
                ns = this.xml.namespace();
                rtmpAuthBase = this.xml.ns::head.ns::meta.(@name == "rtmpAuthBase").@content;
                rtmpPlaybackBase = this.xml.ns::head.ns::meta.(@name == "rtmpPlaybackBase").@content;
                httpBase = this.xml.ns::head.ns::meta.(@name == "httpBase").@content;
                if (httpBase.slice(-1) != "/"){
                    httpBase = (httpBase + "/");
                };
                this.title = this.xml.ns::head.ns::meta.(@name == "title").@content;
                this.isVOD = (this.xml.ns::head.ns::meta.(@name == "vod").@content.toString().toLowerCase() == "true");
                this.mbrObjects = new Array();
                i = 0;
                while (i < this.xml.ns::bodyns::["switch"].length()) {
                    mbrObject = new HDMBRObject();
                    mbrObject.title = this.xml.ns::bodyns::["switch"][i].@id;
                    mbrObject.httpBase = httpBase;
                    mbrObject.rtmpPlaybackBase = rtmpPlaybackBase;
                    j = 0;
                    while (j < this.xml.ns::bodyns::["switch"][i].ns::video.length()) {
                        streamName = this.xml.ns::bodyns::["switch"][i].ns::video[j].@src;
                        bitrate = (Number(this.xml.ns::bodyns::["switch"][i].ns::video[j].@["system-bitrate"]) / 1000);
                        width = (Number(this.xml.ns::bodyns::["switch"][i].ns::video[j].@["width"]) / 1000);
                        height = (Number(this.xml.ns::bodyns::["switch"][i].ns::video[j].@["height"]) / 1000);
                        clipBegin = NaN;
                        clipEnd = NaN;
                        tempSubClip = String(this.xml.ns::bodyns::["switch"][i].ns::video[j].@["clipBegin"]);
                        if (((!((tempSubClip == null))) && ((tempSubClip.length > 0)))){
                            clipBegin = this.parseTime(tempSubClip);
                        };
                        tempSubClip = String(this.xml.ns::bodyns::["switch"][i].ns::video[j].@["clipEnd"]);
                        if (((!((tempSubClip == null))) && ((tempSubClip.length > 0)))){
                            clipEnd = this.parseTime(tempSubClip);
                        };
                        mbrObject.addStream(streamName, bitrate);
                        if (!(isNaN(clipBegin))){
                            mbrObject.clipBegin = clipBegin;
                        };
                        if (!(isNaN(clipEnd))){
                            mbrObject.clipEnd = clipEnd;
                        };
                        j = (j + 1);
                    };
                    if (this.isVOD){
                        mbrObject = HDVODFormatter.format(mbrObject);
                    };
                    this.mbrObjects.push(mbrObject);
                    i = (i + 1);
                };
                dispatchEvent(new HDEvent(HDEvent.PARSED, this.mbrObjects));
            };
            this.busy = false;
        }
        private function verifySMIL(_arg1:XML):Boolean{
            var src:* = _arg1;
            var ns:* = src.namespace();
            return (((((!((src.ns::bodyns::["switch"] == undefined))) && (!((src.ns::head.ns::meta.(@name == "httpBase").@content == undefined))))) && ((src.ns::bodyns::["switch"][0].ns::video.length() > 0))));
        }
        public function get isBusy():Boolean{
            return (this.busy);
        }
        private function catchIOError(_arg1:IOErrorEvent):void{
            this.timeoutTimer.stop();
            this.busy = false;
            dispatchEvent(new HDEvent(HDEvent.FAILURE, _arg1.text));
        }
        private function catchSecurityError(_arg1:SecurityErrorEvent):void{
            this.timeoutTimer.stop();
            this.busy = false;
            dispatchEvent(new HDEvent(HDEvent.FAILURE, _arg1.text));
        }
        private function parseTime(_arg1:String):Number{
            var _local4:int;
            var _local2:Number = 0;
            var _local3:Array = _arg1.split(":");
            if (_local3.length > 1){
                _local2 = (_local3[0] * 3600);
                _local2 = (_local2 + (_local3[1] * 60));
                _local2 = (_local2 + Number(_local3[2]));
            } else {
                _local4 = 0;
                switch (_arg1.charAt((_arg1.length - 1))){
                    case "h":
                        _local4 = 3600;
                        break;
                    case "m":
                        _local4 = 60;
                        break;
                    case "s":
                        _local4 = 1;
                        break;
                };
                if (_local4){
                    _local2 = (Number(_arg1.substr(0, (_arg1.length - 1))) * _local4);
                } else {
                    _local2 = Number(_arg1);
                };
            };
            return (_local2);
        }
        public function get mbrObjects():Array{
            return (this._134873303mbrObjects);
        }
        public function set mbrObjects(_arg1:Array):void{
            var _local2:Object = this._134873303mbrObjects;
            if (_local2 !== _arg1){
                this._134873303mbrObjects = _arg1;
                if (this.hasEventListener("propertyChange")){
                    this.dispatchEvent(PropertyChangeEvent.createUpdateEvent(this, "mbrObjects", _local2, _arg1));
                };
            };
        }

    }
}//package com.akamai.hd 
﻿package com.akamai.hd {

    public interface IMBRObject {

        function get streamCount():int;
        function set streamCount(_arg1:int):void;
        function get title():String;
        function set title(_arg1:String):void;
        function get rtmpPlaybackBase():String;
        function set rtmpPlaybackBase(_arg1:String):void;
        function get httpBase():String;
        function set httpBase(_arg1:String):void;
        function addStream(_arg1:String, _arg2:Number, _arg3:Number=0, _arg4:Number=0):void;
        function setDimensionsAt(_arg1:Number, _arg2:Number, _arg3:Number):void;
        function get streams():Array;
        function getRateAt(_arg1:Number):Number;
        function getWidthAt(_arg1:Number):Number;
        function getHeightAt(_arg1:Number):Number;
        function getNameAt(_arg1:Number):String;

    }
}//package com.akamai.hd 
﻿package com.akamai.hd {

    public class HDVODFormatter {

        public static function format(_arg1:HDMBRObject):HDMBRObject{
            if (_arg1.streamCount == 1){
                return (_arg1);
            };
            var _local2:Array = _arg1.streams;
            var _local3:Array = new Array();
            var _local4:Number = 0;
            while (_local4 < _local2.length) {
                _local3[_local4] = _local2[_local4].name.split("?")[1];
                _local2[_local4].name = _local2[_local4].name.split("?")[0];
                _local4++;
            };
            var _local5:Boolean = true;
            var _local6:String = "";
            var _local7:Number = 0;
            var _local8:String = "";
            while (_local5) {
                _local6 = _local8;
                _local8 = (_local2[0].name as String).slice(0, (_local7 + 1));
                _local4 = 0;
                while (_local4 < _local2.length) {
                    if (_local2[_local4].name.slice(0, (_local7 + 1)) != _local8){
                        _local5 = false;
                        break;
                    };
                    _local4++;
                };
                _local7++;
            };
            var _local9:String = "";
            _local7 = 1;
            _local5 = true;
            _local8 = "";
            while (_local5) {
                _local9 = _local8;
                _local8 = (_local2[0].name as String).slice(-(_local7));
                _local4 = 0;
                while (_local4 < _local2.length) {
                    if (((!((_local2[_local4].name.slice(-(_local7)) == _local8))) || ((_local2[_local4].name.slice(_local6.length, (_local2[_local4].name.length - _local7)).length < 2)))){
                        _local5 = false;
                        break;
                    };
                    _local4++;
                };
                _local7++;
            };
            var _local10:String = "";
            _local4 = 0;
            while (_local4 < _local2.length) {
                _local10 = (_local10 + ((((_local4 == 0)) ? "" : ",") + _local2[_local4].name.slice(_local6.length, (_local2[_local4].name.length - _local9.length))));
                _local4++;
            };
            _local4 = 0;
            while (_local4 < _local2.length) {
                _local2[_local4].name = (((((((_local6 + ",") + _local10) + ",") + _local9) + ".csmil/bitrate=") + _local4) + ((((!((_local3[_local4] == ""))) && (!((_local3[_local4] == null))))) ? ("?" + _local3[_local4]) : ""));
                _local4++;
            };
            _arg1.streams = _local2;
            return (_arg1);
        }

    }
}//package com.akamai.hd 
﻿package com.akamai.hd {

    public interface IMBRObject2 extends IMBRObject {

        function get clipBegin():Number;
        function set clipBegin(_arg1:Number):void;
        function get clipEnd():Number;
        function set clipEnd(_arg1:Number):void;
        function get primaryToken():String;
        function set primaryToken(_arg1:String):void;

    }
}//package com.akamai.hd 
﻿package com.akamai.hd {
    import flash.events.*;

    public class HDEvent extends Event {

        public static const NET_STATUS:String = "netstatus";
        public static const DEBUG:String = "debug";
        public static const PROGRESS:String = "progress";
        public static const STREAM_NOT_FOUND:String = "streamnotfound";
        public static const STREAM_NOT_FOUND_WHILE_PLAYING:String = "streamnotfoundwhileplaying";
        public static const IS_LIVE_STREAM:String = "islivestream";
        public static const IS_PLAYING_LIVE:String = "isplayinglive";
        public static const FAILURE:String = "failure";
        public static const IS_BUFFERING:String = "isbuffering";
        public static const BANDWIDTH:String = "bandwidth";
        public static const COMPLETE:String = "complete";
        public static const SWITCH_START:String = "switchstart";
        public static const SWITCH_COMPLETE:String = "switchcomplete";
        public static const RESUME:String = "resume";
        public static const PAUSE:String = "pause";
        public static const SEEK:String = "seek";
        public static const METADATA:String = "metadata";
        public static const ERROR:String = "error";
        public static const SUCCESS:String = "success";
        public static const REJECTED:String = "rejected";
        public static const PARSED:String = "parsed";
        public static const RENDITION_CHANGE:String = "renditionchange";
        public static const RTT:String = "rtt";
        public static const DATA_MESSAGE:String = "datamessage";
        public static const STREAM_NAME_CHANGE:String = "streamnamechange";
        public static const STREAM_TYPE_CHANGE:String = "streamtypechange";
        public static const TIMEOUT:String = "timeout";
        public static const FAIL_OVER_TO_RTMP:String = "failovertortmp";
        public static const LOOP:String = "loop";
        public static const PLAY:String = "play";
        public static const CPU:String = "cpu";
        public static const REBUFFER:String = "rebuffer";
        public static const TAT:String = "tat";
        public static const SESSION_ID:String = "sessionid";
        public static const NETSESSION_CLIENT:String = "netsessionclient";
        public static const NETSESSION_EULA:String = "netsessioneula";
        public static const STREAM_START_TIME:String = "streamstarttime";
        public static const DEAD_CONNECTION:String = "deadconnection";
        public static const THUMBNAIL_READY:String = "thumbnailready";
        public static const DVR_WINDOW:String = "dvrwindow";
        public static const DVR_WINDOW_CLOSED:String = "dvrwindowclosed";
        public static const ARCHIVE_PLAYBACK_DISABLED:String = "archiveplaybackdisabled";
        public static const BANDWIDTH_ESTIMATION_COMPLETE:String = "bandwidthEstimationComplete";
        public static const ALT_SERVER_MAP_FAILOVER:String = "altservermapfailover";
        public static const IDENT_REQUEST:String = "identrequest";

        private var _data:Object;

        public function HDEvent(_arg1:String, _arg2:Object=null){
            this._data = _arg2;
            super(_arg1, false, true);
        }
        public function get data():Object{
            return (this._data);
        }
        override public function clone():Event{
            return (new HDEvent(type, this.data));
        }

    }
}//package com.akamai.hd 
﻿package com.akamai.hd {

    public interface ITokenService {

        function requestTokenizedURL(_arg1:String):void;
        function set callBackFunctionOnSuccess(_arg1:Function):void;
        function set callBackFunctionOnFailure(_arg1:Function):void;

    }
}//package com.akamai.hd 
﻿package com.akamai.hd {
    import flash.events.*;
    import flash.net.*;
    import flash.display.*;

    public class HDServerController extends EventDispatcher {

        private static const CONTROL_APP_NAME:String = "control";
        private static const BITRATE_TEST_TIMEOUT:Number = 10000;

        public var controlHost:String;
        public var requiresAuth:Boolean = false;
        public var sessionID:String;
        public var guid:String;
        public var qosArgs:String = "";
        public var displayObject:DisplayObject;
        public var streamName:String;
        private var RTT:Number;
        private var secondaryToken:String;
        private var _useVerboseGhostLogs:Boolean = false;
        private var discardBandwidthResult:Boolean = false;
        private var lastCommand:String = "";

        public function HDServerController(_arg1:IEventDispatcher=null){
            super(_arg1);
        }
        public function doSwitch(_arg1:String, _arg2:String=""):void{
            this.buildCommand(("&reason=" + _arg2), _arg1);
        }
        public function throttle(_arg1:Number):void{
            this.buildCommand(("throttle," + _arg1.toString()), this.streamName);
        }
        public function log(_arg1:String, _arg2:String=""):void{
            this.buildCommand((("log," + _arg1) + ((!((_arg2 == ""))) ? ("," + _arg2) : "")), this.streamName);
        }
        public function getTAT():void{
            this.buildCommand("getTAT", this.streamName);
        }
        public function doSwitchAt(_arg1:String, _arg2:Number):void{
            this.buildCommand(("seek=" + _arg2), _arg1);
        }
        public function startBandwidthTest(_arg1:Number, _arg2:Number):void{
            this.discardBandwidthResult = false;
            this.buildCommand(((("bitrate-test," + _arg1) + ",") + _arg2), this.streamName);
        }
        public function startRTTtest():void{
            this.discardBandwidthResult = true;
            this.buildCommand("rtt-test", this.streamName);
        }
        public function sendSecondaryToken(_arg1:String):void{
            this.secondaryToken = _arg1;
            this.requiresAuth = true;
            this.buildCommand("sendingNewToken", this.streamName);
        }
        public function set useVerboseGhostLogs(_arg1:Boolean):void{
            this._useVerboseGhostLogs = _arg1;
        }
        private function buildCommand(_arg1:String, _arg2:String):void{
            if (this.haveNecessaryParams()){
                this.makeRequest(_arg1, _arg2);
            } else {
                this.notifyThatParamsAreInvalid();
            };
        }
        private function makeRequest(_arg1:String, _arg2:String):void{
            this.lastCommand = _arg1;
            var _local3:URLRequest = new URLRequest();
            _local3.method = URLRequestMethod.POST;
            _local3.contentType = "text/xml";
            _local3.data = ":)";
            var _local4:Array = new Array();
            _local4.push(new URLRequestHeader("x-Akamai-Streaming-SessionID", this.sessionID));
            if (this.requiresAuth){
                _local4.push(new URLRequestHeader("x-Akamai-Streaming-SessionToken", this.secondaryToken));
            };
            _local3.requestHeaders = _local4;
            _local3.url = ((((((((((((((this.controlHost + (((this.controlHost.slice(-1) == "/")) ? "" : "/")) + CONTROL_APP_NAME) + "/") + _arg2) + (((_arg1 == "")) ? "?" : (("?cmd=" + _arg1) + "&"))) + "v=") + HDVersion.version) + "&r=") + this.getCacheBustString()) + "&g=") + this.guid) + this.qosArgs) + ((this._useVerboseGhostLogs) ? "&verbose=on" : "")) + (((((_arg1 == "sendingNewToken")) && ((this.displayObject is DisplayObject)))) ? ("&swf=" + escape(this.displayObject.stage.loaderInfo.loaderURL)) : ""));
            var _local5:URLLoader = new URLLoader();
            _local5.addEventListener(IOErrorEvent.IO_ERROR, this.onIOError);
            _local5.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onSecurityError);
            _local5.addEventListener(Event.COMPLETE, this.onComplete);
            _local5.load(_local3);
            dispatchEvent(new HDEvent(HDEvent.DEBUG, ("Control request: " + ((!((_arg1.indexOf("reason") == -1))) ? ("Switch to " + _arg2) : _arg1))));
        }
        private function onIOError(_arg1:IOErrorEvent):void{
            dispatchEvent(new HDEvent(HDEvent.FAILURE, ((("IO Error event - " + _arg1.text) + " using ") + this.sessionID)));
        }
        private function onSecurityError(_arg1:SecurityErrorEvent):void{
            dispatchEvent(new HDEvent(HDEvent.FAILURE, ((("Security Error event - " + _arg1.text) + " using ") + this.sessionID)));
        }
        private function onComplete(_arg1:Event):void{
            var _local2:String = (_arg1.currentTarget as URLLoader).data;
            if (((!((_local2.indexOf("bandwidth=") == -1))) && (!(this.discardBandwidthResult)))){
                dispatchEvent(new HDEvent(HDEvent.BANDWIDTH, Number(_local2.slice((_local2.indexOf("bandwidth=") + 10), _local2.indexOf("Kbps")))));
            };
            if (_local2.indexOf("rtt=") != -1){
                this.discardBandwidthResult = false;
                dispatchEvent(new HDEvent(HDEvent.RTT, Number(_local2.slice((_local2.indexOf("rtt=") + 4), _local2.indexOf("ms")))));
            };
            if (_local2.indexOf("TAT=") != -1){
                this.discardBandwidthResult = false;
                dispatchEvent(new HDEvent(HDEvent.TAT, Number(_local2.slice((_local2.indexOf("TAT=") + 4)))));
            };
            if (_local2.indexOf("error=") != -1){
                this.discardBandwidthResult = false;
                dispatchEvent(new HDEvent(HDEvent.FAILURE, _local2));
            } else {
                dispatchEvent(new HDEvent(HDEvent.SUCCESS));
            };
        }
        private function notifyThatParamsAreInvalid():void{
            dispatchEvent(new HDEvent(HDEvent.FAILURE, ((this.requiresAuth) ? "ControlHost, Stream Name, SessionID and SecondaryToken are required with control requests under Auth" : "ControlHost, Stream Name and SessionID are required with control requests")));
        }
        private function haveNecessaryParams():Boolean{
            return (((((((!((this.controlHost == null))) && (!((this.streamName == null))))) && (!((this.sessionID == null))))) && (((this.requiresAuth) ? !((this.secondaryToken == null)) : true))));
        }
        private function getCacheBustString():String{
            var _local1:String = "";
            var _local2:Number = 0;
            while (_local2 < 5) {
                _local1 = (_local1 + String.fromCharCode((65 + Math.round((Math.random() * 25)))));
                _local2++;
            };
            return (_local1);
        }

    }
}//package com.akamai.hd 
﻿package com.akamai.hd {
    import flash.utils.*;

    public dynamic class HDClientProxy extends Proxy {

        private var handlers:Dictionary;

        public function HDClientProxy(){
            this.handlers = new Dictionary();
            super();
        }
        public function addHandler(_arg1:String, _arg2:Function):void{
            var _local3:Array = ((this.handlers.hasOwnProperty(_arg1)) ? this.handlers[_arg1] : this.handlers[_arg1] = []);
            if (_local3.indexOf(_arg2) == -1){
                _local3.push(_arg2);
            };
        }
        public function removeHandler(_arg1:String, _arg2:Function):Boolean{
            var _local3:Boolean;
            var _local4:Array;
            var _local5:int;
            if (this.handlers.hasOwnProperty(_arg1)){
                _local4 = this.handlers[_arg1];
                _local5 = _local4.indexOf(_arg2);
                if (_local5 != -1){
                    _local4.splice(_local5, 1);
                    _local3 = true;
                };
            };
            return (_local3);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function callProperty(_arg1, ... _args){
            return (this.invokeHandlers(_arg1, _args));
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function getProperty(_arg1){
            var result:* = undefined;
            var name:* = _arg1;
            result = function (){
                return (invokeHandlers(arguments.callee.name, arguments));
            };
            result.name = name;
            return (result);
        }
        private function invokeHandlers(_arg1:String, _arg2:Array){
            var _local3:Array;
            var _local4:Function;
            var _local5:Array;
            if (this.handlers.hasOwnProperty(_arg1)){
                _local3 = [];
                _local5 = this.handlers[_arg1];
                for each (_local4 in _local5) {
                    _local3.push(_local4.apply(null, _arg2));
                };
            };
            if (this.handlers.hasOwnProperty("all")){
                _local3 = [];
                _local5 = this.handlers["all"];
                for each (_local4 in _local5) {
                    _arg2.unshift(_arg1);
                    _local3.push(_local4.apply(null, _arg2));
                };
            };
            return (_local3);
        }

    }
}//package com.akamai.hd 
﻿package com.akamai.hd {
    import org.osmf.logging.*;
    import flash.utils.*;
    import flash.net.*;
    import com.akamai.qos.*;
    import flash.display.*;
    import com.akamai.playeranalytics.*;
    import com.akamai.playeranalytics.loader.events.*;
    import com.akamai.version.*;
    import flash.events.*;
    import flash.media.*;
    import flash.system.*;
    import com.akamai.utils.*;
    import org.osmf.utils.*;

    public class HDNetStream extends NetStream {

        private const DEFAULT_PROGRESS_INTERVAL:Number = 100;
        private const BANDWIDTH_SAFETY_FACTOR_LOW_RTT:Number = 1.3;
        private const BANDWIDTH_SAFETY_FACTOR_HIGH_RTT:Number = 1.5;
        private const BANDWIDTH_SAFETY_FACTOR_LIVE:Number = 1.2;
        private const METRICS_INTERVAL:Number = 250;
        private const KEEP_ALIVE_AFTER_PAUSE_DURATION:Number = 600000;
        private const PLAYING_LIVE_DELTA:Number = 10;
        private const RAPID_STOP_THRESHOLD:Number = 50;
        private const WAIT_AFTER_SWITCH:Number = 3000;
        private const WAIT_AFTER_SWITCH_FOR_DOWNLOAD_RATIO:Number = 2000;
        private const WAIT_AFTER_BITRATE_TEST:Number = 1000;
        private const SWITCH_TIMEOUT:Number = 20000;
        private const MAX_INTERVAl_BETWEEN_TAT:Number = 5000;
        private const MAX_STARTING_BITRATE:Number = 500;
        private const MINIMUM_BUFFER_EMPTY_FULL_GAP:Number = 250;
        private const MAXIMUM_SESSION_BYTES:Number = 0x713FB300;
        private const END_OF_STREAM_TAT_TIME_DELTA:Number = 1.5;
        private const IDLE_TIMEOUT_MILLSECONDS:Number = 110000;
        private const EOS_LIVE_TIMEOUT_AFTER_BUFFER_EMPTY:Number = 15000;
        private const EOS_VOD_TIMEOUT_AFTER_BUFFER_EMPTY:Number = 1000;
        private const EOF_MARGIN:Number = 6;
        private const DEAD_CONNECTION_TIMEOUT:Number = 10000;
        private const IGNORE_PERIOD:Number = 300000;
        private const ABSOLUTE_SEEK_THRESHOLD:Number = 0x4B3D3B00;
        private const CROSSDOMAIN_SUFFIX:String = "/crossdomain.xml";
        private const BITRATE_TEST_BASE_INTERVAL:Number = 10000;
        private const BITRATE_TEST_RANDOM_INTERVAL:Number = 5000;
        private const BITRATE_TEST_MIN_DELAY_FOR_SBR:Number = 300000;
        private const BITRATE_TEST_LIVE_HOLD_BACK:Number = 1500;
        private const BANDWIDTH_TEST_ALLOWED_BUFFER_GROWTH:Number = 3;
        private const BANDWIDTH_FAST_INSPECTION_INTERVAL:Number = 250;
        private const BANDWIDTH_TEST_DURATION:Number = 2000;
        private const BANDWIDTH_SAMPLE_COUNT:Number = 5;
        private const DOWNLOAD_RATIO_SAMPLE_COUNT:Number = 20;
        private const PLAYBACK_RATE_SAMPLE_COUNT:Number = 10;
        private const DOWNLOAD_RATIO_THRESHOLD:Number = 0.8;
        private const DOWNLOAD_RATIO_THRESHOLD_LIVE:Number = 0.8;
        private const MIN_SAMPLES_FOR_MAX_BANDWIDTH:Number = 3;
        private const MASTER_BUFFER_TIME:Number = 100;
        private const TARGET_BUFFER_TIME_LOW_LATENCY:Number = 10;
        private const TARGET_BUFFER_TIME_HIGH_LATENCY:Number = 15;
        private const TARGET_BUFFER_TIME_SINGLE_BITRATE:Number = 60;
        private const LOW_RTT:Number = 20;
        private const HIGH_RTT:Number = 100;
        private const ALLOWABLE_BUFFER_DELTA:Number = 0.5;
        private const STARTING_BUFFER_TIME_ONDEMAND:Number = 0.75;
        private const STARTING_BUFFER_AFTER_BUFFER_EMPTY:Number = 0;
        private const STARTING_BUFFER_TIME_LIVE:Number = 7;
        private const MINIMUM_LIVE_STARTING_BUFFER:Number = 5;
        private const MAXIMUM_LIVE_BUFFER:Number = 10;
        private const BUFFER_SAMPLE_PERIOD:Number = 1000;
        private const UPPER_BUFFER_RANGE:Number = 5;
        private const LOWER_BUFFER_RANGE:Number = 2;
        private const MAX_BUFFER_SWITCHDOWN_THRESHOLD:Number = 15;
        private const REBUFFER_THRESHOLD:Number = 500;
        private const BUFFER_EMPTY_THRESHOLD:Number = 10;
        private const MIN_BUFFER_TO_SWITCH_UP:Number = 3;
        private const MAX_BUFFERTIME_AFTER_BUFFER_EMPTY:Number = 5;
        private const THRESHOLD_FOR_REPEATED_BUFFER_EMPTY:Number = 5000;
        private const FRAMEDROP_THRESHOLD:Number = 0.5;
        private const MIN_NOMIMAL_FPS_TO_SWITCH:Number = 15;
        private const DROPPED_FRAME_AVERAGING_PERIOD:Number = 3000;
        private const MAX_THROTTLE_INTERVAL:Number = 4000;
        private const MIN_THROTTLE_INTERVAL:Number = 2000;
        private const THROTTLE_INSPECTION_INTERVAL:Number = 500;
        private const MAX_THROTTLE:Number = 200;
        private const MIN_THROTTLE:Number = 20;
        private const PAUSE_THROTTLE:Number = 0;
        private const UP_SWITCH_THROTTLE:Number = 100;
        private const DOWN_SWITCH_THROTTLE:Number = 200;
        private const BANDWIDTH_ESTIMATION_THROTTLE:Number = 500;
        private const FIXED_THROTTLE:Number = 100;
        private const EOS_TARGET_BUFFER_TIME_OFFSET:Number = 10;
        private const INITIAL_LOCKOUT_PERIOD:Number = 300000;
        private const LOCKOUT_THRESHOLD:Number = 5;
        private const ANALYTICS_SWF:String = "http://79423.analytics.edgesuite.net/csma/plugin/csma.swf";

        private var clientObject:Object;
        private var guid:String;
        private var tat:Number = 0;
        private var timeBase:Number = 0;
        private var sessionToken:String;
        private var sessionID:String;
        private var metricsTimer:Timer;
        private var progressTimer:Timer;
        private var controller:HDServerController;
        private var netSessionInterface:HDNetSessionInterface;
        private var currentURL:String;
        private var errorNumber:Number;
        private var status:Number;
        private var currentMBRObject:IMBRObject;
        private var currentStreamName:String;
        private var timeAtLastOnEdge:Number = 0;
        private var timerAtLastTat:Number = 0;
        private var trapTime:Boolean = false;
        private var bitrateTestTimer:Timer;
        private var throttleTimer:Timer;
        private var bufferInspectionTimer:Timer;
        private var switchTimeoutTimer:Timer;
        private var bandwidthEstimateFastTimer:Timer;
        private var needBitrateTest:Boolean = false;
        private var bitrateTestStartTime:Number;
        private var bitrateTestStartBytes:Number;
        private var lastDroppedFrameCount:Number;
        private var lastDroppedFrameTime:Number;
        private var lastThrottleTime:Number;
        private var isPaused:Boolean;
        private var bitrateTestUnderway:Boolean = false;
        private var lastBufferValue:Number;
        private var lastBufferTime:Number;
        private var switchUnderway:Boolean;
        private var accummulatedBytesLoaded:uint;
        private var accummulatedDroppedFrames:uint;
        private var trapFirstOnEdge:Boolean;
        private var transferToken:String;
        private var authToken:String;
        private var pendingIndex:Number;
        private var timeAtLastSwitchStart:Number;
        private var lastPrimaryTokenUsed:String;
        private var pendingSeek:String;
        private var nc:NetConnection;
        private var lockOutArray:Array;
        private var lockLimit:Number;
        private var lockTimer:Timer;
        private var renderedWidth:Number = 0;
        private var renderedHeight:Number = 0;
        private var bytesAtStartOfFastBufferInspection:Number;
        private var lastBytesForFastBufferInspection:Number;
        private var timeAtStartOfFastBufferInspection:Number;
        private var timeAtLastPause:Number;
        private var timerAtLastPause:Number;
        private var bandwidthSafetyFactor:Number;
        private var smilParser:HDSMILParser;
        private var playlistAvailable:Boolean;
        private var swfAuthUnderway:Boolean = false;
        private var lastStopEventTime:Number;
        private var lastSwitchTime:Number;
        private var timeAtLastBitrateTest:Number;
        private var bufferAtLastBitrateTest:Number;
        private var lastPlayBackRate:Number = 0;
        private var isBuffering:Boolean = false;
        private var requiresSwfAuth:Boolean;
        private var firstByte:Number;
        private var firstByteTime:Number;
        private var lastFLVTimeStamp:Number;
        private var seekTarget:Number;
        private var timeAtLastBufferEmpty:Number;
        private var timeAtLastBufferFull:Number;
        private var delayFromLive:Number = 0;
        private var recoveringFromTimeout:Boolean = false;
        private var swf:MovieClip;
        private var lastBitrateMeasured:Number;
        private var byteDelta:Number;
        private var timeDelta:Number;
        private var bandwidthSampleArray:Array;
        private var timeAtEndOfLastBitrateTest:Number;
        private var hasReachedBufferTarget:Boolean;
        private var lastThrottleStats:Object;
        private var bytesAtBufferEmpty:Number;
        private var eosLiveTimer:Timer;
        private var eosVodTimer:Timer;
        private var deadConnectionTimer:Timer;
        private var bufferEmptyFlag:Boolean;
        private var downloadRatioSampleArray:Array;
        private var bufferAtLastSwitch:Number;
        private var firstThrottleBeforeSwitch:Boolean;
        private var bytesAtlastBufferEmpty:Number;
        private var useTransferToken:Boolean;
        private var ignoreList:Array;
        private var systemTimeAtLastCheck:Number;
        private var streamTimeAtlastCheck:Number;
        private var onEdgeCount:Number;
        private var periodsWithNoData:Number;
        private var timeAtFirstEmptyByteDelta:Number;
        private var analyticsPluginAlreadyLoaded:Boolean = false;
        private var HDClientVersion:String = "u";
        private var lastTat:Number;
        private var lastTimebase:Number;
        private var alternateHost:String = "";
        private var playSource:Object;
        private var playStart:Number;
        private var playLength:Number;
        private var allowSubClipCheck:Boolean = false;
        private var callPauseOnce:Boolean = false;
        private var bufferTimeAfterBufferEmpty:Number;
        private var pendingPlayURL:String;
        private var failingOverToAlternate:Boolean;
        private var qosManager:HDN1QoSManager;
        private var csmaQosEventVo:QoSEventVO;
        private var logger:Logger;
        private var playbackBytesSampleArray:Array;
        private var bandwidthEstimationPeriodInSeconds:Number;
        private var _requiresEdgeAuth:Boolean = false;
        private var _edgeVersion:String;
        private var _edgeIP:String;
        private var _playerIP:String;
        private var _considerDimensionsWhenSwitching:Boolean = false;
        private var _loop:Boolean = false;
        private var _displayObject:DisplayObject;
        private var _currentIndex:int;
        private var _dvrWindow:Number;
        private var _netSessionClientAvailable:Boolean = false;
        private var _useVerboseGhostLogs:Boolean = false;
        private var _targetBufferTime:Number;
        private var _startingBufferTimeOndemand:Number;
        private var _startingBufferTimeLive:Number;
        private var _volume:Number = 1;
        private var _autoSwitch:Boolean = true;
        private var _nominalFPS:Number;
        private var _droppedFPS:Number = 0;
        private var _estimatedMaxbandwidth:Number = 0;
        private var _estimatedCurrentBandwidth:Number = 0;
        private var _estimatedRTT:Number;
        private var _lastThrottleValue:Number;
        private var _isLiveStream:Boolean = false;
        private var _isPlayingLive:Boolean = false;
        private var _isPausedWhileLive:Boolean = false;
        private var _isComplete:Boolean = false;
        private var _source;
        private var _streamType:int;
        private var _secondsUntilBufferEmpties:Number;
        private var _startingIndex:Number;
        private var _cpu:Number;
        private var _maximizeSingleBitrateBuffers:Boolean = true;
        private var _streamStartTime:Number;
        private var _serverTAT:Number;
        private var _liveDrift:Number;
        private var _maximumBitrateAllowed:Number = 2147483647;
        private var _tokenService:ITokenService;
        private var _maxLiveDriftAllowed:Number = 2147483647;
        private var _time:Number;
        private var _duration:Number;
        private var _useFixedThrottleForSBR:Boolean = false;
        private var _autoRecoverFromTimeout:Boolean = true;
        private var _downloadRatio:Number;
        private var _primaryToken:String;
        private var _enableNetSessionDiscovery:Boolean = false;
        private var _maxSecondsWithoutData:Number;
        private var _analyticsBeacon:String = "";
        private var _EOF_margin:Number;
        private var _automaticallyReconnect:Boolean = false;
        private var _enableAlternateServerMapping:Boolean = false;
        private var _enableEndUserMapping:Boolean = false;
        private var _disableAllArchivePlayback:Boolean = false;
        private var _averagePlaybackBitsPerSecond:Number;
        private var _maxBufferLength:Number;
        private var _bandwidthEstimationEnabled:Boolean = false;
        public var streamType:int;

        public function HDNetStream(_arg1:NetConnection){
            this.bandwidthSafetyFactor = this.BANDWIDTH_SAFETY_FACTOR_LOW_RTT;
            this.lastThrottleStats = new Object();
            this._targetBufferTime = this.TARGET_BUFFER_TIME_LOW_LATENCY;
            this._startingBufferTimeOndemand = this.STARTING_BUFFER_TIME_ONDEMAND;
            this._startingBufferTimeLive = this.STARTING_BUFFER_TIME_LIVE;
            this._maxBufferLength = this.TARGET_BUFFER_TIME_SINGLE_BITRATE;
            this.logger = Log.getLogger(describeType(this).@name);
            if (_arg1.uri == "null"){
                super(_arg1);
                this.nc = _arg1;
                this.init();
            } else {
                throw (new ArgumentError("NetConnection must be null"));
            };
        }
        public function get bandwidthEstimationEnabled():Boolean{
            return (this._bandwidthEstimationEnabled);
        }
        public function setBandwidthEstimationEnabled(_arg1:Boolean, _arg2:Number=1):void{
            this._bandwidthEstimationEnabled = _arg1;
            this.bandwidthEstimationPeriodInSeconds = _arg2;
        }
        public function get maxBufferLength():Number{
            return (this._maxBufferLength);
        }
        public function set maxBufferLength(_arg1:Number):void{
            this._maxBufferLength = _arg1;
        }
        public function get enableAlternateServerMapping():Boolean{
            return (this._enableAlternateServerMapping);
        }
        public function set enableAlternateServerMapping(_arg1:Boolean):void{
            if (((_arg1) && ((this.qosManager == null)))){
                this.qosManager = new HDN1QoSManager(this._enableEndUserMapping);
                this.csmaQosEventVo = new QoSEventVO();
            } else {
                if (((!(_arg1)) && (!((this.qosManager == null))))){
                    this.qosManager.destroy();
                    this.qosManager = null;
                    this._enableEndUserMapping = false;
                };
            };
            this._enableAlternateServerMapping = _arg1;
        }
        public function get enableEndUserMapping():Boolean{
            return (this._enableEndUserMapping);
        }
        public function set enableEndUserMapping(_arg1:Boolean):void{
            this._enableEndUserMapping = _arg1;
            if (((_arg1) && (!(this._enableAlternateServerMapping)))){
                this.enableAlternateServerMapping = true;
            };
            if (this.qosManager != null){
                this.qosManager.enableEndUserMapping = _arg1;
            };
        }
        public function get dvrWindow():Number{
            return (this._dvrWindow);
        }
        public function get requiresEdgeAuth():Boolean{
            return (this._requiresEdgeAuth);
        }
        public function set requiresEdgeAuth(_arg1:Boolean):void{
            this._requiresEdgeAuth = _arg1;
        }
        public function get disableAllArchivePlayback():Boolean{
            return (this._disableAllArchivePlayback);
        }
        public function set disableAllArchivePlayback(_arg1:Boolean):void{
            this._disableAllArchivePlayback = _arg1;
        }
        public function get edgeVersion():String{
            return (this._edgeVersion);
        }
        public function set edgeVersion(_arg1:String):void{
            this._edgeVersion = _arg1;
        }
        public function get edgeIP():String{
            return (this._edgeIP);
        }
        public function set edgeIP(_arg1:String):void{
            this._edgeIP = _arg1;
        }
        public function get playerIP():String{
            return (this._playerIP);
        }
        public function set playerIP(_arg1:String):void{
            this._playerIP = _arg1;
        }
        public function get considerDimensionsWhenSwitching():Boolean{
            return (this._considerDimensionsWhenSwitching);
        }
        public function set considerDimensionsWhenSwitching(_arg1:Boolean):void{
            this._considerDimensionsWhenSwitching = _arg1;
        }
        public function get loop():Boolean{
            return (this._loop);
        }
        public function set loop(_arg1:Boolean):void{
            this._loop = _arg1;
        }
        public function get displayObject():DisplayObject{
            return (this._displayObject);
        }
        public function set displayObject(_arg1:DisplayObject):void{
            this._displayObject = _arg1;
            this.controller.displayObject = this._displayObject;
        }
        public function get currentIndex():int{
            return (this._currentIndex);
        }
        public function set currentIndex(_arg1:int):void{
            this._currentIndex = _arg1;
        }
        public function get streamStartTime():Number{
            return ((((this._dvrWindow > 0)) ? ((this._streamStartTime + (this._duration * 1000)) - (this._dvrWindow * 1000)) : this._streamStartTime));
        }
        public function get reachedTargetBufferFull():Boolean{
            return (this.hasReachedBufferTarget);
        }
        override public function set client(_arg1:Object):void{
            this.clientObject = _arg1;
        }
        override public function get client():Object{
            return ((this.clientObject as Object));
        }
        public function set primaryToken(_arg1:String):void{
            this._primaryToken = _arg1;
            this.useTransferToken = true;
        }
        public function set autoRecoverFromTimeout(_arg1:Boolean):void{
            this._autoRecoverFromTimeout = _arg1;
        }
        public function get autoRecoverFromTimeout():Boolean{
            return (this._autoRecoverFromTimeout);
        }
        public function set analyticsBeacon(_arg1:String):void{
            var _local2:NetConnection;
            if (_arg1 == ""){
                if (this._analyticsBeacon != ""){
                    AnalyticsPluginLoader.pause();
                };
            } else {
                this._analyticsBeacon = _arg1;
                AnalyticsPluginLoader.loadPlugin(this.ANALYTICS_SWF, this._analyticsBeacon);
                AnalyticsPluginLoader.addEventListener(AnalyticsEvent.ON_PLUGIN_LOAD, this.onPluginLoad, false, 0, true);
                AnalyticsPluginLoader.setDebug(false);
                AnalyticsPluginLoader.setData("hdcore", HDCoreVersion.version);
                _local2 = new NetConnection();
                _local2.connect(null);
                AnalyticsPluginLoader.setNetConnectionInfo(_local2, null);
                AnalyticsPluginLoader.setNetStreamInfo(this, null);
            };
        }
        public function get analyticsBeacon():String{
            return (this._analyticsBeacon);
        }
        public function get enableNetSessionDiscovery():Boolean{
            return (this._enableNetSessionDiscovery);
        }
        public function set enableNetSessionDiscovery(_arg1:Boolean):void{
            this._enableNetSessionDiscovery = _arg1;
        }
        override public function get time():Number{
            var _local2:Number;
            var _local1:Number = (((((this._dvrWindow > 0)) && ((this._dvrWindow < this._duration)))) ? Math.ceil((this._time - (this._duration - this._dvrWindow))) : this._time);
            if (((((((!(isNaN(this.playStart))) && ((this.playStart > 0)))) && (!(isNaN(this.playLength))))) && ((((this.playLength == -1)) || ((this.playLength > 0)))))){
                _local2 = (this._time - this.playStart);
                _local1 = ((_local2)>0) ? _local2 : 0;
                if ((((this.playLength > 0)) && ((_local1 > this.playLength)))){
                    _local1 = this.playLength;
                };
            };
            if (((!(isNaN(this.playLength))) && ((this.playLength == 0)))){
                _local1 = this.playStart;
            };
            return (_local1);
        }
        public function get timeAsTimeCode():String{
            return (this.timeCode(this.time));
        }
        public function get durationAsTimeCode():String{
            return (this.timeCode(this.duration));
        }
        override public function get bufferLength():Number{
            var _local1:Number;
            switch (this._streamType){
                case 0:
                    _local1 = super.bufferLength;
                    break;
                case 1:
                    _local1 = super.info.videoBufferLength;
                    break;
                case 2:
                    _local1 = super.info.audioBufferLength;
                    break;
                case 3:
                    _local1 = super.info.videoBufferLength;
                    break;
            };
            return (_local1);
        }
        public function get nominalFPS():Number{
            return (this._nominalFPS);
        }
        public function get maxSecondsWithoutData():Number{
            return (this._maxSecondsWithoutData);
        }
        public function get MBRObject():IMBRObject{
            return (((this.isPlayingMBRcontent()) ? this.currentMBRObject : null));
        }
        public function get netSessionClientAvailable():Boolean{
            return (this._netSessionClientAvailable);
        }
        public function netSessionAcceptEULA():void{
            this.netSessionInterface.acceptEULA();
        }
        public function installNetSessionClient(_arg1:String="NetSessionInstaller", _arg2:Boolean=false, _arg3:String="Unknown EULA version"):void{
            this.netSessionInterface.installClient(_arg1, _arg2, _arg3);
        }
        public function get netSessionAcceptedEULA():Boolean{
            return (this.netSessionInterface.acceptedEULA);
        }
        public function get liveDrift():Number{
            return (((this.isLiveStream) ? this._liveDrift : NaN));
        }
        public function get maxLiveDriftAllowed():Number{
            return (this._maxLiveDriftAllowed);
        }
        public function set maxLiveDriftAllowed(_arg1:Number):void{
            this._maxLiveDriftAllowed = _arg1;
        }
        public function get useFixedThrottleForSBR():Boolean{
            return (this._useFixedThrottleForSBR);
        }
        public function set useFixedThrottleForSBR(_arg1:Boolean):void{
            this._useFixedThrottleForSBR = _arg1;
            this.debug(("useFixedThrottleForSBR set to " + _arg1));
        }
        public function get startingIndex():Number{
            return (this._startingIndex);
        }
        public function set startingIndex(_arg1:Number):void{
            this._startingIndex = _arg1;
        }
        public function set tokenService(_arg1:ITokenService):void{
            this._tokenService = _arg1;
            this._tokenService.callBackFunctionOnSuccess = this.onTokenServiceSuccess;
            this._tokenService.callBackFunctionOnFailure = this.onTokenServiceFailure;
            this.useTransferToken = true;
        }
        public function get maximumBitrateAllowed():Number{
            return (this._maximumBitrateAllowed);
        }
        public function set maximumBitrateAllowed(_arg1:Number):void{
            this._maximumBitrateAllowed = _arg1;
            if (this._autoSwitch){
                this.debug((("Maximum bitrate allowed set to " + _arg1) + " kbps."));
            } else {
                this.debug((("Maximum bitrate allowed set to " + _arg1) + " kbps. This will be ignored since the class is currently in manual switching mode."));
            };
        }
        public function get maximizeSingleBitrateBuffers():Boolean{
            return (this._maximizeSingleBitrateBuffers);
        }
        public function set maximizeSingleBitrateBuffers(_arg1:Boolean):void{
            this._maximizeSingleBitrateBuffers = _arg1;
        }
        public function get playbackKbps():Number{
            return (Math.round(((this.info.playbackBytesPerSecond * 8) / 1000)));
        }
        public function get droppedFPS():Number{
            return (this._droppedFPS);
        }
        public function get averagePlaybackBitsPerSecond():Number{
            return (this._averagePlaybackBitsPerSecond);
        }
        public function get estimatedMaxbandwidth():Number{
            return (this._estimatedMaxbandwidth);
        }
        public function get estimatedCurrentBandwidth():Number{
            return (this._estimatedCurrentBandwidth);
        }
        public function get estimatedRTT():Number{
            return (this._estimatedRTT);
        }
        public function get secondsUntilBufferEmpties():Number{
            return (this._secondsUntilBufferEmpties);
        }
        public function get cpu():Number{
            return (this._cpu);
        }
        public function get lastThrottleValue():Number{
            return (this._lastThrottleValue);
        }
        public function get downloadRatio():Number{
            return (this._downloadRatio);
        }
        public function get isLiveStream():Boolean{
            return (this._isLiveStream);
        }
        public function get isPlayingLive():Boolean{
            return (this._isPlayingLive);
        }
        public function get isPausedWhileLive():Boolean{
            return (this._isPausedWhileLive);
        }
        public function get isComplete():Boolean{
            return (this._isComplete);
        }
        public function secondsToTimeCode(_arg1:Number):String{
            return (this.timeCode(_arg1));
        }
        public function get source(){
            return (this._source);
        }
        public function get droppedFrames():uint{
            return ((this.accummulatedDroppedFrames + super.info.droppedFrames));
        }
        public function set netSessionCpCode(_arg1:String):void{
            this.netSessionInterface.cpCode = _arg1;
        }
        public function destroy():void{
            this.stopTimers();
            removeEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus);
            removeEventListener(AsyncErrorEvent.ASYNC_ERROR, this.onAsyncError);
            removeEventListener(IOErrorEvent.IO_ERROR, this.onIOError);
            var _local1:HDClientProxy = (super.client as HDClientProxy);
            _local1.removeHandler("onMetaData", this.onMetaData);
            _local1.removeHandler("onEdge", this.onEdge);
            _local1.removeHandler("all", this.onAll);
            this.displayObject = null;
            this.clientObject = null;
            this.controller = null;
            this.netSessionInterface = null;
            this.currentMBRObject = null;
            this.bitrateTestTimer = null;
            this.throttleTimer = null;
            this.bufferInspectionTimer = null;
            this.switchTimeoutTimer = null;
            this.bandwidthEstimateFastTimer = null;
            this.nc = null;
            this.smilParser = null;
            this.swf = null;
            this.lastThrottleStats = null;
            this.deadConnectionTimer = null;
            this.csmaQosEventVo = null;
            if (this.qosManager != null){
                this.qosManager.destroy();
                this.qosManager = null;
            };
            super.close();
        }
        override public function get bytesLoaded():uint{
            return ((this.accummulatedBytesLoaded + super.bytesLoaded));
        }
        override public function get bufferTime():Number{
            return (this._targetBufferTime);
        }
        override public function set bufferTime(_arg1:Number):void{
        }
        public function get trueBufferTime():Number{
            return (super.bufferTime);
        }
        public function setCurrentIndex(_arg1:Number):void{
            if (this.currentMBRObject == null){
                this.debug("Cannot switch on non-multi-bitrate content");
            } else {
                if (this._autoSwitch){
                    this.debug("Cannot switch index manually since auto-switching is enabled");
                } else {
                    if (_arg1 == this.currentIndex){
                        this.debug((("You are trying to switch to " + _arg1) + " which is already the current index"));
                    } else {
                        if (this.isBeingIgnored(_arg1)){
                            this.debug((("Cannot switch to index " + _arg1) + " since it is currently being ignored"));
                        } else {
                            if (this.currentMBRObject.getRateAt(_arg1) > this._maximumBitrateAllowed){
                                this.debug((((("Warning - you are switching to a rendition whose bitrate (" + this.currentMBRObject.getRateAt(_arg1)) + "kbps) is greater than the maximum allowed bitrate of ") + this._maximumBitrateAllowed) + "kbps. The switch will still be honored."));
                            };
                            this.doSwitch(_arg1, "manual request", "MANUAL_REQUEST");
                        };
                    };
                };
            };
        }
        public function checkForNetSessionClient():void{
            this.netSessionInterface.requestCPU();
        }
        public function isPlayingMBRcontent():Boolean{
            return (((!((this.currentMBRObject == null))) && ((this.currentMBRObject.streamCount > 1))));
        }
        public function setRenderedDimensions(_arg1:Number, _arg2:Number):void{
            this.renderedWidth = _arg1;
            this.renderedHeight = _arg2;
        }
        public function set useVerboseGhostLogs(_arg1:Boolean):void{
            this._useVerboseGhostLogs = _arg1;
            this.controller.useVerboseGhostLogs = this._useVerboseGhostLogs;
        }
        public function sendUpdatedStats():void{
            this.updateCurrentRendition();
            dispatchEvent(new HDEvent(HDEvent.IS_LIVE_STREAM, this._isLiveStream));
        }
        public function makeTATrequest():void{
            this.controller.getTAT();
        }
        public function updateCurrentRendition():void{
            if (this.currentMBRObject != null){
                dispatchEvent(new HDEvent(HDEvent.RENDITION_CHANGE, {
                    currentIndex:this.currentIndex,
                    maxIndex:this.maxIndexAvailable,
                    currentKbps:this.currentMBRObject.getRateAt(this.currentIndex),
                    maxKbps:this.currentMBRObject.getRateAt(this.maxIndexAvailable)
                }));
            };
        }
        public function get maxIndexAvailable():Number{
            var _local1:Number;
            var _local2:Number;
            if ((this.currentMBRObject is IMBRObject)){
                _local1 = 0;
                _local2 = (this.currentMBRObject.streamCount - 1);
                while (_local2 > 0) {
                    if (this.currentMBRObject.getRateAt(_local2) <= this._maximumBitrateAllowed){
                        _local1 = _local2;
                        break;
                    };
                    _local2--;
                };
                return (_local2);
            };
            return (NaN);
        }
        public function get maxIndexAvailableBitrate():Number{
            return ((((this.currentMBRObject is IMBRObject)) ? this.currentMBRObject.getRateAt(this.maxIndexAvailable) : NaN));
        }
        public function get currentIndexBitrate():Number{
            return ((((this.currentMBRObject is IMBRObject)) ? this.currentMBRObject.getRateAt(this.currentIndex) : NaN));
        }
        override public function seek(_arg1:Number):void{
            var _local3:Number;
            var _local4:String;
            var _local2:Boolean = ((((!(isNaN(this.playLength))) && (!(isNaN(this.playStart))))) && ((this.playStart > 0)));
            if (!(this.trapFirstOnEdge)){
                if (_local2){
                    _arg1 = (_arg1 + this.playStart);
                };
                if ((((((this._dvrWindow > 0)) && (!((_arg1 == -1))))) && ((_arg1 < this.ABSOLUTE_SEEK_THRESHOLD)))){
                    if (this._duration > this._dvrWindow){
                        _arg1 = (_arg1 + (this._duration - this._dvrWindow));
                        this.debug(((("DVR Window enabled, so adjusting seek request from raw value of " + ((_arg1 - this._duration) + this._dvrWindow)) + " to ") + _arg1));
                    } else {
                        this.debug("DVR Window enabled and duration is smaller than dvr window, so seek request is unadjusted");
                    };
                    this.debug(((("Receiving seek request to a point " + " ") + (this._duration - _arg1)) + " back from live"));
                };
                if (this.isComplete){
                    this.beginPlay(this._source, _arg1, this.playLength, true);
                } else {
                    if (this.swfAuthUnderway){
                        this.debug("Queueing seek request until SWF Auth is complete");
                        this.pendingSeek = _arg1.toString();
                    } else {
                        this.accummulatedBytesLoaded = this.bytesLoaded;
                        this.accummulatedDroppedFrames = this.droppedFrames;
                        _local3 = ((_local2) ? (_arg1 - this.playStart) : _arg1);
                        dispatchEvent(new HDEvent(HDEvent.SEEK, {
                            seekTo:(((_local3 == -1)) ? "live" : (Math.round((_local3 * 100)) / 100)),
                            seekFrom:(Math.round((this.time * 100)) / 100)
                        }));
                        if (this.isPaused){
                            super.soundTransform = this.cloneExistingSoundTransform(0);
                        };
                        if (this.switchUnderway){
                            _local4 = (((this.currentMBRObject.httpBase + this.currentMBRObject.getNameAt(this.pendingIndex)) + (((this.currentMBRObject.getNameAt(this.pendingIndex).indexOf("?") == -1)) ? "?" : "&")) + this.currentURL.split("?")[1].toString());
                        } else {
                            _local4 = this.currentURL;
                        };
                        super.close();
                        super.bufferTime = this._startingBufferTimeOndemand;
                        this.callPauseOnce = true;
                        if ((this.duration - _arg1) < this._EOF_margin){
                            _arg1 = (this.duration - this._EOF_margin);
                            this.debug((((("Adjusting seek time to " + _arg1) + " since it is within ") + this._EOF_margin) + " seconds of the end of the file"));
                        };
                        this.seekTarget = (((_arg1 == -1)) ? this._duration : (((_arg1 > this.ABSOLUTE_SEEK_THRESHOLD)) ? (_arg1 - (this._streamStartTime / 1000)) : _arg1));
                        this.assembleAndPlayURL(_local4, ((((this._isLiveStream) && ((_arg1 < 0)))) ? "live" : _arg1.toString()));
                    };
                };
            } else {
                this.debug("Disallowing SEEK request since the prior request has not yet completed");
            };
        }
        override public function pause():void{
            dispatchEvent(new HDEvent(HDEvent.PAUSE));
            this.isPaused = true;
            this.timeAtLastPause = this._time;
            this.onEdgeCount = 0;
            this.timerAtLastPause = getTimer();
            if (((this.isLiveStream) && (this.isPlayingLive))){
                this._isPausedWhileLive = true;
            };
            super.pause();
        }
        override public function resume():void{
            dispatchEvent(new HDEvent(HDEvent.RESUME));
            this.volume = this._volume;
            this.throttle(this.UP_SWITCH_THROTTLE);
            this.isPaused = false;
            if (this._isPausedWhileLive){
                this._isPausedWhileLive = false;
                this.beginPlay(this._source, -1);
            } else {
                if (this._isComplete){
                    this.beginPlay(this._source, ((isNaN(this.playStart)) ? -1 : this.playStart));
                } else {
                    if (((((getTimer() - this.timerAtLastPause) > this.IDLE_TIMEOUT_MILLSECONDS)) && ((Math.abs(((this.time + super.bufferLength) - this._duration)) > this.EOF_MARGIN)))){
                        this.recoverFromTimeOut(this.timeAtLastPause);
                    } else {
                        super.bufferTime = this.STARTING_BUFFER_TIME_ONDEMAND;
                        super.resume();
                    };
                };
            };
        }
        override public function close():void{
            this.stopTimers();
            super.close();
        }
        public function get duration():Number{
            return ((((this._dvrWindow > 0)) ? Math.min(this._duration, this._dvrWindow) : this._duration));
        }
        public function get volume():Number{
            return (this._volume);
        }
        public function set volume(_arg1:Number):void{
            this._volume = _arg1;
            this.soundTransform = this.cloneExistingSoundTransform(_arg1);
        }
        override public function get soundTransform():SoundTransform{
            return (super.soundTransform);
        }
        override public function set soundTransform(_arg1:SoundTransform):void{
            this._volume = _arg1.volume;
            super.soundTransform = _arg1;
        }
        override public function play(... _args):void{
            if (this.qosManager != null){
                this.qosManager.reset();
            };
            this.beginPlay.apply(this, _args);
        }
        public function simulateTimeout():void{
            if (this.enableAlternateServerMapping){
                this.csmaQosEventVo.reason = QoSEventVO.REASON_DATA_GAP;
                this.failOverToAlternateServer();
            } else {
                this.debug(("Alternate Server Mapping is not enabled so this feature will not be simulated. " + "To turn it on set the property 'enableAlternateServerMapping' in HDNetStream to true."));
            };
        }
        function getQoSManager():HDN1QoSManager{
            return (this.qosManager);
        }
        public function simulateForceTimerComplete():void{
            this.qosManager.addEventListener(QoSEvent.FORCE_TIMEOUT, this.onQoSForceTimerTimeout);
            this.qosManager.simulateForceTimerComplete();
        }
        public function simulateFailbackToPrimaryTimerComplete():void{
            this.qosManager.addEventListener(QoSEvent.FAILBACK_TO_PRIMARY, this.onFailbackToPrimaryReady);
            this.qosManager.simulateFailbackToPrimaryTimerComplete();
        }
        public function simulateFailToRtmp():void{
            this.failToRtmp();
        }
        protected function getStartingIndex(_arg1:IMBRObject):int{
            var _local2:Number;
            var _local3:Number;
            var _local4:Number;
            var _local5:Number;
            if (((!(isNaN(this._startingIndex))) && ((this._startingIndex >= 0)))){
                this.debug((("Selecting starting index " + this._startingIndex) + " as it was explicitly set"));
                return (this._startingIndex);
            };
            if (((((!(isNaN(this.lastBitrateMeasured))) && (this._autoSwitch))) && ((this.lastBitrateMeasured > 0)))){
                _local2 = 0;
                _local3 = (_arg1.streamCount - 1);
                while (_local3 > 0) {
                    if ((((_arg1.getRateAt(_local3) <= (this.lastBitrateMeasured / this.BANDWIDTH_SAFETY_FACTOR_HIGH_RTT))) && ((_arg1.getRateAt(_local3) <= this._maximumBitrateAllowed)))){
                        _local2 = _local3;
                        break;
                    };
                    _local3--;
                };
                this.debug((((("Selecting starting index " + _local2) + " due to a last bandwidth estimate of ") + this.lastBitrateMeasured) + "kbps"));
                return (_local2);
            };
            if (!(this._autoSwitch)){
                this.debug("Using starting index of 0 since switching is in manual mode");
                return (0);
            };
            _local4 = 0;
            _local5 = (_arg1.streamCount - 1);
            while (_local5 > 0) {
                if (_arg1.getRateAt(_local5) <= this.MAX_STARTING_BITRATE){
                    _local4 = _local5;
                    break;
                };
                _local5--;
            };
            this.debug((((("Selecting starting index " + _local4) + " since it is the highest which is <= ") + this.MAX_STARTING_BITRATE) + "kbps"));
            return (_local4);
        }
        private function failToRtmp():void{
            this.stopTimers();
            this.close();
            dispatchEvent(new HDEvent(HDEvent.FAIL_OVER_TO_RTMP, (((this.currentMBRObject == null)) ? this._source : this.currentMBRObject)));
            this.debug("RTMP FALLBACK");
        }
        private function prepareURL(_arg1:String, _arg2:String):void{
            this.controller.streamName = this.currentStreamName;
            this.updateStreamName();
            _arg1 = (_arg1 + (((((((((((!((_arg1.indexOf("?") == -1))) ? "&" : "?") + "v=") + HDVersion.version) + "&fp=") + Capabilities.version.replace(" ", "%20")) + "&r=") + URLUtils.getCacheBustString()) + "&g=") + this.guid) + ((this._useVerboseGhostLogs) ? "&verbose=on" : "")));
            this.currentURL = _arg1;
            if ((this._tokenService is ITokenService)){
                if (((!((_arg2 == null))) && (!((_arg2 == "-1"))))){
                    _arg1 = (_arg1 + ("&seek=" + _arg2));
                };
                this.pendingSeek = null;
                this.debug(("Requesting token for this url: " + _arg1));
                this._tokenService.requestTokenizedURL(_arg1);
            } else {
                this.assembleAndPlayURL(_arg1, (((_arg2 == "-1")) ? null : _arg2));
            };
        }
        public function get autoSwitch():Boolean{
            return (this._autoSwitch);
        }
        public function set autoSwitch(_arg1:Boolean):void{
            if (this.switchUnderway){
                this.debug("Cannot change switching mode while a switch is underway");
            } else {
                this._autoSwitch = _arg1;
                this.debug(("Switching mode changed to : " + ((_arg1) ? "auto" : "manual")));
            };
        }
        public function get isSwitching():Boolean{
            return (this.switchUnderway);
        }
        private function init():void{
            this.guid = URLUtils.getCacheBustString(12);
            this.checkPolicyFile = true;
            addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus, false, 0, true);
            addEventListener(AsyncErrorEvent.ASYNC_ERROR, this.onAsyncError, false, 0, true);
            addEventListener(IOErrorEvent.IO_ERROR, this.onIOError, false, 0, true);
            super.client = new HDClientProxy();
            super.client.addHandler("onMetaData", this.onMetaData);
            super.client.addHandler("onEdge", this.onEdge);
            super.client.addHandler("all", this.onAll);
            this.metricsTimer = new Timer(this.METRICS_INTERVAL);
            this.metricsTimer.addEventListener(TimerEvent.TIMER, this.updateMetrics, false, 0, true);
            this.progressTimer = new Timer(this.DEFAULT_PROGRESS_INTERVAL);
            this.progressTimer.addEventListener(TimerEvent.TIMER, this.onProgress, false, 0, true);
            this.bitrateTestTimer = new Timer(Math.round((this.BITRATE_TEST_BASE_INTERVAL + (Math.random() * this.BITRATE_TEST_RANDOM_INTERVAL))));
            this.bitrateTestTimer.addEventListener(TimerEvent.TIMER, this.onBitrateTestTimer, false, 0, true);
            this.throttleTimer = new Timer(this.THROTTLE_INSPECTION_INTERVAL);
            this.throttleTimer.addEventListener(TimerEvent.TIMER, this.onThrottleTimer, false, 0, true);
            this.switchTimeoutTimer = new Timer(this.SWITCH_TIMEOUT, 1);
            this.switchTimeoutTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.onSwitchTimeout, false, 0, true);
            this.bandwidthEstimateFastTimer = new Timer(this.BANDWIDTH_FAST_INSPECTION_INTERVAL);
            this.bandwidthEstimateFastTimer.addEventListener(TimerEvent.TIMER, this.onCheckBandwidth, false, 0, true);
            this.eosLiveTimer = new Timer(this.EOS_LIVE_TIMEOUT_AFTER_BUFFER_EMPTY, 1);
            this.eosLiveTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.onEOSLiveTimeout, false, 0, true);
            this.eosVodTimer = new Timer(this.EOS_VOD_TIMEOUT_AFTER_BUFFER_EMPTY, 1);
            this.eosVodTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.onEOSVodTimeout, false, 0, true);
            this.deadConnectionTimer = new Timer(this.DEAD_CONNECTION_TIMEOUT, 1);
            this.deadConnectionTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.onDeadConnection, false, 0, true);
            this.controller = new HDServerController();
            this.controller.guid = this.guid;
            this.controller.addEventListener(HDEvent.FAILURE, this.onControlFailure, false, 0, true);
            this.controller.addEventListener(HDEvent.SUCCESS, this.onControlSuccess, false, 0, true);
            this.controller.addEventListener(HDEvent.DEBUG, this.onDebug, false, 0, true);
            this.controller.addEventListener(HDEvent.RTT, this.onRTT, false, 0, true);
            this.controller.addEventListener(HDEvent.TAT, this.onTAT, false, 0, true);
            this.smilParser = new HDSMILParser();
            this.smilParser.addEventListener(HDEvent.FAILURE, this.onParserFailure, false, 0, true);
            this.smilParser.addEventListener(HDEvent.PARSED, this.onParsed, false, 0, true);
            this.netSessionInterface = new HDNetSessionInterface();
            this.netSessionInterface.addEventListener(HDEvent.CPU, this.onCPU, false, 0, true);
            this.netSessionInterface.addEventListener(HDEvent.FAILURE, this.onNetSessionFailure, false, 0, true);
            this.netSessionInterface.addEventListener(HDEvent.DEBUG, this.onDebug, false, 0, true);
            this.netSessionInterface.addEventListener(HDEvent.NETSESSION_CLIENT, this.onNetSessionClient, false, 0, true);
            this.netSessionInterface.addEventListener(HDEvent.NETSESSION_EULA, this.onNetSessionEULA, false, 0, true);
        }
        private function assembleAndPlayURL(_arg1:String, _arg2:String):void{
            this.lastDroppedFrameCount = 0;
            this.lastDroppedFrameTime = 0;
            this._secondsUntilBufferEmpties = 0;
            this.lastSwitchTime = (-1 * this.WAIT_AFTER_SWITCH);
            this._nominalFPS = 0;
            this.lastBufferValue = 0;
            this.lastBufferTime = 0;
            this.lastStopEventTime = 0;
            this.lastPlayBackRate = 0;
            this.timeAtLastBitrateTest = 0;
            this.timeAtEndOfLastBitrateTest = (-1 * this.WAIT_AFTER_BITRATE_TEST);
            this.hasReachedBufferTarget = false;
            this._isComplete = false;
            if (((!((this._primaryToken == ""))) && (!((this._primaryToken == null))))){
                _arg1 = (_arg1 + ("&primaryToken=" + this._primaryToken));
                this._primaryToken = "";
            };
            if (((!((_arg1.indexOf("?") == -1))) && (!((_arg1.indexOf("primaryToken=") == -1))))){
                this.useTransferToken = true;
            };
            if (((this.useTransferToken) && (!((this.transferToken == ""))))){
                _arg1 = _arg1.replace(/primaryToken=(.*?)\&/, "");
            };
            if (_arg2 != null){
                if (_arg1.indexOf("seek=") != -1){
                    _arg1 = _arg1.replace(/seek=(.*?)(\&|\b)/, "");
                };
                if (_arg1.indexOf("seekABS=") != -1){
                    _arg1 = _arg1.replace(/seekABS=(.*?)(\&|\b)/, "");
                };
                _arg1 = (_arg1 + ((((!((_arg1.indexOf("?") == -1))) ? "&" : "?") + (((((this._dvrWindow > 0)) && (!((_arg2 == "live"))))) ? ("seekABS=" + this.convertToAbsoluteSeconds(_arg2)) : ("seek=" + _arg2))) + ((((!((this.transferToken == ""))) && (((this.useTransferToken) || (this.requiresSwfAuth))))) ? ((("&transferToken=" + this.transferToken) + "&session=") + this.sessionID) : "")));
                this.transferToken = "";
            };
            if (((!((this.qosManager == null))) && (this.qosManager.playingFromAlternateServer))){
                _arg1 = (_arg1 + "&alt=true");
            };
            this.pendingPlayURL = _arg1;
            if (((((this.enableAlternateServerMapping) && ((this.qosManager.primaryHostURL == null)))) && (!(this.qosManager.playingFromAlternateServer)))){
                this.makeQosIdentRequest();
            } else {
                this.callPlay();
            };
        }
        private function callPlay():void{
            this._lastThrottleValue = 100;
            this.lastThrottleTime = getTimer();
            this.throttleTimer.stop();
            this.bitrateTestUnderway = false;
            this.bitrateTestTimer.start();
            this.needBitrateTest = false;
            this.trapFirstOnEdge = true;
            if (!(this.metricsTimer.running)){
                this.metricsTimer.start();
            };
            if (!(this.progressTimer.running)){
                this.progressTimer.start();
            };
            if (!(this.bandwidthEstimateFastTimer.running)){
                this.bandwidthEstimateFastTimer.start();
            };
            dispatchEvent(new HDEvent(HDEvent.PLAY, {
                source:(((this.currentMBRObject is IMBRObject)) ? this.currentMBRObject : this._source),
                stream:this.pendingPlayURL,
                index:this.currentIndex
            }));
            this.debug(("Requesting: " + this.pendingPlayURL));
            super.play(this.pendingPlayURL, 0);
        }
        private function convertToAbsoluteSeconds(_arg1:String):String{
            var _local2:Number = Number(_arg1);
            if (this._dvrWindow > 0){
                if ((((_local2 == -1)) || ((_local2 > this.ABSOLUTE_SEEK_THRESHOLD)))){
                } else {
                    _local2 = (_local2 + (this._streamStartTime / 1000));
                    _local2 = (Math.round((_local2 * 100)) / 100);
                };
            };
            this.debug(((((((("Seeking to an absolute time of " + _local2) + " while stream start time=") + (this._streamStartTime / 1000)) + " now (relative)=") + this._duration) + " and now(absolute)=") + (this._duration + (this._streamStartTime / 1000))));
            return (_local2.toString());
        }
        private function onControlFailure(_arg1:HDEvent):void{
            if (!(this._isComplete)){
                this.debug(("Control failure: " + _arg1.data.toString()));
            };
            if (_arg1.data.toString().indexOf("error=switch_in_progress") != -1){
                setTimeout(this.resetSwitch, 1000);
            };
        }
        private function resetSwitch():void{
            this.switchUnderway = false;
        }
        private function onControlSuccess(_arg1:HDEvent):void{
        }
        public function onMetaData(_arg1:Object):void{
            var _local2:Number;
            dispatchEvent(new HDEvent(HDEvent.METADATA, _arg1));
            if (_arg1["duration"] != undefined){
                this.tat = Number(_arg1["duration"]);
            };
            if (((((!((_arg1["width"] == undefined))) && (!((_arg1["height"] == undefined))))) && (!((this.currentMBRObject == null))))){
                _local2 = (((this.pendingIndex > 0)) ? this.pendingIndex : this.currentIndex);
                this.currentMBRObject.setDimensionsAt(_local2, Number(_arg1["width"]), Number(_arg1["height"]));
            };
        }
        private function onAll(... _args):void{
            var _local2:Object = _args[1];
            if (((!((this.clientObject == null))) && (this.clientObject.hasOwnProperty((_args[0] as String))))){
                (this.clientObject[(_args[0] as String)] as Function).apply(this, [_local2]);
            };
            dispatchEvent(new HDEvent(HDEvent.DATA_MESSAGE, {
                name:(_args[0] as String),
                value:_local2
            }));
        }
        public function onEdge(_arg1:Object):void{
            var _local2:Number;
            var _local3:Number;
            var _local4:Number;
            var _local5:int;
            var _local6:Array;
            var _local7:Number;
            var _local8:Boolean;
            var _local9:Number;
            var _local10:Loader;
            this.onEdgeCount++;
            if (this.enableAlternateServerMapping){
                if (_arg1["force"] != undefined){
                    this.qosManager.onEdgeForceTag = _arg1.force;
                    if (!(this.qosManager.hasEventListener(QoSEvent.FORCE_TIMEOUT))){
                        this.qosManager.addEventListener(QoSEvent.FORCE_TIMEOUT, this.onQoSForceTimerTimeout);
                    };
                };
                if (_arg1["ai"] != undefined){
                    this.qosManager.onEdgeAlternateInRegionTag = _arg1.ai;
                    this.debug(("QOS alternate-in-region onEdge data received - " + _arg1.ai));
                };
            };
            if (((((this.onEdgeCount % 6) == 0)) && (!(isNaN(this.streamTimeAtlastCheck))))){
                _local2 = (Math.round(((getTimer() - this.systemTimeAtLastCheck) * 1000)) / 1000);
                _local3 = Math.round((1000 * (super.time - this.streamTimeAtlastCheck)));
                this.debug((((((((("System clock change: " + _local2) + " FLV timestamp change: ") + _local3) + " giving delta of  ") + (_local2 - _local3)) + " over ") + (5000 * 6)) + "ms"));
            };
            this.streamTimeAtlastCheck = super.time;
            this.systemTimeAtLastCheck = getTimer();
            if (_arg1["dvrWindow"] != undefined){
                _local4 = Number(_arg1["dvrWindow"].toString());
                if (_local4 != this._dvrWindow){
                    this._dvrWindow = _local4;
                    this.debug(("DVR window detected: " + this._dvrWindow));
                    dispatchEvent(new HDEvent(HDEvent.DVR_WINDOW, this._dvrWindow));
                };
            };
            if (_arg1["streamType"] != undefined){
                _local5 = (_arg1["streamType"] as int);
                if (this._streamType != _local5){
                    this._streamType = _local5;
                    _local6 = ["Unknown", "Video-only", "Audio-only", "Video and Audio"];
                    this.debug(("Stream-type identified: " + _local6[this._streamType]));
                    dispatchEvent(new HDEvent(HDEvent.STREAM_TYPE_CHANGE, this._streamType));
                };
            };
            if (_arg1["edgeVersion"] != undefined){
                this.edgeVersion = _arg1["edgeVersion"].toString();
                this.debug(("EdgeVersion detected: " + this.edgeVersion));
            };
            if (_arg1["edgeIP"] != undefined){
                this.edgeIP = _arg1["edgeIP"].toString();
                if (((this.enableAlternateServerMapping) && (!((this.csmaQosEventVo == null))))){
                    this.csmaQosEventVo.ip = this.edgeIP;
                };
                this.debug(("Edge server IP address: " + this.edgeIP));
            };
            if (_arg1["playerIP"] != undefined){
                this.playerIP = _arg1["playerIP"].toString();
                this.debug(("Player IP address: " + this.playerIP));
            };
            if (_arg1["streamName"] != undefined){
                if (this.currentStreamName != _arg1["streamName"].toString()){
                    this.currentURL = (((this.controller.controlHost + _arg1["streamName"].toString()) + "?") + this.currentURL.split("?")[1].toString());
                    this.currentStreamName = _arg1["streamName"].toString();
                    this.controller.streamName = this.currentStreamName;
                    this.updateStreamName();
                    if (this.switchUnderway){
                        this.switchUnderway = false;
                        this.switchTimeoutTimer.stop();
                        this._nominalFPS = 0;
                        this.lastBufferValue = 0;
                        this.lastBufferTime = 0;
                        this._secondsUntilBufferEmpties = 0;
                        this.lastSwitchTime = getTimer();
                        this.currentIndex = this.pendingIndex;
                        this.debug((((((((("Switch to index " + this.currentIndex) + " took ") + ((getTimer() - this.timeAtLastSwitchStart) / 1000)) + "s of which ") + (Math.round((this.bufferAtLastSwitch * 10)) / 10)) + "s was client buffer and approx. ") + (Math.round(((((getTimer() - this.timeAtLastSwitchStart) / 1000) - (Math.round((this.bufferAtLastSwitch * 10)) / 10)) * 10)) / 10)) + "s was server-side"));
                        dispatchEvent(new HDEvent(HDEvent.SWITCH_COMPLETE, this.currentIndex));
                        this.updateCurrentRendition();
                        this.needBitrateTest = true;
                        if (!(this.trapFirstOnEdge)){
                            this._estimatedMaxbandwidth = 0;
                        };
                    };
                };
            };
            if (_arg1["transferToken"] != undefined){
                this.transferToken = _arg1["transferToken"].toString();
                this.debug(("New transferToken received:  " + this.transferToken));
            };
            if (_arg1["streamStartTime"] != undefined){
                _local7 = (Number(_arg1["streamStartTime"].toString()) * 1000);
                if (this._streamStartTime != _local7){
                    this._streamStartTime = _local7;
                    dispatchEvent(new HDEvent(HDEvent.STREAM_START_TIME, this._streamStartTime));
                    this.debug((((("Stream start time received from server " + new Date(this._streamStartTime).toString()) + "(") + this._streamStartTime) + ")"));
                };
            };
            if (_arg1["session"] != undefined){
                if (_arg1["session"].toString() != this.sessionID){
                    this.sessionID = _arg1["session"].toString();
                    this.controller.sessionID = this.sessionID;
                    this.debug(("New sessionID received:  " + this.sessionID));
                    dispatchEvent(new HDEvent(HDEvent.SESSION_ID, this.sessionID));
                    this.lastSwitchTime = getTimer();
                };
            };
            if (_arg1["authToken"] != undefined){
                this.authToken = _arg1["authToken"].toString();
                this.debug(("New authToken received: " + this.authToken));
                this.controller.sendSecondaryToken(this.authToken);
            };
            if (_arg1["timeBase"] != undefined){
                this.timeBase = Number(_arg1["timeBase"].toString());
                this.trapTime = true;
            };
            if (_arg1["tat"] != undefined){
                this.tat = Number(_arg1["tat"].toString());
                this.timerAtLastTat = getTimer();
                this._liveDrift = (Number(_arg1["tat"].toString()) - this.timeBase);
            };
            if (_arg1["errorNumber"] != undefined){
                this.errorNumber = Number(_arg1["errorNumber"].toString());
            };
            if (_arg1["isLive"] != undefined){
                _local8 = (_arg1["isLive"].toString() == "true");
                if (this._isLiveStream != _local8){
                    this._isLiveStream = _local8;
                    dispatchEvent(new HDEvent(HDEvent.IS_LIVE_STREAM, this._isLiveStream));
                };
            };
            if (_arg1["status"] != undefined){
                this.status = Number(_arg1["status"].toString());
                switch (this.status){
                    case 1:
                        break;
                    case 2:
                        break;
                    case 3:
                        this.onComplete();
                        break;
                    case 4:
                        dispatchEvent(new HDEvent(HDEvent.ERROR, this.errorNumber));
                        switch (this.errorNumber){
                            case 0:
                                break;
                            case 1:
                                this.debug("STREAM NOT FOUND WHILE PLAYING");
                                dispatchEvent(new HDEvent(HDEvent.STREAM_NOT_FOUND_WHILE_PLAYING));
                                this.stopTimers();
                                break;
                            case 2:
                                this.debug("TRACK NOT FOUND");
                                this.debug((((("adding index " + this.pendingIndex) + " to the ignore list for ") + this.IGNORE_PERIOD) + "ms"));
                                this.ignoreList.push({
                                    index:this.pendingIndex,
                                    time:getTimer()
                                });
                                this.switchUnderway = false;
                                this.switchTimeoutTimer.stop();
                                this.pendingIndex = this.currentIndex;
                                dispatchEvent(new HDEvent(HDEvent.SWITCH_COMPLETE, this.currentIndex));
                                break;
                            case 3:
                                this.debug("SEEK OUT OF BOUNDS");
                                break;
                            case 4:
                                this.debug("AUTHENTICATION FAILED");
                                break;
                            case 5:
                                this.debug("DVR DISABLED");
                                break;
                            case 6:
                                this.debug("INVALID BITRATE TEST");
                                break;
                            case 7:
                                this.failToRtmp();
                                break;
                        };
                        break;
                    case 5:
                        this.switchUnderway = false;
                        this.bitrateTestUnderway = false;
                        this.recoverFromTimeOut(this._time);
                        break;
                    case 6:
                        this.debug("MUST DISCONNECT");
                        this.recoverFromTimeOut(this._time);
                        break;
                };
            };
            if (_arg1["liveDelay"] != undefined){
                _local9 = Number(_arg1["liveDelay"].toString());
                if (_local9 != this.delayFromLive){
                    this.delayFromLive = _local9;
                    this.debug((("Live delay is " + this.delayFromLive) + "s."));
                };
            };
            if (_arg1["data64"] != undefined){
                this.debug("SWF verification initiated");
                _local10 = new Loader();
                _local10.contentLoaderInfo.addEventListener(Event.COMPLETE, this.onSwfLoaderComplete, false, 0, true);
                _local10.loadBytes(HDBase64.decodeToByteArray((_arg1["data64"] as String)));
                this.swfAuthUnderway = true;
                this.requiresSwfAuth = true;
            };
            if (this.trapFirstOnEdge){
                this.trapFirstOnEdge = false;
                this.debug(("Live stream: " + this.isLiveStream.toString()));
                this._isPlayingLive = ((this._isLiveStream) && ((Math.round((this.tat - this.timeBase)) < this.PLAYING_LIVE_DELTA)));
                if (this._isPlayingLive){
                    dispatchEvent(new HDEvent(HDEvent.IS_PLAYING_LIVE, true));
                    this._startingBufferTimeLive = this._startingBufferTimeOndemand;
                    super.bufferTime = this._startingBufferTimeLive;
                    this.debug(("Setting bufferTime in onEdge to " + super.bufferTime));
                    this._targetBufferTime = this._startingBufferTimeLive;
                } else {
                    dispatchEvent(new HDEvent(HDEvent.IS_PLAYING_LIVE, false));
                };
                this.throttleTimer.start();
                this.needBitrateTest = true;
                this.lastPlayBackRate = super.info.playbackBytesPerSecond;
            };
            this.debug(((((((("onEdge received: timebase=" + (Math.round((this.timeBase * 1000)) / 1000)) + " tat=") + (Math.round((this.tat * 1000)) / 1000)) + " timeBase-delta=") + Math.round((this.timeBase - this.lastTimebase))) + " tat-delta=") + (Math.round(((this.tat - this.lastTat) * 1000)) / 1000)));
            this.lastTat = this.tat;
            this.lastTimebase = this.timeBase;
            this.debug(("Stats: " + this.controller.qosArgs.slice(6)));
            if (super.bytesLoaded > this.MAXIMUM_SESSION_BYTES){
                this.debug(("Session bytes have reached byte limit of " + this.MAXIMUM_SESSION_BYTES));
                this.beginPlay(this._source, ((this._isPlayingLive) ? -1 : this._time), this.playLength, true);
            };
        }
        private function onDebug(_arg1:HDEvent):void{
            this.debug((_arg1.data as String));
        }
        private function debug(_arg1:String):void{
            dispatchEvent(new HDEvent(HDEvent.DEBUG, _arg1));
            if (this.logger != null){
                this.logger.debug(_arg1);
            };
        }
        private function updateMetrics(_arg1:TimerEvent):void{
            var _local2:Boolean;
            var _local3:String;
            if ((((((super.time >= 0)) && (super.hasOwnProperty("info")))) && ((super.info is NetStreamInfo)))){
                this.updateTimeAndDuration();
                if (((((this.allowSubClipCheck) && (!(isNaN(this.playLength))))) && ((this.playLength > 0)))){
                    if (this._time >= (this.playStart + this.playLength)){
                        this.allowSubClipCheck = false;
                        this.debug(((((("Completing playback : time=" + this._time) + ", start=") + this.playStart) + ", len=") + this.playLength));
                        this.onComplete();
                        return;
                    };
                };
                if ((((((((((((this.bufferLength < this.MASTER_BUFFER_TIME)) && ((this.bufferLength >= (this._startingBufferTimeOndemand * 0.5))))) && (!((Math.round(super.bufferTime) == Math.round(this.maxBufferTime())))))) && (!(this.isBuffering)))) && ((Math.abs((super.info.playbackBytesPerSecond - this.lastPlayBackRate)) > 0)))) && ((this.lastPlayBackRate > 0)))){
                    super.bufferTime = this.maxBufferTime();
                    this.hasReachedBufferTarget = true;
                    this.seekTarget = -1;
                };
                this.lastPlayBackRate = super.info.playbackBytesPerSecond;
                if (((((((this.isPaused) && (this.hasReachedBufferTarget))) && ((super.currentFPS > 0)))) && (this.callPauseOnce))){
                    this.callPauseOnce = false;
                    super.pause();
                };
                if (((((this.isPaused) && ((this.bufferLength < this._targetBufferTime)))) && ((super.bufferTime < this._targetBufferTime)))){
                    super.bufferTime = this.maxBufferTime();
                };
                if (((((!(this.isPaused)) && (this._isPlayingLive))) && ((this._liveDrift > this.maxLiveDriftAllowed)))){
                    this.debug((((("Live drift value of " + this._liveDrift) + " exceeds the max allowed value of ") + this.maxLiveDriftAllowed) + ". Seeking back to live"));
                    this._liveDrift = 0;
                    this.beginPlay(this._source, -1);
                };
                if (((((this.bitrateTestUnderway) && (!((this._lastThrottleValue == this.MIN_THROTTLE))))) && ((((((this.timeAtLastBitrateTest > 0)) && (((getTimer() - this.timeAtLastBitrateTest) > this.BANDWIDTH_TEST_DURATION)))) || (((this.bufferLength - this.bufferAtLastBitrateTest) > this.BANDWIDTH_TEST_ALLOWED_BUFFER_GROWTH)))))){
                    this.bitrateTestUnderway = false;
                    this.lastBitrateMeasured = this._estimatedMaxbandwidth;
                    dispatchEvent(new HDEvent(HDEvent.BANDWIDTH, this._estimatedMaxbandwidth));
                    this.debug((((("Bandwidth test complete. Max is " + this._estimatedMaxbandwidth) + " kbps, Current is ") + this._estimatedCurrentBandwidth) + " kbps"));
                    this.timeAtEndOfLastBitrateTest = getTimer();
                    this.needBitrateTest = false;
                };
                if (((this.needBitrateTest) && (!(this.swfAuthUnderway)))){
                    this.requestBitrateTest();
                };
                this._nominalFPS = (((this.currentFPS > this._nominalFPS)) ? Math.round(this.currentFPS) : this._nominalFPS);
                if (((((getTimer() - this.lastDroppedFrameTime) > this.DROPPED_FRAME_AVERAGING_PERIOD)) && (((getTimer() - this.lastSwitchTime) > this.WAIT_AFTER_SWITCH)))){
                    this._droppedFPS = (Math.round(((((super.info.droppedFrames - this.lastDroppedFrameCount) * 1000) / (getTimer() - this.lastDroppedFrameTime)) * 100)) / 100);
                    this.lastDroppedFrameCount = super.info.droppedFrames;
                    this.lastDroppedFrameTime = getTimer();
                };
                if (((((((!(this.trapTime)) && ((super.time < this.lastFLVTimeStamp)))) && ((super.time > this.WAIT_AFTER_SWITCH)))) && (((getTimer() - this.lastSwitchTime) > this.WAIT_AFTER_SWITCH)))){
                    this.debug((("Detected backward timestamp jump of " + (this.lastFLVTimeStamp - super.time)) + "s."));
                    this.debug((("Reloading from a start time of " + super.time) + "s."));
                    this.beginPlay(this._source, super.time, this.playLength, true);
                };
                if (!(this.trapTime)){
                    this.lastFLVTimeStamp = super.time;
                };
                this.adjustTargetBufferForRTT();
                _local2 = ((this.qosManager)!=null) ? this.qosManager.playingFromAlternateServer : false;
                _local3 = ((((((((((((((((((((((((((((((((((((((((((((((("&lvl1=" + this.bufferLength) + ",") + this._targetBufferTime) + ",") + super.bufferTime) + ",") + (Math.round((this.currentFPS * 100)) / 100)) + ",") + this.droppedFPS) + ",") + this._estimatedRTT) + ",") + this._estimatedMaxbandwidth) + ",") + this._estimatedCurrentBandwidth) + ",") + ((this.isPlayingMBRcontent()) ? this.currentIndex : "sbr")) + ",") + ((this.isPlayingMBRcontent()) ? this.currentMBRObject.getRateAt(this.currentIndex) : "sbr")) + ",") + (Math.round((this.time * 1000)) / 1000).toString()) + ",") + (new Date().time / 1000).toString()) + ",") + (Math.round((this.timeBase * 1000)) / 1000)) + ",") + (Math.round((super.time * 1000)) / 1000)) + ",") + (Math.round((this.timeAtLastOnEdge * 1000)) / 1000)) + ",") + (Math.round((this.tat * 1000)) / 1000)) + ",") + (Math.round(((getTimer() - this.timerAtLastTat) * 1000)) / 1000)) + ",") + (Math.round((this._downloadRatio * 100)) / 100)) + ",") + this.maxSecondsWithoutData) + ",") + super.info.droppedFrames) + ",") + this.lastDroppedFrameCount) + ",") + this.lastDroppedFrameTime) + ",") + this.HDClientVersion) + ",") + _local2);
                this.controller.qosArgs = _local3;
                if (((((((((!((this.currentMBRObject == null))) && (this._autoSwitch))) && (!(this.isPaused)))) && (!(this.swfAuthUnderway)))) && (((this._isPlayingLive) || (((!(this._isPlayingLive)) && ((this.time < (this._duration - this.bufferLength))))))))){
                    this.applySwitchingRules();
                };
            };
        }
        protected function applySwitchingRules():void{
            var _local5:Number;
            var _local6:Number;
            var _local7:Number;
            var _local8:Number;
            var _local9:Number;
            var _local10:Number;
            var _local11:Number;
            var _local12:Number;
            var _local13:int;
            var _local14:Object;
            var _local15:Number;
            var _local16:Number;
            var _local1:Number = this.currentIndex;
            var _local2:String = "Default reason";
            var _local3:String = "DEFAULT_REASON";
            var _local4:Number = ((this.isPlayingLive) ? this.DOWNLOAD_RATIO_THRESHOLD_LIVE : this.DOWNLOAD_RATIO_THRESHOLD);
            if (((((((((((((((!(this.switchUnderway)) && ((this.bufferLength < this.MAX_BUFFER_SWITCHDOWN_THRESHOLD)))) && ((this._downloadRatio < _local4)))) && ((this.bufferLength < ((this._targetBufferTime - this.LOWER_BUFFER_RANGE) - 1))))) && ((this.lastThrottleValue > 100)))) && (!(this.trapFirstOnEdge)))) && (((getTimer() - this.lastSwitchTime) > this.WAIT_AFTER_SWITCH_FOR_DOWNLOAD_RATIO)))) && (((getTimer() - this.timeAtEndOfLastBitrateTest) > this.WAIT_AFTER_BITRATE_TEST)))){
                _local5 = 0;
                _local6 = (this.currentMBRObject.streamCount - 1);
                while (_local6 >= 0) {
                    if ((((((this.currentMBRObject.getRateAt(_local6) <= (this._estimatedCurrentBandwidth / this.BANDWIDTH_SAFETY_FACTOR_LOW_RTT))) && ((this.currentMBRObject.getRateAt(_local6) <= this._maximumBitrateAllowed)))) && (!(this.isBeingIgnored(_local6))))){
                        _local5 = _local6;
                        break;
                    };
                    _local6--;
                };
                if (_local5 < _local1){
                    _local2 = ((((((((((((("Download ratio too low  " + (Math.round((this._downloadRatio * 100)) / 100)) + " < ") + _local4) + ", buffer is ") + Math.round(this.bufferLength)) + " and selecting index ") + _local5) + " since ") + this.currentMBRObject.getRateAt(_local5)) + " < ") + this._estimatedCurrentBandwidth) + "/") + this.BANDWIDTH_SAFETY_FACTOR_LOW_RTT);
                    _local3 = ((((((((((((("DOWNLOAD_RATIO_FAILURE," + (Math.round((this._downloadRatio * 100)) / 100)) + ",") + _local4) + ",") + _local5) + ",") + this.currentMBRObject.getRateAt(_local5)) + ",") + this._estimatedCurrentBandwidth) + ",") + this.BANDWIDTH_SAFETY_FACTOR_LOW_RTT) + ",") + this.currentStreamName);
                    _local1 = _local5;
                };
            };
            if (this._nominalFPS > this.MIN_NOMIMAL_FPS_TO_SWITCH){
                _local7 = (this._droppedFPS / this._nominalFPS);
                if (_local7 >= this.FRAMEDROP_THRESHOLD){
                    _local8 = 0;
                    _local9 = (this.currentIndex - 1);
                    while (_local9 >= 0) {
                        if (!(this.isBeingIgnored(_local9))){
                            _local8 = _local9;
                            break;
                        };
                        _local9--;
                    };
                    if (_local8 < _local1){
                        _local1 = _local8;
                        _local2 = ((((("Dropped frames ratio " + this._droppedFPS) + "/") + this._nominalFPS) + " > ") + this.FRAMEDROP_THRESHOLD);
                        _local3 = ((((((((((("DROPPED_FRAMES," + this._droppedFPS) + ",") + this._nominalFPS) + ",") + this.FRAMEDROP_THRESHOLD) + ",") + _local1) + ",") + this.currentMBRObject.getRateAt(_local1)) + ",") + this.currentStreamName);
                    };
                };
            };
            if (this.currentMBRObject.getRateAt(this.currentIndex) > this._maximumBitrateAllowed){
                _local10 = 0;
                _local2 = (((("Switching down since current rate of " + this.currentMBRObject.getRateAt(this.currentIndex)) + " kbps > max allowed bandwidth of ") + this._maximumBitrateAllowed) + " kbps and this is the lowest bitrate we have.");
                _local3 = ((((((((("MAX_ALLOWED_BITRATE," + this.currentMBRObject.getRateAt(this.currentIndex)) + ",") + this._maximumBitrateAllowed) + ",") + _local10) + ",") + this.currentMBRObject.getRateAt(_local10)) + ",") + this.currentStreamName);
                _local11 = (this.currentMBRObject.streamCount - 1);
                while (_local11 > 0) {
                    if ((((this.currentMBRObject.getRateAt(_local11) <= this._maximumBitrateAllowed)) && (!(this.isBeingIgnored(_local11))))){
                        _local10 = _local11;
                        break;
                    };
                    _local11--;
                };
                if (_local10 < _local1){
                    _local1 = _local10;
                    _local2 = (((("Switching down since current rate of " + this.currentMBRObject.getRateAt(this.currentIndex)) + " kbps > max allowed bandwidth of ") + this._maximumBitrateAllowed) + " kbps");
                    _local3 = ((((((((("MAX_ALLOWED_BITRATE," + this.currentMBRObject.getRateAt(this.currentIndex)) + ",") + this._maximumBitrateAllowed) + ",") + _local1) + ",") + this.currentMBRObject.getRateAt(_local1)) + ",") + this.currentStreamName);
                };
            };
            if (((((((((((((((this.considerDimensionsWhenSwitching) && ((this.currentIndex > 0)))) && ((this.renderedWidth > 0)))) && ((this.renderedHeight > 0)))) && ((this.currentMBRObject.getWidthAt(this.currentIndex) > this.renderedWidth)))) && ((this.currentMBRObject.getHeightAt(this.currentIndex) > this.renderedHeight)))) && ((((this.currentMBRObject.getWidthAt((this.currentIndex - 1)) == 0)) || ((this.currentMBRObject.getWidthAt((this.currentIndex - 1)) >= this.renderedWidth)))))) && ((((this.currentMBRObject.getHeightAt((this.currentIndex - 1)) == 0)) || ((this.currentMBRObject.getHeightAt((this.currentIndex - 1)) >= this.renderedHeight)))))){
                _local13 = this.currentIndex;
                while (_local13 > -1) {
                    _local14 = this.currentMBRObject.streams[_local13];
                    if ((((_local14.width <= this.renderedWidth)) && ((_local14.height <= this.renderedHeight)))){
                        _local12 = _local13;
                        break;
                    };
                    _local13--;
                };
                _local12 = ((isNaN(_local12)) ? (this.currentIndex - 1) : _local12);
                if (_local12 < _local1){
                    _local1 = _local12;
                    _local2 = "Switching down since this video is larger than the rendered area";
                    _local3 = ((((((((((((((("SIZE_LIMIT," + this.currentMBRObject.getWidthAt(this.currentIndex)) + "x") + this.currentMBRObject.getHeightAt(this.currentIndex)) + ",") + this.renderedWidth) + "x") + this.renderedHeight) + ",") + this.currentMBRObject.getWidthAt(_local1)) + "x") + this.currentMBRObject.getHeightAt(_local1)) + ",") + _local1) + ",") + this.currentStreamName);
                };
            };
            if (_local1 < this.currentIndex){
                this.doSwitch(_local1, _local2, _local3);
            } else {
                if (((((((((((((!(this.bitrateTestUnderway)) && ((this.bufferLength > this.MIN_BUFFER_TO_SWITCH_UP)))) && (((this._droppedFPS / this._nominalFPS) < this.FRAMEDROP_THRESHOLD)))) && ((this._estimatedMaxbandwidth > 0)))) && ((this.currentIndex < (this.currentMBRObject.streamCount - 1))))) && (((((((!(this.considerDimensionsWhenSwitching)) || ((this.currentMBRObject.getWidthAt((this.currentIndex + 1)) == 0)))) || ((this.renderedWidth == 0)))) || ((this.currentMBRObject.getWidthAt(this.currentIndex) < this.renderedWidth)))))) && (((((((!(this.considerDimensionsWhenSwitching)) || ((this.currentMBRObject.getHeightAt((this.currentIndex + 1)) == 0)))) || ((this.renderedHeight == 0)))) || ((this.currentMBRObject.getHeightAt(this.currentIndex) < this.renderedHeight)))))){
                    _local15 = 0;
                    _local16 = (this.currentMBRObject.streamCount - 1);
                    while (_local16 > 0) {
                        if ((((((this._estimatedMaxbandwidth > (this.currentMBRObject.getRateAt(_local16) * this.bandwidthSafetyFactor))) && ((this.currentMBRObject.getRateAt(_local16) <= this._maximumBitrateAllowed)))) && (!(this.isBeingIgnored(_local16))))){
                            _local15 = _local16;
                            _local2 = ((((("Switching up since " + this._estimatedMaxbandwidth) + " > ") + this.currentMBRObject.getRateAt(_local16)) + "*") + this.bandwidthSafetyFactor);
                            _local3 = ((((((((("SWITCH_UP," + this._estimatedMaxbandwidth) + ",") + this.currentMBRObject.getRateAt(_local16)) + ",") + this.bandwidthSafetyFactor) + ",") + _local15) + ",") + this.currentStreamName);
                            break;
                        };
                        _local16--;
                    };
                    if (_local15 > this.currentIndex){
                        this.doSwitch(_local15, _local2, _local3);
                    };
                };
            };
        }
        private function doSwitch(_arg1:Number, _arg2:String, _arg3:String):void{
            _arg1 = Math.max(0, _arg1);
            _arg1 = Math.min((this.currentMBRObject.streamCount - 1), _arg1);
            if (((((((((!((_arg1 == this.currentIndex))) && (!(this.switchUnderway)))) && ((((this.durationTimeDelta > Math.max((2 * this.bufferLength), this.EOF_MARGIN))) || (this.isPlayingLive))))) && (this.isAvailable(_arg1)))) && ((((_arg1 < this.currentIndex)) || (((((getTimer() - this.timeAtEndOfLastBitrateTest) > this.WAIT_AFTER_BITRATE_TEST)) && (((getTimer() - this.lastSwitchTime) > this.WAIT_AFTER_SWITCH)))))))){
                if ((((((((_arg1 < this.currentIndex)) && (this._autoSwitch))) && ((_arg3.indexOf("MAX_ALLOWED_BITRATE") == -1)))) && ((_arg3.indexOf("SIZE_LIMIT") == -1)))){
                    this.incrementFailCountAt(this.currentIndex);
                };
                dispatchEvent(new HDEvent(HDEvent.SWITCH_START, {
                    index:_arg1,
                    reason:_arg2
                }));
                this.debug(((("Switching to " + _arg1) + " : ") + _arg2));
                this.switchUnderway = true;
                this.pendingIndex = _arg1;
                this.firstThrottleBeforeSwitch = true;
                this.onThrottleTimer(null);
                this.controller.doSwitch(this.currentMBRObject.getNameAt(_arg1), _arg3);
                this.timeAtLastSwitchStart = getTimer();
                this.bufferAtLastSwitch = this.bufferLength;
            } else {
                if (((this.switchUnderway) && (!(this._autoSwitch)))){
                    this.debug("Cannot switch since the prior switch is still underway");
                } else {
                    if (((this.bitrateTestUnderway) && (!(this._autoSwitch)))){
                        this.debug("Cannot switch since the prior bitrate test is still underway");
                    } else {
                        if (((!(this.isAvailable(_arg1))) && (!(this._autoSwitch)))){
                            this.debug((("Cannot switch since index " + _arg1) + " has been locked out"));
                        };
                    };
                };
            };
        }
        private function onThrottleTimer(_arg1:TimerEvent):void{
            var _local2:Number;
            if (((((((((((((((((getTimer() - this.lastThrottleTime) > (((Math.abs((this.bufferLength - this._targetBufferTime)) < this.ALLOWABLE_BUFFER_DELTA)) ? this.MAX_THROTTLE_INTERVAL : this.MIN_THROTTLE_INTERVAL))) && (!(this.isPaused)))) && ((this.bufferLength < this.MASTER_BUFFER_TIME)))) && (!(this.swfAuthUnderway)))) && (!(this._isPausedWhileLive)))) && (!(this.bitrateTestUnderway)))) && (!(isNaN(this.bufferLength))))) && (!(this.swfAuthUnderway)))){
                if (((!(this.isPaused)) && ((this.bufferLength >= (this._targetBufferTime + this.UPPER_BUFFER_RANGE))))){
                    _local2 = ((this.isPlayingMBRcontent()) ? this.MIN_THROTTLE : ((this.useFixedThrottleForSBR) ? this.FIXED_THROTTLE : this.MIN_THROTTLE));
                } else {
                    if (this.bufferLength < (this._targetBufferTime - this.LOWER_BUFFER_RANGE)){
                        _local2 = this.MAX_THROTTLE;
                    } else {
                        if (this.bufferLength >= this._targetBufferTime){
                            if (((this.isPlayingMBRcontent()) || (!(this.useFixedThrottleForSBR)))){
                                _local2 = (this.MIN_THROTTLE + (((100 - this.MIN_THROTTLE) * (this.bufferLength - (this._targetBufferTime + this.UPPER_BUFFER_RANGE))) / (this._targetBufferTime - (this._targetBufferTime + this.UPPER_BUFFER_RANGE))));
                            } else {
                                _local2 = this.FIXED_THROTTLE;
                            };
                        } else {
                            _local2 = (this.MAX_THROTTLE + (((this.MAX_THROTTLE - 100) * (this.bufferLength - (this._targetBufferTime - this.LOWER_BUFFER_RANGE))) / ((this._targetBufferTime - this.LOWER_BUFFER_RANGE) - this._targetBufferTime)));
                        };
                    };
                };
                if (_local2 >= 0){
                    _local2 = Math.round(Math.min(this.MAX_THROTTLE, _local2));
                    _local2 = Math.max(0, _local2);
                    this.throttle(_local2);
                };
            };
            if (((this.isPaused) && ((this.bufferLength >= this._targetBufferTime)))){
                this.throttle(this.PAUSE_THROTTLE);
                dispatchEvent(new HDEvent(HDEvent.IS_BUFFERING, false));
            };
        }
        private function throttle(_arg1:Number):void{
            if (((((!((_arg1 == this._lastThrottleValue))) && (!(this.swfAuthUnderway)))) && ((((this.durationTimeDelta > this.EOF_MARGIN)) || (this.isPlayingLive))))){
                this.lastThrottleTime = getTimer();
                if (this.firstThrottleBeforeSwitch){
                    this.firstThrottleBeforeSwitch = false;
                    _arg1 = Math.min(this.MAX_THROTTLE, _arg1);
                    _arg1 = Math.max(100, _arg1);
                    this.debug(("Setting throttle before switch to " + _arg1));
                };
                this._lastThrottleValue = _arg1;
                this.controller.throttle(_arg1);
                this.debug(((("At throttle to " + _arg1) + " and bufferlength =") + this.bufferLength));
            };
            if (this._netSessionClientAvailable){
                this.netSessionInterface.requestCPU();
            };
        }
        private function onProgress(_arg1:TimerEvent):void{
            dispatchEvent(new HDEvent(HDEvent.PROGRESS));
        }
        private function onBitrateTestTimer(_arg1:TimerEvent):void{
            if (!(this.trapFirstOnEdge)){
                this.needBitrateTest = true;
            };
        }
        private function requestBitrateTest():void{
            if (((((((((((((((!(this.isPaused)) && ((this.bufferLength >= this._targetBufferTime)))) && (!(this.switchUnderway)))) && (!(this.bitrateTestUnderway)))) && (!(this.swfAuthUnderway)))) && ((((this.durationTimeDelta > (2 * (this.bufferLength + this.EOF_MARGIN)))) || (this.isPlayingLive))))) && (((getTimer() - this.lastSwitchTime) > this.WAIT_AFTER_SWITCH)))) && (((this.isPlayingMBRcontent()) || (!(this.useFixedThrottleForSBR)))))){
                this.needBitrateTest = false;
                if (((((((!((this.currentMBRObject == null))) && (!((this.currentIndex == (this.currentMBRObject.streamCount - 1)))))) || ((this.timeAtLastBitrateTest == 0)))) || (((getTimer() - this.timeAtLastBitrateTest) > this.BITRATE_TEST_MIN_DELAY_FOR_SBR)))){
                    this.debug(((("At bitrate test, bufferLength=" + this.bufferLength) + " target=") + this._targetBufferTime));
                    this.startBitrateTest();
                    this.controller.startRTTtest();
                } else {
                    this.controller.startRTTtest();
                };
            };
        }
        private function startBitrateTest():void{
            if (!(this.switchUnderway)){
                this.bitrateTestUnderway = true;
                this.bandwidthSampleArray.length = 0;
                this._estimatedMaxbandwidth = this._estimatedCurrentBandwidth;
                this.debug(("Starting bitrate test - throttling to " + this.BANDWIDTH_ESTIMATION_THROTTLE));
                this.throttle(this.BANDWIDTH_ESTIMATION_THROTTLE);
                this.timeAtLastBitrateTest = getTimer();
                this.bufferAtLastBitrateTest = this.bufferLength;
            } else {
                this.bitrateTestUnderway = false;
            };
        }
        private function onNetStatus(_arg1:NetStatusEvent):void{
            var _local2:Number;
            var _local3:Number;
            var _local4:Number;
            var _local5:Number;
            if (_arg1.info.code != "NetStream.Buffer.Flush"){
                dispatchEvent(new HDEvent(HDEvent.NET_STATUS, _arg1.info));
            };
            switch (_arg1.info.code){
                case "NetStream.Play.Start":
                    dispatchEvent(new HDEvent(HDEvent.IS_BUFFERING, true));
                    this.isBuffering = true;
                    this.timeAtLastBufferEmpty = getTimer();
                    this.timeAtLastBufferFull = 0;
                    break;
                case "NetStream.Buffer.Full":
                    _local2 = ((getTimer() - this.timeAtLastBufferEmpty) / 1000);
                    if (this.isPaused){
                        this.hasReachedBufferTarget = true;
                        if (this._isPausedWhileLive){
                            this._isPausedWhileLive = this.isPlayingLive;
                        };
                    };
                    this.debug(((("At bufferfull, bufferlength= " + this.bufferLength) + " bufferTime=") + super.bufferTime));
                    _local3 = (getTimer() - this.timeAtLastBufferEmpty);
                    dispatchEvent(new HDEvent(HDEvent.REBUFFER, (_local3 / 1000)));
                    this.controller.log("rebufferevent", (_local3 / 1000).toString());
                    this.timeAtLastBufferEmpty = 0;
                    this.onEdgeCount = 0;
                    this.seekTarget = -1;
                    this.bufferEmptyFlag = false;
                    dispatchEvent(new HDEvent(HDEvent.IS_BUFFERING, false));
                    this.isBuffering = false;
                    this.timeAtLastBufferFull = getTimer();
                    this.deadConnectionTimer.stop();
                    this.allowSubClipCheck = true;
                    if (((((this.isPlayingMBRcontent()) && ((this.currentIndex > 0)))) && ((_local2 > super.bufferTime)))){
                        _local4 = (_local2 / super.bufferTime);
                        _local5 = (this.currentMBRObject.getRateAt(this._currentIndex) / _local4);
                        this._currentIndex = this.getIndexBasedOnBandwidth(_local5);
                        this.debug(((((((("Changing the MBR index to " + this._currentIndex) + " at bitrate ") + this.currentMBRObject.getRateAt(this._currentIndex)) + " since it is taking ") + _local4) + " X longer ") + "than the defined bufferTime to fill the players buffer"));
                    };
                    break;
                case "NetStream.Buffer.Flush":
                    break;
                case "NetStream.Buffer.Empty":
                    if ((((this.bufferLength < this._startingBufferTimeOndemand)) && (((getTimer() - this.timeAtLastBufferFull) > this.MINIMUM_BUFFER_EMPTY_FULL_GAP)))){
                        if ((this.duration - this.time) < this.END_OF_STREAM_TAT_TIME_DELTA){
                            if (this.isLiveStream){
                                this.debug("Starting EOS livestream timer");
                                this.bytesAtBufferEmpty = this.bytesLoaded;
                                this.eosLiveTimer.reset();
                                this.eosLiveTimer.start();
                            } else {
                                this.debug(("Starting VOD EOS timer since duration - time =" + (Math.round(((this._duration - this.time) * 100)) / 100)));
                                this.eosVodTimer.reset();
                                this.eosVodTimer.start();
                            };
                        };
                        if ((getTimer() - this.timeAtLastBufferFull) < this.THRESHOLD_FOR_REPEATED_BUFFER_EMPTY){
                            this.bufferTimeAfterBufferEmpty++;
                            this.bufferTimeAfterBufferEmpty = Math.min(this.bufferTimeAfterBufferEmpty, this.MAX_BUFFERTIME_AFTER_BUFFER_EMPTY);
                            this.debug((("Raising bufferTime since this buffer empty occurred only " + (getTimer() - this.timeAtLastBufferFull)) + " after the last buffer full"));
                        };
                        super.bufferTime = this.bufferTimeAfterBufferEmpty;
                        this.debug(((((("At buffer empty, bufferlength=" + this.bufferLength) + " & bw=") + this.estimatedCurrentBandwidth) + " last so setting buffertime to ") + super.bufferTime));
                        if (((((((!(this.switchUnderway)) && (!(this.isPaused)))) && (!(this.isComplete)))) && (this.isPlayingMBRcontent()))){
                            this.debug("Applying switching rules since a switch is not underway");
                            this.applySwitchingRules();
                        };
                        this._estimatedMaxbandwidth = 0;
                        this.lastBitrateMeasured = 0;
                        this.needBitrateTest = true;
                        this.isBuffering = true;
                        this.hasReachedBufferTarget = false;
                        if (!(this._isComplete)){
                            dispatchEvent(new HDEvent(HDEvent.IS_BUFFERING, true));
                        };
                        if (((this.throttleTimer.running) && (!(this.isPaused)))){
                            this.throttle(this.MAX_THROTTLE);
                        };
                    };
                    this.deadConnectionTimer.reset();
                    this.deadConnectionTimer.start();
                    this.bytesAtlastBufferEmpty = this.bytesLoaded;
                    this.bufferEmptyFlag = true;
                    this.timeAtLastBufferEmpty = getTimer();
                    break;
                case "NetStream.Play.StreamNotFound":
                    this.debug(("Stream not found - " + this.currentURL));
                    if (this.enableAlternateServerMapping){
                        this.makeServerLivenessCheck(true);
                        this.csmaQosEventVo.reason = QoSEventVO.REASON_STARTUP;
                    } else {
                        dispatchEvent(new HDEvent(HDEvent.STREAM_NOT_FOUND, this.currentURL));
                    };
                    break;
                case "NetStream.Play.Stop":
                    this.debug("NetStream.Play.Stop");
                    break;
            };
        }
        private function onAuthenticatorRejection(_arg1:HDEvent):void{
            this.debug("Authenticator failed");
            this.swfAuthUnderway = false;
            dispatchEvent(_arg1);
        }
        private function onAuthenticatorFailure(_arg1:HDEvent):void{
            this.swfAuthUnderway = false;
            dispatchEvent(_arg1);
        }
        private function onRTT(_arg1:HDEvent):void{
            this._estimatedRTT = (_arg1.data as Number);
            dispatchEvent(_arg1);
            this.debug((("RTT estimate: " + this._estimatedRTT) + " ms"));
            this.adjustTargetBufferForRTT();
            this.adjustBandwidthSafetyFactorForRTT();
        }
        private function onTAT(_arg1:HDEvent):void{
        }
        private function onTokenServiceSuccess(_arg1:String):void{
            this.debug(("Received tokenized url: " + _arg1));
            this.currentURL = _arg1.split("&primaryToken")[0];
            this.controller.controlHost = this.currentURL.slice(0, (this.currentURL.indexOf("/", 9) + 1));
            this.debug(("Storing currentURL as: " + this.currentURL));
            this.debug(("setting control host: " + this.controller.controlHost));
            this.assembleAndPlayURL(_arg1, this.pendingSeek);
        }
        private function onTokenServiceFailure(_arg1:String):void{
            this.debug(_arg1);
        }
        private function onComplete():void{
            this._isComplete = true;
            this.stopTimers();
            super.pause();
            this.debug("STREAM HAS ENDED");
            if (this.loop){
                this.debug("Looping");
                dispatchEvent(new HDEvent(HDEvent.LOOP));
                super.bufferTime = this._startingBufferTimeOndemand;
                this.beginPlay(this._source, this.playStart, this.playLength, true);
            } else {
                dispatchEvent(new HDEvent(HDEvent.IS_BUFFERING, false));
                dispatchEvent(new HDEvent(HDEvent.COMPLETE));
            };
        }
        private function stopTimers():void{
            this.bitrateTestTimer.stop();
            this.metricsTimer.stop();
            this.progressTimer.stop();
            this.throttleTimer.stop();
            this.switchTimeoutTimer.stop();
            this.deadConnectionTimer.stop();
            this.eosLiveTimer.stop();
            this.eosVodTimer.stop();
            if ((this.lockTimer is Timer)){
                this.lockTimer.stop();
            };
        }
        private function queryArgFromString(_arg1:String, _arg2:String):String{
            var _local4:Array;
            var _local3:String = _arg1.slice((_arg1.indexOf("?") + 1));
            var _local5:Array = _local3.split("&");
            var _local6:Object = {};
            while (_local5.length) {
                _local4 = _local5.shift().split("=");
                if (_local4[0].toString() == _arg2){
                    return ((_local4[1] as String));
                };
            };
            return ("");
        }
        private function initLockoutArray():void{
            this.lockOutArray = [];
            var _local1:Number = 0;
            while (_local1 < this.currentMBRObject.streamCount) {
                this.lockOutArray.push({
                    count:0,
                    delay:(this.INITIAL_LOCKOUT_PERIOD / 2)
                });
                _local1++;
            };
            this.lockLimit = int.MAX_VALUE;
            if (!((this.lockTimer is Timer))){
                this.lockTimer = new Timer(this.INITIAL_LOCKOUT_PERIOD, 1);
                this.lockTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.removeLock, false, 0, true);
            } else {
                this.lockTimer.delay = (this.INITIAL_LOCKOUT_PERIOD / 2);
            };
        }
        private function incrementFailCountAt(_arg1:Number):void{
            this.lockOutArray[_arg1].count = ((this.lockOutArray[_arg1].count as Number) + 1);
            this.debug(((((("Incremented fail count for index " + _arg1) + " to ") + this.lockOutArray[_arg1].count) + " out of ") + this.LOCKOUT_THRESHOLD));
            if ((this.lockOutArray[_arg1].count as Number) >= this.LOCKOUT_THRESHOLD){
                this.lockLimit = Math.min(this.lockLimit, _arg1);
                this.lockOutArray[_arg1].count = 0;
                this.lockTimer.reset();
                this.lockTimer.start();
                this.debug((((((("Locking out index " + _arg1) + "  for ") + Math.round((this.lockTimer.delay / 1000))) + "s since it has failed ") + this.LOCKOUT_THRESHOLD) + " times."));
            };
        }
        private function isAvailable(_arg1:Number):Boolean{
            return ((_arg1 < this.lockLimit));
        }
        private function removeLock(_arg1:TimerEvent):void{
            this.debug(("Removing locklimit from index " + this.lockLimit));
            this.lockLimit = int.MAX_VALUE;
        }
        private function updateStreamName():void{
            dispatchEvent(new HDEvent(HDEvent.STREAM_NAME_CHANGE, {
                streamName:this.currentStreamName,
                title:((!((this.currentMBRObject == null))) ? this.currentMBRObject.title : "")
            }));
        }
        private function onIOError(_arg1:IOErrorEvent):void{
            this.debug(("IO error" + _arg1));
        }
        private function onAsyncError(_arg1:AsyncErrorEvent):void{
            this.debug(("ASYNC Error" + _arg1));
        }
        private function adjustBandwidthSafetyFactorForRTT():void{
            var _local1:Number;
            if ((((this._estimatedRTT > 0)) && (!((this.currentMBRObject == null))))){
                if (this.isPlayingLive){
                    _local1 = this.BANDWIDTH_SAFETY_FACTOR_LIVE;
                } else {
                    if (this._estimatedRTT <= this.LOW_RTT){
                        _local1 = this.BANDWIDTH_SAFETY_FACTOR_LOW_RTT;
                    } else {
                        if (this._estimatedRTT >= this.HIGH_RTT){
                            _local1 = this.BANDWIDTH_SAFETY_FACTOR_HIGH_RTT;
                        } else {
                            _local1 = (this.BANDWIDTH_SAFETY_FACTOR_HIGH_RTT + (((this.BANDWIDTH_SAFETY_FACTOR_HIGH_RTT - this.BANDWIDTH_SAFETY_FACTOR_LOW_RTT) * (this._estimatedRTT - this.HIGH_RTT)) / (this.HIGH_RTT - this.LOW_RTT)));
                        };
                    };
                };
                if (_local1 != this.bandwidthSafetyFactor){
                    this.bandwidthSafetyFactor = (Math.round((_local1 * 100)) / 100);
                    this.debug((((("Adjusting bandwidth safety factor to " + Math.round(((this.bandwidthSafetyFactor - 1) * 100))) + "% for RTT of ") + this._estimatedRTT) + "ms"));
                };
            };
        }
        private function adjustTargetBufferForRTT():void{
            var _local1:Number;
            if (this.isPlayingLive){
                this._targetBufferTime = Math.max(this.MINIMUM_LIVE_STARTING_BUFFER, (this.delayFromLive - 3));
            } else {
                if (((((this._maximizeSingleBitrateBuffers) && (((this.isPaused) || (((this._droppedFPS / this._nominalFPS) < this.FRAMEDROP_THRESHOLD)))))) && (((((this.isPlayingMBRcontent()) && ((this.currentIndex == (this.currentMBRObject.streamCount - 1))))) || (!(this.isPlayingMBRcontent())))))){
                    this._targetBufferTime = this._maxBufferLength;
                } else {
                    _local1 = this.TARGET_BUFFER_TIME_LOW_LATENCY;
                    if (this._estimatedRTT <= this.LOW_RTT){
                        _local1 = this.TARGET_BUFFER_TIME_LOW_LATENCY;
                    } else {
                        if (this._estimatedRTT >= this.HIGH_RTT){
                            _local1 = this.TARGET_BUFFER_TIME_HIGH_LATENCY;
                        } else {
                            if (this._estimatedRTT > 0){
                                _local1 = (this.TARGET_BUFFER_TIME_HIGH_LATENCY + (((this.TARGET_BUFFER_TIME_HIGH_LATENCY - this.TARGET_BUFFER_TIME_LOW_LATENCY) * (this._estimatedRTT - this.HIGH_RTT)) / (this.HIGH_RTT - this.LOW_RTT)));
                            };
                        };
                    };
                    if (_local1 != this._targetBufferTime){
                        this._targetBufferTime = (Math.round((_local1 * 100)) / 100);
                    };
                };
            };
            if (((((!(this.isLiveStream)) && (!(this.isPaused)))) && ((this.durationTimeDelta < Math.max(30, (((this.bufferLength * 5) / 4) + 10)))))){
                this._targetBufferTime = ((this.bufferLength)>20) ? 10 : Math.abs((this.durationTimeDelta - this.EOS_TARGET_BUFFER_TIME_OFFSET));
            };
        }
        private function onParsed(_arg1:HDEvent):void{
            this.playlistAvailable = (this.smilParser.mbrObjects.length > 1);
            if (this._bandwidthEstimationEnabled){
                this.estimateBandwidth();
            } else {
                this.processMBRObject(this.smilParser.mbrObjects[0]);
            };
        }
        private function onParserFailure(_arg1:HDEvent):void{
            this.debug((("SMIL file parsing failed with error: " + _arg1.data) as String));
            this._isComplete = true;
            this.stopTimers();
        }
        private function processMBRObject(_arg1:IMBRObject):void{
            var _local3:IMBRObject2;
            this.currentMBRObject = _arg1;
            this.currentIndex = this.getStartingIndex(this.currentMBRObject);
            this.currentStreamName = this.currentMBRObject.getNameAt(this.currentIndex);
            var _local2:String = ((this.currentMBRObject.httpBase + (((this.currentMBRObject.httpBase.slice(-1) == "/")) ? "" : "/")) + this.currentStreamName);
            if ((this.currentMBRObject is IMBRObject2)){
                _local3 = (this.currentMBRObject as IMBRObject2);
                if (((!((_local3.primaryToken == ""))) && (!((_local3.primaryToken == null))))){
                    this.primaryToken = _local3.primaryToken;
                };
                if (!(isNaN(_local3.clipBegin))){
                    this.playStart = _local3.clipBegin;
                    this.debug(("Setting sub-clip play start to " + this.playStart));
                    this.pendingSeek = ((this.pendingSeek)==null) ? this.playStart.toString() : this.pendingSeek;
                };
                if (!(isNaN(_local3.clipEnd))){
                    if ((((_local3.clipEnd == -1)) || ((_local3.clipEnd == 0)))){
                        this.playLength = _local3.clipEnd;
                        this.debug(("Setting sub-clip play length to " + this.playLength));
                    } else {
                        this.playLength = ((((!(isNaN(this.playStart))) && ((this.playStart > 0)))) ? (_local3.clipEnd - this.playStart) : _local3.clipEnd);
                        this.debug(("Setting sub-clip play length to " + this.playLength));
                    };
                } else {
                    if (((isNaN(_local3.clipEnd)) && (!(isNaN(_local3.clipBegin))))){
                        this.playLength = -1;
                        this.debug(("Setting sub-clip play length to " + this.playLength));
                    };
                };
                if (this.playLength == 0){
                    this.isPaused = ((((!(isNaN(this.playLength))) && ((this.playLength == 0)))) ? true : false);
                    this.callPauseOnce = this.isPaused;
                };
            };
            this.initLockoutArray();
            this.controller.controlHost = this.currentMBRObject.httpBase;
            this.updateCurrentRendition();
            this.prepareURL(_local2, (((this.pendingSeek == null)) ? null : this.pendingSeek.toString()));
        }
        private function recoverFromTimeOut(_arg1:Number):void{
            dispatchEvent(new HDEvent(HDEvent.TIMEOUT));
            this.debug("IDLE TIMEOUT");
            this.recoveringFromTimeout = true;
            this.accummulatedBytesLoaded = this.bytesLoaded;
            this.accummulatedDroppedFrames = this.droppedFrames;
            if (this.isPlayingMBRcontent()){
                this._startingIndex = this.currentIndex;
            };
            if (this._autoRecoverFromTimeout){
                this.debug("Auto-recovering from timeout");
                this.beginPlay(this._source, ((this._isPlayingLive) ? -1 : _arg1), this.playLength, true);
            };
        }
        private function onSwitchTimeout(_arg1:TimerEvent):void{
            this.switchUnderway = false;
            this.debug((("Switch timed-out after " + this.SWITCH_TIMEOUT) + " ms."));
        }
        private function maxBufferTime():Number{
            if (this.isPlayingLive){
                return ((Math.max(this._targetBufferTime, this.bufferLength) + this.UPPER_BUFFER_RANGE));
            };
            if (this.isPaused){
                return (((this.hasReachedBufferTarget) ? (Math.max(this._targetBufferTime, this.bufferLength) + this.UPPER_BUFFER_RANGE) : 0.5));
            };
            return (Math.min((Math.max(this._targetBufferTime, this.bufferLength) + this.UPPER_BUFFER_RANGE), this.durationTimeDelta));
        }
        private function onCheckBandwidth(_arg1:TimerEvent):void{
            if (this.firstByte > 0){
                this.byteDelta = (this.bytesLoaded - this.firstByte);
                if (!(this.isPaused)){
                    if ((((this.byteDelta == 0)) && ((this.timeAtFirstEmptyByteDelta == 0)))){
                        this.timeAtFirstEmptyByteDelta = getTimer();
                    } else {
                        if ((((this.byteDelta == 0)) && ((this.timeAtFirstEmptyByteDelta > 0)))){
                            this._maxSecondsWithoutData = Math.max(this._maxSecondsWithoutData, (Math.round((1000 * ((getTimer() - this.timeAtFirstEmptyByteDelta) / 1000))) / 1000));
                            if (((((((((this.enableAlternateServerMapping) && (!(this.failingOverToAlternate)))) && (!(this.isComplete)))) && ((this._maxSecondsWithoutData > (this.qosManager.dataGap / 1000))))) && ((this.bufferLength < (this.qosManager.bufferLowMark / 1000))))){
                                this.failingOverToAlternate = true;
                                this.makeServerLivenessCheck();
                                this.csmaQosEventVo.reason = QoSEventVO.REASON_DATA_GAP;
                            };
                        } else {
                            if (this.byteDelta > 0){
                                this.timeAtFirstEmptyByteDelta = 0;
                            };
                        };
                    };
                };
                this.timeDelta = (getTimer() - this.firstByteTime);
                this.estimateBandwidthOverInterval();
                this.estimateDownloadRatioAverage();
            };
            this.firstByte = this.bytesLoaded;
            this.firstByteTime = getTimer();
        }
        private function estimateDownloadRatioAverage():void{
            var _local1:Number;
            var _local2:Number;
            var _local3:Number;
            if (((((!(this.isPlayingMBRcontent())) || ((this.currentIndexBitrate > 0)))) && (!(this.bitrateTestUnderway)))){
                if (!((this.playbackBytesSampleArray is Array))){
                    this.playbackBytesSampleArray = new Array();
                };
                this.playbackBytesSampleArray.unshift((this.info.playbackBytesPerSecond * 8));
                if (this.playbackBytesSampleArray.length > this.PLAYBACK_RATE_SAMPLE_COUNT){
                    this.playbackBytesSampleArray.pop();
                };
                _local1 = 0;
                _local2 = 0;
                while (_local2 < this.playbackBytesSampleArray.length) {
                    _local1 = (_local1 + this.playbackBytesSampleArray[_local2]);
                    _local2++;
                };
                this._averagePlaybackBitsPerSecond = (_local1 / this.playbackBytesSampleArray.length);
                if (!((this.downloadRatioSampleArray is Array))){
                    this.downloadRatioSampleArray = new Array();
                };
                this.downloadRatioSampleArray.unshift(((this.estimatedCurrentBandwidth * 1000) / this._averagePlaybackBitsPerSecond));
                if (this.downloadRatioSampleArray.length > this.DOWNLOAD_RATIO_SAMPLE_COUNT){
                    this.downloadRatioSampleArray.pop();
                };
                _local3 = 0;
                _local2 = 0;
                while (_local2 < this.downloadRatioSampleArray.length) {
                    _local3 = (_local3 + this.downloadRatioSampleArray[_local2]);
                    _local2++;
                };
                this._downloadRatio = ((!(((_local3 / this.downloadRatioSampleArray.length) == Infinity))) ? (_local3 / this.downloadRatioSampleArray.length) : 0);
            };
        }
        private function estimateBandwidthOverInterval():void{
            var _local1:Number = ((this.byteDelta * 8) / this.timeDelta);
            if (!((this.bandwidthSampleArray is Array))){
                this.bandwidthSampleArray = new Array();
            };
            this.bandwidthSampleArray.unshift(_local1);
            if (this.bandwidthSampleArray.length > this.BANDWIDTH_SAMPLE_COUNT){
                this.bandwidthSampleArray.pop();
            };
            var _local2:Number = 0;
            var _local3:Number = 0;
            while (_local3 < this.bandwidthSampleArray.length) {
                _local2 = (_local2 + this.bandwidthSampleArray[_local3]);
                _local3++;
            };
            this._estimatedCurrentBandwidth = Math.round((_local2 / this.bandwidthSampleArray.length));
            if (this.bandwidthSampleArray.length >= this.MIN_SAMPLES_FOR_MAX_BANDWIDTH){
                this._estimatedMaxbandwidth = Math.round(Math.max(this._estimatedMaxbandwidth, this._estimatedCurrentBandwidth));
            };
        }
        private function onCPU(_arg1:HDEvent):void{
            this._cpu = (_arg1.data as Number);
            if (!(this._netSessionClientAvailable)){
                this._netSessionClientAvailable = true;
                dispatchEvent(new HDEvent(HDEvent.NETSESSION_CLIENT, this._netSessionClientAvailable));
                this.debug("NetSession client installed: true");
            };
        }
        private function onNetSessionFailure(_arg1:HDEvent):void{
            this._netSessionClientAvailable = false;
            dispatchEvent(new HDEvent(HDEvent.NETSESSION_CLIENT, this._netSessionClientAvailable));
            this.debug("NetSession client installed: false");
        }
        private function onNetSessionClient(_arg1:HDEvent):void{
            dispatchEvent(_arg1);
        }
        private function onNetSessionEULA(_arg1:HDEvent):void{
            this.debug(("NetSession EULA :" + String(_arg1.data)));
            dispatchEvent(_arg1);
        }
        private function onSwfLoaderComplete(_arg1:Event):void{
            this.swf = ((_arg1.currentTarget as LoaderInfo).content as MovieClip);
            this.swf.session = this.sessionID;
            this.swf.addEventListener("ready", this.onTokenReady, false, 0, true);
            if ((this.displayObject is DisplayObject)){
                this.displayObject.stage.addChild(this.swf);
            } else {
                this.debug("Cannot authenticate this player since the displayObject property has not been defined");
            };
        }
        private function onTokenReady(_arg1:Event):void{
            this.sessionToken = (_arg1.currentTarget.token as String);
            this.debug(("Auth token generated: " + this.sessionToken));
            this.controller.sendSecondaryToken(_arg1.currentTarget.token);
            this.displayObject.stage.removeChild(this.swf);
            this.swfAuthUnderway = false;
        }
        private function timeCode(_arg1:Number):String{
            var _local2:Number;
            var _local3:Number;
            var _local4:Number;
            if (isNaN(_arg1)){
                return ("00:00");
            };
            _local2 = Math.floor((_arg1 / 3600));
            _local3 = Math.floor(((_arg1 % 3600) / 60));
            _local4 = Math.round(((_arg1 % 3600) % 60));
            if (_local4 == 60){
                _local3++;
                _local4 = 0;
            };
            return (((((((((_local2 == 0)) ? "" : (((((_local2 < 10)) ? "0" : "") + _local2.toString()) + ":")) + (((_local3 < 10)) ? "0" : "")) + _local3.toString()) + ":") + (((_local4 < 10)) ? "0" : "")) + _local4.toString()));
        }
        private function updateTimeAndDuration():void{
            if (((((this.trapTime) && ((super.time > 0)))) && ((this.seekTarget == -1)))){
                this.trapTime = false;
                this.timeAtLastOnEdge = super.time;
                this.lastFLVTimeStamp = super.time;
            };
            if (this.trapTime){
                this.timeAtLastOnEdge = this.timeBase;
            };
            if (this._isLiveStream){
                if (((!(((((this.isBuffering) || (this.isPaused))) || (this.isPausedWhileLive)))) || (isNaN(this._duration)))){
                    this._duration = (this.tat + ((getTimer() - this.timerAtLastTat) / 1000));
                };
            } else {
                this._duration = this.tat;
            };
            if (((!(isNaN(this.playLength))) && ((this.playLength > 0)))){
                if ((((this._duration > 0)) && ((this.playLength > this._duration)))){
                    this.debug(((("Adjusting sub-clip play length because it exceeds the duration of the stream. Was " + this.playLength) + ", but duration is ") + this._duration));
                    this.playLength = -1;
                    this.debug(("Setting sub-clip play length to " + this.playLength));
                } else {
                    this._duration = this.playLength;
                };
            };
            if (((((((((!(isNaN(this.playStart))) && ((this.playStart > 0)))) && ((this._duration > this.playStart)))) && (!(isNaN(this.playLength))))) && ((this.playLength == -1)))){
                this._duration = (this._duration - this.playStart);
            };
            if (((!(isNaN(this.playLength))) && ((this.playLength == 0)))){
                this._duration = 0;
            };
            if (this.seekTarget >= 0){
                this._time = this.seekTarget;
            } else {
                if (((!(isNaN(this.playLength))) && ((((this.playLength > 0)) || ((this.playLength == -1)))))){
                    this._time = (this.timeBase + Math.max(0, (super.time - this.timeAtLastOnEdge)));
                } else {
                    this._time = Math.min((this.timeBase + Math.max(0, (super.time - this.timeAtLastOnEdge))), this._duration);
                };
            };
            var _local1:Boolean = (((Math.abs((this._time - this._duration)) < this.PLAYING_LIVE_DELTA)) && (this._isLiveStream));
            if (((!((_local1 == this._isPlayingLive))) && (!((this.time == 0))))){
                this._isPlayingLive = _local1;
                dispatchEvent(new HDEvent(HDEvent.IS_PLAYING_LIVE, this._isPlayingLive));
            };
            if ((((((this.dvrWindow > 0)) && ((this.time < -1)))) && ((this.seekTarget < 0)))){
                this.close();
                this.debug("Stream has reached the end of the dvrWindow. Terminating playback and dispatching DVR_WINDOW_CLOSED event");
                dispatchEvent(new HDEvent(HDEvent.DVR_WINDOW_CLOSED, this._dvrWindow));
                this._isComplete = true;
                this.stopTimers();
            };
            if (((((((((this.disableAllArchivePlayback) && (!(this._isPlayingLive)))) && ((this._streamStartTime > 0)))) && (!(this.trapFirstOnEdge)))) && (!(this.isPaused)))){
                this.close();
                this.debug("All archive playback for live streams has been disabled. Stopping playback and dispathcing ARCHIVE_PLAYBACK_DISABLED event");
                dispatchEvent(new HDEvent(HDEvent.ARCHIVE_PLAYBACK_DISABLED));
                this._isComplete = true;
                this.stopTimers();
            };
        }
        private function onEOSLiveTimeout(_arg1:TimerEvent):void{
            this.eosLiveTimer.stop();
            if (this.bytesLoaded == this.bytesAtBufferEmpty){
                this.debug("Detecting end of live stream since byte count unchanged");
                this.onComplete();
            } else {
                this.debug("Bytes recovered so stream has not ended");
            };
        }
        private function onEOSVodTimeout(_arg1:TimerEvent):void{
            this.eosVodTimer.stop();
            this.onComplete();
        }
        private function onDeadConnection(_arg1:TimerEvent):void{
            this.deadConnectionTimer.stop();
            if ((((this.bytesLoaded <= this.bytesAtlastBufferEmpty)) && (!(this.isPaused)))){
                this.debug("Dispatching DEAD_CONNECTION event");
                dispatchEvent(new HDEvent(HDEvent.DEAD_CONNECTION));
            };
        }
        private function isBeingIgnored(_arg1:Number):Boolean{
            var _local2:Boolean;
            var _local3:Number = 0;
            while (_local3 < this.ignoreList.length) {
                if ((getTimer() - this.ignoreList[_local3].time) > this.IGNORE_PERIOD){
                    this.ignoreList.splice(_local3, 1);
                    this.debug((((("Removing index " + _local3) + " from ignore list since more than ") + this.IGNORE_PERIOD) + "ms have passed"));
                } else {
                    if (this.ignoreList[_local3].index == _arg1){
                        _local2 = true;
                        break;
                    };
                };
                _local3++;
            };
            return (_local2);
        }
        private function onPluginLoad(_arg1:Event):void{
            this.debug(("Analytics plugin loaded : v" + AnalyticsPluginLoader.getPluginVersion()));
        }
        private function cloneExistingSoundTransform(_arg1:Number):SoundTransform{
            var _local2:SoundTransform = new SoundTransform();
            _local2.volume = _arg1;
            _local2.leftToLeft = super.soundTransform.leftToLeft;
            _local2.leftToRight = super.soundTransform.leftToRight;
            _local2.rightToLeft = super.soundTransform.rightToLeft;
            _local2.rightToRight = super.soundTransform.rightToRight;
            _local2.pan = super.soundTransform.pan;
            return (_local2);
        }
        private function beginPlay(... _args):void{
            var _local2:String;
            var _local3:Array;
            super.bufferTime = this._startingBufferTimeOndemand;
            this.stopTimers();
            this._source = _args[0];
            this.debug(("GUID: " + this.guid));
            if ((((((((((_args.length >= 2)) && (!((_args[1] == null))))) && (!(isNaN(Number(_args[1])))))) && (isNaN(this.playStart)))) && (!(_args[3])))){
                this.playStart = Number(_args[1]);
                this.debug(("Setting sub-clip play start to " + this.playStart));
            };
            if ((((((((_args.length >= 3)) && (!((_args[2] == null))))) && (!(isNaN(Number(_args[2])))))) && (isNaN(this.playLength)))){
                this.playLength = Number(_args[2]);
                this.debug(("Setting sub-clip play length to " + this.playLength));
            };
            this.isPaused = ((((!(isNaN(this.playLength))) && ((this.playLength == 0)))) ? true : false);
            this.callPauseOnce = this.isPaused;
            if (this.recoveringFromTimeout){
                this.recoveringFromTimeout = false;
            } else {
                this.accummulatedBytesLoaded = 0;
                this.accummulatedDroppedFrames = 0;
            };
            this._isPausedWhileLive = false;
            this.swfAuthUnderway = false;
            this.requiresSwfAuth = false;
            this.ignoreList = new Array();
            this._dvrWindow = 0;
            this.edgeIP = "";
            this.playerIP = "";
            this.firstByte = 0;
            this.sessionToken = "";
            this.transferToken = "";
            this._streamType = 0;
            this.seekTarget = -1;
            this.onEdgeCount = 0;
            this.timeAtFirstEmptyByteDelta = 0;
            this.bufferTimeAfterBufferEmpty = this.STARTING_BUFFER_AFTER_BUFFER_EMPTY;
            this._maxSecondsWithoutData = 0;
            this.playlistAvailable = false;
            this.failingOverToAlternate = false;
            this.controller.requiresAuth = false;
            this.switchUnderway = false;
            if (this._enableNetSessionDiscovery){
                this.checkForNetSessionClient();
            };
            if (this._analyticsBeacon != ""){
                this.debug(("Media Analytics active against beacon " + this._analyticsBeacon));
            };
            if ((_args[0] is IMBRObject)){
                this.playSource = (_args[0] as IMBRObject);
                this.pendingSeek = (((((_args[1] == undefined)) || (isNaN(_args[1])))) ? null : _args[1].toString());
                this.processMBRObject((_args[0] as IMBRObject));
            } else {
                if ((_args[0] is String)){
                    this.playSource = (_args[0] as String);
                    this.currentMBRObject = null;
                    _local2 = (_args[0] as String);
                    if (_local2.toLowerCase().indexOf(".smil") != -1){
                        if (_local2.indexOf("primaryToken=") != -1){
                            _local3 = _local2.match(/(\&?primaryToken=(.*?))(\&|\z)/);
                            this._primaryToken = _local3[2];
                            _local2 = _local2.replace(_local3[1], "");
                        };
                        this.pendingSeek = (((((_args[1] == undefined)) || (isNaN(_args[1])))) ? null : _args[1].toString());
                        this.smilParser.load(_local2);
                    } else {
                        this.controller.controlHost = _local2.slice(0, (_local2.indexOf("/", 9) + 1));
                        this.currentStreamName = ((!((_local2.indexOf("?") == -1))) ? _local2.slice((_local2.lastIndexOf("/") + 1), _local2.indexOf("?")) : _local2.slice((_local2.lastIndexOf("/") + 1)));
                        dispatchEvent(new HDEvent(HDEvent.RENDITION_CHANGE, {
                            currentIndex:0,
                            maxIndex:1,
                            currentKbps:null,
                            maxKbps:null
                        }));
                        this.prepareURL(_local2, (((_args[1] == undefined)) ? null : _args[1].toString()));
                    };
                } else {
                    throw (new ArgumentError("Play method argument must be a string, or an IMBRObject"));
                };
            };
        }
        private function get durationTimeDelta():Number{
            return ((this._duration - this.time));
        }
        private function makeQosIdentRequest():void{
            var onQosIdentComplete:* = null;
            var onQosIdentError:* = null;
            var onQosIdentTimeout:* = null;
            onQosIdentComplete = function (_arg1:QoSEvent):void{
                removeListeners();
                var _local2:String = ((qosManager.isPlayingFromEUM()) ? "&eum=true" : "");
                var _local3:String = qosManager.getPrimaryHostName();
                pendingPlayURL = (URLUtils.modifyResourceHost(pendingPlayURL, _local3) + _local2);
                controller.controlHost = (((qosManager.primaryHostURL.protocol + "://") + _local3) + "/");
                dispatchQoSStatusChangeEvent();
                callPlay();
            };
            onQosIdentError = function (_arg1:QoSEvent):void{
                removeListeners();
                enableAlternateServerMapping = false;
                enableEndUserMapping = false;
                debug("QoS - Ident failed so continue playing on original host.");
                dispatchQoSStatusChangeEvent();
                callPlay();
            };
            onQosIdentTimeout = function (_arg1:QoSEvent):void{
                removeListeners();
                debug("QoS - Ident timed out so making server liveness check to see if we need to switch to alt server");
                dispatchQoSStatusChangeEvent();
                callPlay();
            };
            var addListeners:* = function ():void{
                qosManager.addEventListener(QoSEvent.IDENT_COMPLETE, onQosIdentComplete);
                qosManager.addEventListener(QoSEvent.IDENT_ERROR, onQosIdentError);
                qosManager.addEventListener(QoSEvent.IDENT_TIMEOUT, onQosIdentTimeout);
            };
            var removeListeners:* = function ():void{
                qosManager.removeEventListener(QoSEvent.IDENT_COMPLETE, onQosIdentComplete);
                qosManager.removeEventListener(QoSEvent.IDENT_ERROR, onQosIdentError);
                qosManager.removeEventListener(QoSEvent.IDENT_TIMEOUT, onQosIdentTimeout);
            };
            var dispatchQoSStatusChangeEvent:* = function ():void{
                csmaQosEventVo.reason = "";
                csmaQosEventVo.asmEnabled = _enableAlternateServerMapping;
                csmaQosEventVo.eumEnabled = _enableEndUserMapping;
                dispatchEvent(new QoSEvent(QoSEvent.STATUS_CHANGED, false, false, csmaQosEventVo));
            };
            addListeners();
            this.qosManager.request(this.pendingPlayURL);
        }
        private function makeServerLivenessCheck(_arg1:Boolean=false):void{
            var onQosLivenessFailure:* = null;
            var onQosLivenessSuccess:* = null;
            var isStreamNotFound:Boolean = _arg1;
            onQosLivenessFailure = function (_arg1:QoSEvent):void{
                removeListeners();
                failOverToAlternateServer(isStreamNotFound);
            };
            onQosLivenessSuccess = function (_arg1:QoSEvent):void{
                removeListeners();
                if (isStreamNotFound){
                    dispatchEvent(new HDEvent(HDEvent.STREAM_NOT_FOUND, currentURL));
                };
                debug("QoS - liveness check was successful so I will not fail over to alternate server");
            };
            var addListeners:* = function ():void{
                qosManager.addEventListener(QoSEvent.LIVENESS_SUCCESS, onQosLivenessSuccess);
                qosManager.addEventListener(QoSEvent.LIVENESS_FAILURE, onQosLivenessFailure);
            };
            var removeListeners:* = function ():void{
                qosManager.removeEventListener(QoSEvent.LIVENESS_SUCCESS, onQosLivenessSuccess);
                qosManager.removeEventListener(QoSEvent.LIVENESS_FAILURE, onQosLivenessFailure);
            };
            addListeners();
            this.qosManager.makeLivenessCheck();
        }
        private function onQoSForceTimerTimeout(_arg1:QoSEvent):void{
            this.qosManager.removeEventListener(QoSEvent.FORCE_TIMEOUT, this.onQoSForceTimerTimeout);
            this.csmaQosEventVo.reason = QoSEventVO.REASON_SERVER_FORCE;
            this.debug("QoS - Force timer has timed out so I am switching to and alternate server");
            this.failOverToAlternateServer();
        }
        private function onFailbackToPrimaryReady(_arg1:QoSEvent):void{
            this.qosManager.removeEventListener(QoSEvent.FAILBACK_TO_PRIMARY, this.onFailbackToPrimaryReady);
            this.csmaQosEventVo.reason = QoSEventVO.REASON_PRIMARY_AVAILABLE;
            this.continueStreamingOnNewServer(_arg1.data.host, _arg1.data.type);
            this.debug("QoS - switching back to primary server from alternate server because it is OK to do so at this point.");
        }
        private function failOverToAlternateServer(_arg1:Boolean=false):void{
            var oldHost:* = null;
            var onAlternateHostDetermined:* = null;
            var isStreamNotFound:Boolean = _arg1;
            oldHost = new URL(this.currentURL).host;
            if (((this.useTransferToken) && (!((this._tokenService is ITokenService))))){
                this.debug("QoS - Cannot failover to alt server map since content is protected and tokenService is not available");
                dispatchEvent(new HDEvent(HDEvent.ERROR, "Cannot failover to alt server map since content is protected and tokenService is not available"));
                if (isStreamNotFound){
                    dispatchEvent(new HDEvent(HDEvent.STREAM_NOT_FOUND, this.currentURL));
                };
            } else {
                if (((this.qosManager.identRequestTimedOut) && ((this.qosManager.primaryHostURL.host.indexOf("0-") == -1)))){
                    if (this.qosManager.playingFromAlternateServer){
                        this.debug("QoS - Already on alternate host so cannot fail over");
                    } else {
                        this.debug(("QoS - Alternate host is not defined and current host is not of the form that allows an alternate map to be synthesized: " + oldHost));
                        dispatchEvent(new HDEvent(HDEvent.ERROR, "Cannot fail to alt server map since alternate host is not defined and cannot be synthesized"));
                    };
                    if (isStreamNotFound){
                        dispatchEvent(new HDEvent(HDEvent.STREAM_NOT_FOUND, this.currentURL));
                    };
                } else {
                    onAlternateHostDetermined = function (_arg1:QoSEvent):void{
                        qosManager.removeEventListener(QoSEvent.ALTERNATE_HOST_DETERMINED, onAlternateHostDetermined);
                        alternateHost = (_arg1.data.host as String);
                        debug(("QoS - alternate host was determined " + alternateHost));
                        if (oldHost != alternateHost){
                            debug(((("QoS - switching to alternate host: " + alternateHost) + " from primary host ") + oldHost));
                            continueStreamingOnNewServer(alternateHost, _arg1.data.type);
                            qosManager.addEventListener(QoSEvent.FAILBACK_TO_PRIMARY, onFailbackToPrimaryReady);
                        } else {
                            debug("QoS - Already on alternate host so cannot fail over");
                            if (isStreamNotFound){
                                dispatchEvent(new HDEvent(HDEvent.STREAM_NOT_FOUND, currentURL));
                            };
                        };
                    };
                    this.qosManager.addEventListener(QoSEvent.ALTERNATE_HOST_DETERMINED, onAlternateHostDetermined);
                    this.qosManager.getAlternateHostName();
                };
            };
        }
        private function continueStreamingOnNewServer(_arg1:String, _arg2:String):void{
            var onControllerLoadSuccess:* = null;
            var newSource:* = null;
            var newHost:* = _arg1;
            var type:* = _arg2;
            onControllerLoadSuccess = function (_arg1:HDEvent):void{
                controller.removeEventListener(HDEvent.SUCCESS, onControllerLoadSuccess);
                csmaQosEventVo.host = newHost;
                csmaQosEventVo.type = type;
                csmaQosEventVo.asmEnabled = _enableAlternateServerMapping;
                csmaQosEventVo.eumEnabled = _enableEndUserMapping;
                csmaQosEventVo.rtt = qosManager.rtt;
                dispatchEvent(new QoSEvent(QoSEvent.SERVER_CHANGED, false, false, csmaQosEventVo));
                debug((((((((((((((((((((("\n" + "csmaQosEventVo.host \t\t= ") + csmaQosEventVo.host) + "\n") + "csmaQosEventVo.type \t\t= ") + csmaQosEventVo.type) + "\n") + "csmaQosEventVo.ip \t\t\t= ") + csmaQosEventVo.ip) + "\n") + "csmaQosEventVo.reason \t\t= ") + csmaQosEventVo.reason) + "\n") + "csmaQosEventVo.reason \t\t= ") + csmaQosEventVo.rtt) + "\n") + "csmaQosEventVo.asmEnabled \t= ") + csmaQosEventVo.asmEnabled) + "\n") + "csmaQosEventVo.eumEnabled  = ") + csmaQosEventVo.eumEnabled));
            };
            var url:* = new URL(URLUtils.modifyResourceHost(this.currentURL, newHost));
            this.controller.addEventListener(HDEvent.SUCCESS, onControllerLoadSuccess);
            this.recoveringFromTimeout = true;
            if (this.isPlayingMBRcontent()){
                this.MBRObject.httpBase = ((url.protocol + "://") + url.host);
                this.startingIndex = this.currentIndex;
                this.beginPlay(this.MBRObject, ((this.isPlayingLive) ? -1 : this._time), this.playLength, true);
            } else {
                newSource = ((((url.protocol + "://") + url.host) + "/") + url.path);
                this.beginPlay(newSource, ((this.isPlayingLive) ? -1 : this._time), this.playLength, true);
            };
        }
        private function getIndexBasedOnBandwidth(_arg1:Number):uint{
            var _local3:uint;
            var _local2:IMBRObject = (((this.currentMBRObject == null)) ? this.smilParser.mbrObjects[0] : this.currentMBRObject);
            var _local4:Number = (_local2.streamCount - 1);
            while (_local4 > 0) {
                if ((((((_arg1 > (_local2.getRateAt(_local4) * this.bandwidthSafetyFactor))) && ((_local2.getRateAt(_local4) <= this._maximumBitrateAllowed)))) && (!(this.isBeingIgnored(_local4))))){
                    _local3 = _local4;
                    break;
                };
                _local4--;
            };
            return (_local3);
        }
        private function estimateBandwidth():void{
            var mbrObject:* = null;
            var bwe:* = null;
            var onBWEComplete:* = null;
            var onError:* = null;
            onBWEComplete = function (_arg1:HDEvent):void{
                debug((("Bandwidth Estimation is " + _arg1.data.value) + " Kbps"));
                startingIndex = getIndexBasedOnBandwidth(_arg1.data.value);
                debug(("Setting starting index to " + startingIndex));
                processMBRObject(mbrObject);
                setupListeners(false);
            };
            onError = function (_arg1:HDEvent):void{
                processMBRObject(mbrObject);
                debug(("Bandwidth Estimation issue " + _arg1.data.value));
                setupListeners(false);
            };
            var setupListeners:* = function (_arg1:Boolean=true):void{
                if (_arg1){
                    bwe.addEventListener(HDEvent.BANDWIDTH_ESTIMATION_COMPLETE, onBWEComplete);
                    bwe.addEventListener(HDEvent.ERROR, onError);
                } else {
                    bwe.removeEventListener(HDEvent.BANDWIDTH_ESTIMATION_COMPLETE, onBWEComplete);
                    bwe.removeEventListener(HDEvent.ERROR, onError);
                };
            };
            mbrObject = this.smilParser.mbrObjects[0];
            var base:* = ((mbrObject.httpBase.slice(-1))=="/") ? mbrObject.httpBase : (mbrObject.httpBase + "/");
            bwe = new BandwidthEstimation((base + mbrObject.getNameAt((mbrObject.streamCount - 1))), this.bandwidthEstimationPeriodInSeconds);
            setupListeners();
        }

    }
}//package com.akamai.hd 
﻿package com.akamai.hd {
    import flash.utils.*;

    public class HDBase64 {

        private static const BASE64_CHARS:String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        public static const version:String = "1.1.0";

        public function HDBase64(){
            throw (new Error("Base64 class is static container only"));
        }
        public static function encode(_arg1:String):String{
            var _local2:ByteArray = new ByteArray();
            _local2.writeUTFBytes(_arg1);
            return (encodeByteArray(_local2));
        }
        public static function encodeByteArray(_arg1:ByteArray):String{
            var _local3:Array;
            var _local5:uint;
            var _local6:uint;
            var _local7:uint;
            var _local2:String = "";
            var _local4:Array = new Array(4);
            _arg1.position = 0;
            while (_arg1.bytesAvailable > 0) {
                _local3 = new Array();
                _local5 = 0;
                while ((((_local5 < 3)) && ((_arg1.bytesAvailable > 0)))) {
                    _local3[_local5] = _arg1.readUnsignedByte();
                    _local5++;
                };
                _local4[0] = ((_local3[0] & 252) >> 2);
                _local4[1] = (((_local3[0] & 3) << 4) | (_local3[1] >> 4));
                _local4[2] = (((_local3[1] & 15) << 2) | (_local3[2] >> 6));
                _local4[3] = (_local3[2] & 63);
                _local6 = _local3.length;
                while (_local6 < 3) {
                    _local4[(_local6 + 1)] = 64;
                    _local6++;
                };
                _local7 = 0;
                while (_local7 < _local4.length) {
                    _local2 = (_local2 + BASE64_CHARS.charAt(_local4[_local7]));
                    _local7++;
                };
            };
            return (_local2);
        }
        public static function decode(_arg1:String):String{
            var _local2:ByteArray = decodeToByteArray(_arg1);
            return (_local2.readUTFBytes(_local2.length));
        }
        public static function decodeToByteArray(_arg1:String):ByteArray{
            var _local6:uint;
            var _local7:uint;
            var _local2:ByteArray = new ByteArray();
            var _local3:Array = new Array(4);
            var _local4:Array = new Array(3);
            var _local5:uint;
            while (_local5 < _arg1.length) {
                _local6 = 0;
                while ((((_local6 < 4)) && (((_local5 + _local6) < _arg1.length)))) {
                    _local3[_local6] = BASE64_CHARS.indexOf(_arg1.charAt((_local5 + _local6)));
                    _local6++;
                };
                _local4[0] = ((_local3[0] << 2) + ((_local3[1] & 48) >> 4));
                _local4[1] = (((_local3[1] & 15) << 4) + ((_local3[2] & 60) >> 2));
                _local4[2] = (((_local3[2] & 3) << 6) + _local3[3]);
                _local7 = 0;
                while (_local7 < _local4.length) {
                    if (_local3[(_local7 + 1)] == 64){
                        break;
                    };
                    _local2.writeByte(_local4[_local7]);
                    _local7++;
                };
                _local5 = (_local5 + 4);
            };
            _local2.position = 0;
            return (_local2);
        }

    }
}//package com.akamai.hd 
﻿package com.akamai.hd {
    import com.akamai.version.*;

    public class HDVersion {

        public static function get version():String{
            return (HDCoreVersion.version);
        }

    }
}//package com.akamai.hd 
﻿package com.akamai.hd {

    public class HDMBRObject implements IMBRObject2 {

        private var _streamCount:int;
        private var _title:String;
        private var _rtmpPlaybackBase:String;
        private var _httpBase:String;
        private var _clipBegin:Number;
        private var _clipEnd:Number;
        private var _primaryToken:String;
        private var streamArray:Array;

        public function HDMBRObject(){
            this.streamArray = new Array();
        }
        public function get streamCount():int{
            return (this._streamCount);
        }
        public function set streamCount(_arg1:int):void{
            this._streamCount = _arg1;
        }
        public function get title():String{
            return (this._title);
        }
        public function set title(_arg1:String):void{
            this._title = _arg1;
        }
        public function get rtmpPlaybackBase():String{
            return (this._rtmpPlaybackBase);
        }
        public function set rtmpPlaybackBase(_arg1:String):void{
            this._rtmpPlaybackBase = _arg1;
        }
        public function get httpBase():String{
            return (this._httpBase);
        }
        public function set httpBase(_arg1:String):void{
            this._httpBase = _arg1;
        }
        public function addStream(_arg1:String, _arg2:Number, _arg3:Number=0, _arg4:Number=0):void{
            if (!(isNaN(_arg2))){
                this.streamArray.push({
                    name:_arg1,
                    rate:_arg2,
                    width:_arg3,
                    height:_arg4
                });
            };
            this.streamArray.sortOn("rate", Array.NUMERIC);
            this.streamCount = this.streamArray.length;
        }
        public function setDimensionsAt(_arg1:Number, _arg2:Number, _arg3:Number):void{
            this.streamArray[_arg1].width = _arg2;
            this.streamArray[_arg1].height = _arg3;
        }
        public function get streams():Array{
            return (this.streamArray);
        }
        public function set streams(_arg1:Array):void{
            this.streamArray = _arg1;
        }
        public function getRateAt(_arg1:Number):Number{
            return ((this.streamArray[_arg1].rate as Number));
        }
        public function getWidthAt(_arg1:Number):Number{
            return ((this.streamArray[_arg1].width as Number));
        }
        public function getHeightAt(_arg1:Number):Number{
            return ((this.streamArray[_arg1].height as Number));
        }
        public function getNameAt(_arg1:Number):String{
            return ((this.streamArray[_arg1].name as String));
        }
        public function get clipBegin():Number{
            return (this._clipBegin);
        }
        public function set clipBegin(_arg1:Number):void{
            this._clipBegin = _arg1;
        }
        public function get clipEnd():Number{
            return (this._clipEnd);
        }
        public function set clipEnd(_arg1:Number):void{
            this._clipEnd = _arg1;
        }
        public function get primaryToken():String{
            return (this._primaryToken);
        }
        public function set primaryToken(_arg1:String):void{
            this._primaryToken = _arg1;
        }

    }
}//package com.akamai.hd 
﻿package com.akamai.qos {
    import org.osmf.logging.*;
    import org.osmf.utils.*;
    import com.akamai.hd.*;
    import org.osmf.media.*;
    import flash.events.*;
    import flash.utils.*;

    public class QoSManager extends EventDispatcher {

        private static const logger:Logger = Log.getLogger("com.akamai.qos.QoSManager");

        protected var primaryHostIdent:IdentModel;
        protected var endUserMappingIdent:IdentModel;
        protected var qosTimer:Timer;
        private var _primaryHostURL:URL;
        private var _playingFromAlternateServer:Boolean;
        private var primaryIdentRequest:IdentRequestService;
        private var _enableEndUserMapping:Boolean;

        public function QoSManager(_arg1:Boolean=true){
            this._enableEndUserMapping = _arg1;
            this.reset();
        }
        public function simulateForceTimerComplete():void{
            this.debug("QoS - Simulating Force Timer Complete");
            this.onForceSwitchTimerComplete(null);
        }
        public function simulateFailbackToPrimaryTimerComplete():void{
            this.onFailbackToPrimaryTimerComplete(null);
        }
        public function reset():void{
            this.primaryIdentRequest = null;
            this._primaryHostURL = null;
            this._playingFromAlternateServer = false;
            this.primaryHostIdent = null;
            this.killQoSTimer();
        }
        public function destroy():void{
            this.reset();
        }
        public function get enableEndUserMapping():Boolean{
            return (this._enableEndUserMapping);
        }
        public function set enableEndUserMapping(_arg1:Boolean):void{
            this._enableEndUserMapping = _arg1;
        }
        public function get playingFromAlternateServer():Boolean{
            return (this._playingFromAlternateServer);
        }
        public function get bufferLowMark():Number{
            return (((!((this.primaryHostIdent == null))) ? this.primaryHostIdent.bufferLowMark : NaN));
        }
        public function get dataGap():Number{
            return (((!((this.primaryHostIdent == null))) ? this.primaryHostIdent.dataGap : NaN));
        }
        public function get serverIP():String{
            return (((!((this.primaryHostIdent == null))) ? this.primaryHostIdent.serverIP : null));
        }
        public function get clientIP():String{
            return (((!((this.primaryHostIdent == null))) ? this.primaryHostIdent.clientIP : null));
        }
        public function get rtt():Number{
            return (((((((!((this.endUserMappingIdent == null))) && (!(isNaN(this.primaryHostIdent.rtt))))) && ((this.endUserMappingIdent.rtt <= this.primaryHostIdent.rtt)))) ? this.endUserMappingIdent.rtt : this.primaryHostIdent.rtt));
        }
        public function get identRequestInterval():Number{
            return (((!((this.primaryHostIdent == null))) ? this.primaryHostIdent.identRequestInterval : NaN));
        }
        public function get forceSwitch():Boolean{
            return (((!((this.primaryHostIdent == null))) ? this.primaryHostIdent.forceSwitch : false));
        }
        public function isPlayingFromEUM():Boolean{
            return (((((!((this.endUserMappingIdent == null))) && (!(isNaN(this.primaryHostIdent.rtt))))) && ((this.endUserMappingIdent.rtt <= this.primaryHostIdent.rtt))));
        }
        public function get primaryHostURL():URL{
            return (this._primaryHostURL);
        }
        public function request(_arg1:Object):void{
            var _local2:String;
            var _local3:URL;
            if (this._primaryHostURL == null){
                if ((_arg1 is String)){
                    _local2 = (_arg1 as String);
                } else {
                    if ((_arg1 is IMBRObject)){
                        _local2 = IMBRObject(_arg1).httpBase;
                    } else {
                        if ((_arg1 is URLResource)){
                            _local3 = new URL(URLResource(_arg1).url);
                            _local2 = ((_local3.protocol + "://") + _local3.host);
                        };
                    };
                };
                this._primaryHostURL = new URL(_local2);
            };
            this.makeIdentRequest();
        }
        public function getPrimaryHostName():String{
            this._playingFromAlternateServer = false;
            var _local1:String = (((((this.endUserMappingIdent == null)) || ((this.endUserMappingIdent.rtt > this.primaryHostIdent.rtt)))) ? "Primary Mapping not End User Mapping" : "End User Mapping not Primary Mapping");
            this.debug(("QoS - Return host from " + _local1));
            return ((((((this.endUserMappingIdent == null)) || ((this.endUserMappingIdent.rtt > this.primaryHostIdent.rtt)))) ? this.primaryHostIdent.hexifiedHostname : this.endUserMappingIdent.hexifiedHostname));
        }
        public function makeLivenessCheck():void{
            var service:* = null;
            var onLivenessSuccess:* = null;
            var onLivenessFailure:* = null;
            var addListeners:* = function ():void{
                service.addEventListener(QoSEvent.LIVENESS_SUCCESS, onLivenessSuccess);
                service.addEventListener(QoSEvent.LIVENESS_FAILURE, onLivenessFailure);
            };
            var removeListeners:* = function ():void{
                service.removeEventListener(QoSEvent.LIVENESS_SUCCESS, onLivenessSuccess);
                service.removeEventListener(QoSEvent.LIVENESS_FAILURE, onLivenessFailure);
            };
            onLivenessSuccess = function (_arg1:QoSEvent):void{
                removeListeners();
                dispatchEvent(new QoSEvent(QoSEvent.LIVENESS_SUCCESS));
            };
            onLivenessFailure = function (_arg1:QoSEvent):void{
                removeListeners();
                dispatchEvent(new QoSEvent(QoSEvent.LIVENESS_FAILURE));
            };
            service = new LivenessCheckService();
            var host:* = ((!((this.primaryHostIdent.hexifiedHostname == null))) ? this.primaryHostIdent.hexifiedHostname : this._primaryHostURL.host);
            addListeners();
            service.livenessCheck(((this._primaryHostURL.protocol + "://") + host), this.primaryHostIdent.livenessCheckTimeout);
        }
        public function getAlternateHostName():void{
            var _local1:QoSEventVO;
            if (((!((this.primaryHostIdent.alternateInRegionHost == null))) && (!((this.primaryHostIdent.alternateOutOfRegionHost == null))))){
                this.debug("QoS - Determining alternate host since alternate in-region tag is defined.");
                this.determineAlternateHost();
            } else {
                this.debug("QoS - Returning alternate out-of-region host since alternate in-region tag is not defined.");
                this.setFailbackToPrimaryTimeout();
                _local1 = new QoSEventVO();
                _local1.host = this.primaryHostIdent.getAlternateOutOfRegionHost(this._primaryHostURL.host);
                _local1.type = QoSEventVO.AO_HOST_TYPE;
                dispatchEvent(new QoSEvent(QoSEvent.ALTERNATE_HOST_DETERMINED, false, false, _local1));
            };
        }
        protected function createPrimaryIdentModel(_arg1:XML):IdentModel{
            return (new IdentModel(_arg1));
        }
        protected function forceSwitchDetected():void{
            if (this.qosTimer == null){
                this.startQoSTimer(this.primaryHostIdent.forceSwitchTimeout, this.onForceSwitchTimerComplete);
                this.debug((("QoS - Starting the timer for force tag detection " + Math.round(((this.qosTimer.delay / 1000) / 60))) + " minutes"));
            };
        }
        protected function killQoSTimer():void{
            if (this.qosTimer != null){
                this.debug("QoS - Stopping the QosTimer");
                this.qosTimer.removeEventListener(TimerEvent.TIMER, this.onForceSwitchTimerComplete);
                this.qosTimer.removeEventListener(TimerEvent.TIMER, this.onFailbackToPrimaryTimerComplete);
                this.qosTimer.reset();
                this.qosTimer = null;
            };
        }
        private function startQoSTimer(_arg1:Number, _arg2:Function):void{
            this.qosTimer = new Timer(_arg1, 1);
            this.qosTimer.addEventListener(TimerEvent.TIMER, _arg2);
            this.qosTimer.start();
        }
        private function onForceSwitchTimerComplete(_arg1:TimerEvent):void{
            this.killQoSTimer();
            dispatchEvent(new QoSEvent(QoSEvent.FORCE_TIMEOUT));
        }
        private function setFailbackToPrimaryTimeout():void{
            this._playingFromAlternateServer = true;
            this.startQoSTimer(this.primaryHostIdent.primaryFailbackTimeout, this.onFailbackToPrimaryTimerComplete);
            this.debug((("QoS - Starting the timer for switching back to primary host at the rate of " + Math.round(((this.qosTimer.delay / 1000) / 60))) + " minutes"));
        }
        private function onFailbackToPrimaryTimerComplete(_arg1:TimerEvent):void{
            this.killQoSTimer();
            this.makeIdentRequest();
        }
        private function makeIdentRequest(_arg1:Boolean=false):void{
            var onIdentComplete:* = null;
            var onIdentFailure:* = null;
            var endUserMappingRequest:Boolean = _arg1;
            onIdentComplete = function (_arg1:QoSEvent):void{
                var _local2:Boolean;
                var _local3:String;
                removeRequestListeners();
                if (((!(endUserMappingRequest)) && (!(_playingFromAlternateServer)))){
                    if (primaryHostIdent != null){
                        _local3 = primaryHostIdent.EUMHostname;
                        primaryHostIdent = null;
                    };
                    primaryHostIdent = createPrimaryIdentModel(_arg1.data.xml);
                    _local2 = (((_local3 == primaryHostIdent.EUMHostname)) || (!(_enableEndUserMapping)));
                    debug(("QoS - bypassing end user mapping request since the eum hostname has not changed or is not present: " + _local2));
                } else {
                    if (endUserMappingRequest){
                        if (endUserMappingIdent != null){
                            endUserMappingIdent = null;
                        };
                        endUserMappingIdent = new IdentModel(_arg1.data.xml);
                    };
                };
                if (!(_playingFromAlternateServer)){
                    if (primaryHostIdent.forceSwitch){
                        forceSwitchDetected();
                    } else {
                        killQoSTimer();
                    };
                };
                if (((((_local2) || (endUserMappingRequest))) || ((primaryHostIdent.EUMHostname == null)))){
                    if ((((((((primaryHostIdent.EUMHostname == null)) || (!(_enableEndUserMapping)))) && (!((endUserMappingIdent == null))))) && (!(endUserMappingRequest)))){
                        endUserMappingIdent = null;
                    };
                    if (_playingFromAlternateServer){
                        failbackToPrimary();
                    } else {
                        dispatchEvent(new QoSEvent(QoSEvent.IDENT_COMPLETE));
                    };
                } else {
                    makeIdentRequest(true);
                };
            };
            onIdentFailure = function (_arg1:QoSEvent):void{
                removeRequestListeners();
                if (primaryHostIdent == null){
                    primaryHostIdent = createPrimaryIdentModel(null);
                };
                if (!(_playingFromAlternateServer)){
                    if (((((endUserMappingRequest) && (!((primaryHostIdent == null))))) && (!((primaryHostIdent.hexifiedHostname == null))))){
                        dispatchEvent(new QoSEvent(QoSEvent.IDENT_COMPLETE));
                    } else {
                        dispatchEvent(new QoSEvent(_arg1.type));
                    };
                } else {
                    setFailbackToPrimaryTimeout();
                };
            };
            var addRequestListeners:* = function ():void{
                primaryIdentRequest.addEventListener(QoSEvent.IDENT_COMPLETE, onIdentComplete);
                primaryIdentRequest.addEventListener(QoSEvent.IDENT_TIMEOUT, onIdentFailure);
                primaryIdentRequest.addEventListener(QoSEvent.IDENT_ERROR, onIdentFailure);
            };
            var removeRequestListeners:* = function ():void{
                primaryIdentRequest.removeEventListener(QoSEvent.IDENT_COMPLETE, onIdentComplete);
                primaryIdentRequest.removeEventListener(QoSEvent.IDENT_TIMEOUT, onIdentFailure);
                primaryIdentRequest.removeEventListener(QoSEvent.IDENT_ERROR, onIdentFailure);
            };
            this.primaryIdentRequest = ((this.primaryIdentRequest)==null) ? new IdentRequestService() : this.primaryIdentRequest;
            addRequestListeners();
            this.primaryIdentRequest.queryString = this.getIdentRequestQueryString(endUserMappingRequest);
            var hostname:* = ((endUserMappingRequest) ? this.primaryHostIdent.EUMHostname : this._primaryHostURL.host);
            this.primaryIdentRequest.request(((this._primaryHostURL.protocol + "://") + hostname));
        }
        private function determineAlternateHost():void{
            var errorCount:* = 0;
            var hexifiedAlternateInRegionHost:* = null;
            var alternateInRegionIdentRequest:* = null;
            var alternateOutOfRegionIdentRequest:* = null;
            var onAlternateIdentComplete:* = null;
            var onAlternateIdentError:* = null;
            var addListeners:* = function ():void{
                alternateInRegionIdentRequest.addEventListener(QoSEvent.IDENT_COMPLETE, onAlternateIdentComplete);
                alternateOutOfRegionIdentRequest.addEventListener(QoSEvent.IDENT_COMPLETE, onAlternateIdentComplete);
                alternateInRegionIdentRequest.addEventListener(QoSEvent.IDENT_ERROR, onAlternateIdentError);
                alternateOutOfRegionIdentRequest.addEventListener(QoSEvent.IDENT_ERROR, onAlternateIdentError);
            };
            var removeListeners:* = function ():void{
                alternateInRegionIdentRequest.removeEventListener(QoSEvent.IDENT_COMPLETE, onAlternateIdentComplete);
                alternateOutOfRegionIdentRequest.removeEventListener(QoSEvent.IDENT_COMPLETE, onAlternateIdentComplete);
                alternateInRegionIdentRequest.removeEventListener(QoSEvent.IDENT_ERROR, onAlternateIdentError);
                alternateOutOfRegionIdentRequest.removeEventListener(QoSEvent.IDENT_ERROR, onAlternateIdentError);
            };
            onAlternateIdentComplete = function (_arg1:QoSEvent):void{
                removeListeners();
                var _local2:QoSEventVO = new QoSEventVO();
                if (_arg1.currentTarget === alternateInRegionIdentRequest){
                    _local2.host = hexifiedAlternateInRegionHost;
                    _local2.type = QoSEventVO.AI_HOST_TYPE;
                } else {
                    _local2.host = primaryHostIdent.alternateOutOfRegionHost;
                    _local2.type = QoSEventVO.AO_HOST_TYPE;
                };
                setFailbackToPrimaryTimeout();
                dispatchEvent(new QoSEvent(QoSEvent.ALTERNATE_HOST_DETERMINED, false, false, _local2));
                debug(("QoS - Returning alternate host from parallel ident request test - " + _local2.host));
            };
            onAlternateIdentError = function (_arg1:QoSEvent):void{
                var _local2:QoSEventVO;
                errorCount++;
                if (errorCount == 2){
                    removeListeners();
                    _local2 = new QoSEventVO();
                    _local2.host = "";
                    dispatchEvent(new QoSEvent(QoSEvent.ALTERNATE_HOST_DETERMINED, false, false, _local2));
                };
            };
            errorCount = 0;
            var urlPrefix:* = (this._primaryHostURL.protocol + "://");
            hexifiedAlternateInRegionHost = this.primaryHostIdent.getAlternateInRegionHost(this._primaryHostURL.host);
            alternateInRegionIdentRequest = new IdentRequestService();
            alternateOutOfRegionIdentRequest = new IdentRequestService();
            addListeners();
            alternateInRegionIdentRequest.request((urlPrefix + hexifiedAlternateInRegionHost));
            alternateOutOfRegionIdentRequest.request((urlPrefix + this.primaryHostIdent.alternateOutOfRegionHost));
        }
        private function failbackToPrimary():void{
            var _local1:QoSEventVO = new QoSEventVO();
            _local1.host = this.getPrimaryHostName();
            _local1.type = QoSEventVO.PRIMARY_HOST_TYPE;
            dispatchEvent(new QoSEvent(QoSEvent.FAILBACK_TO_PRIMARY, false, false, _local1));
            this._playingFromAlternateServer = false;
        }
        private function getIdentRequestQueryString(_arg1:Boolean):String{
            var _local2:String;
            if (((!(_arg1)) && (((((!((this._primaryHostURL.query.match("force=1") == null))) || (!((this._primaryHostURL.query.match("ai=1") == null))))) || (!((this._primaryHostURL.query.match("eum=1") == null))))))){
                _local2 = ((((("&eum=" + this._primaryHostURL.getParamValue("eum")) + "&ai=") + this._primaryHostURL.getParamValue("ai")) + "&force=") + this._primaryHostURL.getParamValue("force"));
            } else {
                if (_arg1){
                    _local2 = ("rtt1=" + this.primaryHostIdent.rtt);
                };
            };
            return (_local2);
        }
        private function debug(_arg1:String):void{
            if (logger != null){
                logger.debug(_arg1);
            };
        }

    }
}//package com.akamai.qos 
﻿package com.akamai.qos {
    import org.osmf.logging.*;
    import com.akamai.qos.*;

    class IdentModel {

        private static const logger:Logger = Log.getLogger("com.akamai.qos.IdentModel");
        private static const BUFFER_LOW_MARK_DEFAULT:Number = 5000;
        private static const DATA_GAP_DEFAULT:Number = 5000;
        private static const LIVENESS_CHECK_TIMEOUT_DEFAULT:Number = 2000;
        private static const PERIODICAL_IDENT_REQUEST_INTERVAL_DEFAULT:Number = 15000;
        private static const FAILBACK_TIME_TO_PRIMARY_MIN_DEFAULT:Number = 600000;
        private static const FAILBACK_TIME_TO_PRIMARY_MAX_DEFAULT:Number = 1200000;

        private var _ident:XML;
        private var _forceTimeoutMin:Number;
        private var _forceTimeoutMax:Number;
        private var _forceSwitch:Boolean = false;
        private var _bufferLowMark:Number;
        private var _dataGap:Number;
        private var _livenessCheckTimeout:Number;
        private var _identRequestInterval:Number;
        private var _failbackTimeToPrimaryMin:Number;
        private var _failbackTimeToPrimaryMax:Number;

        public function IdentModel(_arg1:XML){
            this._ident = _arg1;
            if (_arg1 != null){
                this.parse();
            };
        }
        public function get serverIP():String{
            var _local1:String = ((this._ident)!=null) ? this._ident.s.toString() : "";
            return ((((_local1.length > 0)) ? _local1 : null));
        }
        public function get clientIP():String{
            var _local1:String = ((this._ident)!=null) ? this._ident.c.toString() : "";
            return ((((_local1.length > 0)) ? _local1 : null));
        }
        public function get hexifiedHostname():String{
            var _local1:String = ((this._ident)!=null) ? this._ident.sh.toString() : "";
            return ((((_local1.length > 0)) ? _local1 : null));
        }
        public function get alternateInRegionHost():String{
            var _local1:String = ((this._ident)!=null) ? this._ident.ai.toString() : "";
            return ((((_local1.length > 0)) ? _local1 : null));
        }
        public function get alternateOutOfRegionHost():String{
            var _local1:String = ((this._ident)!=null) ? this._ident.ao.toString() : "";
            return ((((_local1.length > 0)) ? _local1 : null));
        }
        public function get EUMHostname():String{
            var _local1:String = ((this._ident)!=null) ? this._ident.e.toString() : "";
            return ((((_local1.length > 0)) ? _local1 : null));
        }
        public function get forceSwitch():Boolean{
            return (this._forceSwitch);
        }
        public function get forceSwitchTimeout():Number{
            return (this.randomNumber(this._forceTimeoutMin, this._forceTimeoutMax));
        }
        public function get bufferLowMark():Number{
            var _local1:Number = ((isNaN(this._bufferLowMark)) ? BUFFER_LOW_MARK_DEFAULT : this._bufferLowMark);
            return (_local1);
        }
        public function get dataGap():Number{
            var _local1:Number = ((isNaN(this._dataGap)) ? DATA_GAP_DEFAULT : this._dataGap);
            return (_local1);
        }
        public function get livenessCheckTimeout():Number{
            var _local1:Number = ((isNaN(this._livenessCheckTimeout)) ? LIVENESS_CHECK_TIMEOUT_DEFAULT : this._livenessCheckTimeout);
            return (_local1);
        }
        public function get identRequestInterval():Number{
            var _local1:Number = ((isNaN(this._identRequestInterval)) ? PERIODICAL_IDENT_REQUEST_INTERVAL_DEFAULT : this._identRequestInterval);
            return (_local1);
        }
        public function get primaryFailbackTimeout():Number{
            var _local1:Number = ((isNaN(this._failbackTimeToPrimaryMin)) ? FAILBACK_TIME_TO_PRIMARY_MIN_DEFAULT : this._failbackTimeToPrimaryMin);
            var _local2:Number = ((isNaN(this._failbackTimeToPrimaryMax)) ? FAILBACK_TIME_TO_PRIMARY_MAX_DEFAULT : this._failbackTimeToPrimaryMax);
            return (this.randomNumber(_local1, _local2));
        }
        public function get rtt():Number{
            return (((this._ident)!=null) ? this._ident.r : NaN);
        }
        public function getAlternateInRegionHost(_arg1:String):String{
            var _local2:String;
            var _local3:Array;
            var _local4:String;
            if (this.alternateInRegionHost != null){
                _local3 = this.createAlternateInRegionHostArray();
                _local4 = _local3[this.randomNumber(1, (_local3.length - 1))];
                _local2 = ((((_local3[0] + "-") + _local4) + "-") + _arg1);
            };
            return (_local2);
        }
        public function getAlternateOutOfRegionHost(_arg1:String):String{
            var _local2:String = ((this._ident)!=null) ? this.alternateOutOfRegionHost : null;
            if (_local2 == null){
                _local2 = _arg1.replace(/0-/, "1-");
            };
            return (_local2);
        }
        protected function createAlternateInRegionHostArray():Array{
            return (this._ident.ai.toString().split(/[;]+/));
        }
        protected function randomNumber(_arg1:Number, _arg2:Number):Number{
            return ((_arg1 + Math.round((Math.random() * (_arg2 - _arg1)))));
        }
        protected function get ident():XML{
            return (this._ident);
        }
        protected function get forceTimeoutMin():Number{
            return (this._forceTimeoutMin);
        }
        protected function get forceTimeoutMax():Number{
            return (this._forceTimeoutMax);
        }
        private function parse():void{
            var _local1:RegExp = /[;|\-]+/;
            var _local2:Array = this._ident.f.toString().split(_local1);
            if (_local2 != null){
                this._forceSwitch = (((_local2[0] == "1")) ? true : false);
                this._forceTimeoutMin = _local2[1];
                this._forceTimeoutMax = _local2[2];
            };
            _local2 = this._ident.t.toString().split(_local1);
            if (_local2 != null){
                this._bufferLowMark = _local2[0];
                this._dataGap = _local2[1];
                this._livenessCheckTimeout = _local2[2];
                this._identRequestInterval = _local2[3];
                this._failbackTimeToPrimaryMin = _local2[4];
                this._failbackTimeToPrimaryMax = _local2[5];
            };
        }
        private function debug(_arg1:String):void{
            if (logger != null){
                logger.debug(_arg1);
            };
        }

    }
}//package com.akamai.qos 
﻿package com.akamai.qos {
    import org.osmf.logging.*;
    import flash.events.*;
    import flash.net.*;
    import com.akamai.qos.*;
    import flash.utils.*;
    import com.akamai.utils.*;

    class LivenessCheckService extends EventDispatcher {

        private static const LIVENESS_COMMAND:String = "/qcheck.xml";
        private static const logger:Logger = Log.getLogger("com.akamai.qos.LivenessCheckService");

        public function livenessCheck(_arg1:String, _arg2:Number):void{
            var livenessTimer:* = null;
            var loader:* = null;
            var onLivenessCheckComplete:* = null;
            var onLivenessCheckError:* = null;
            var url:* = _arg1;
            var timeout:* = _arg2;
            var setupListeners:* = function (_arg1:Boolean=true):void{
                if (_arg1){
                    loader.addEventListener(Event.COMPLETE, onLivenessCheckComplete);
                    loader.addEventListener(IOErrorEvent.IO_ERROR, onLivenessCheckError);
                    loader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onLivenessCheckError);
                    livenessTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onLivenessCheckError);
                } else {
                    loader.close();
                    loader.removeEventListener(Event.COMPLETE, onLivenessCheckComplete);
                    loader.removeEventListener(IOErrorEvent.IO_ERROR, onLivenessCheckError);
                    loader.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, onLivenessCheckError);
                    livenessTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, onLivenessCheckError);
                    livenessTimer.stop();
                    livenessTimer = null;
                    loader = null;
                };
            };
            onLivenessCheckComplete = function (_arg1:Event):void{
                var xml:* = null;
                var event:* = _arg1;
                setupListeners(false);
                try {
                    xml = XML((event.currentTarget as URLLoader).data.toString());
                    debug("QoS - liveness check successful, xml parsing successful");
                } catch(e:Error) {
                    debug(((("QoS - liveness check xml parsing error: " + e.errorID) + " ") + e.message));
                    dispatchEvent(new QoSEvent(QoSEvent.LIVENESS_FAILURE));
                };
                dispatchEvent(new QoSEvent(QoSEvent.LIVENESS_SUCCESS));
            };
            onLivenessCheckError = function (_arg1:Event):void{
                setupListeners(false);
                debug(("QoS - liveness check error: " + _arg1.toString()));
                dispatchEvent(new QoSEvent(QoSEvent.LIVENESS_FAILURE));
            };
            livenessTimer = new Timer(timeout, 1);
            this.debug(("QoS - liveness time out interval=" + timeout));
            url = (((url + "/") + URLUtils.getCacheBustString(5)) + LIVENESS_COMMAND);
            loader = new URLLoader();
            setupListeners();
            this.debug(("QoS - making liveness check on " + url));
            loader.load(new URLRequest(url));
            livenessTimer.start();
        }
        private function debug(_arg1:String):void{
            if (logger != null){
                logger.debug(_arg1);
            };
        }

    }
}//package com.akamai.qos 
﻿package com.akamai.qos {
    import com.akamai.version.*;
    import org.osmf.logging.*;
    import com.akamai.qos.*;
    import flash.net.*;
    import flash.events.*;
    import flash.utils.*;
    import com.akamai.utils.*;

    class IdentRequestService extends EventDispatcher {

        private static const IDENT_PATH:String = ("/ident.xml?qv=" + HDCoreVersion.version);
        private static const logger:Logger = Log.getLogger("com.akamai.qos.IdentRequestService");
        private static const REQUEST_TIMEOUT:uint = 1000;

        private var _queryString:String = "";

        public function request(_arg1:String):void{
            var identTimer:* = null;
            var loader:* = null;
            var onIdentLoadComplete:* = null;
            var onIdentTimeout:* = null;
            var onIdentLoadError:* = null;
            var url:* = _arg1;
            onIdentLoadComplete = function (_arg1:Event):void{
                var vo:* = null;
                var event:* = _arg1;
                removeListeners();
                try {
                    vo = new QoSEventVO();
                    vo.xml = XML((event.currentTarget as URLLoader).data.toString());
                    debug("QoS - ident request successful, xml parsing successful");
                } catch(e:Error) {
                    debug(((("QoS - ident xml parsing error: " + e.errorID) + " ") + e.message));
                    dispatchEvent(new QoSEvent(QoSEvent.IDENT_ERROR));
                };
                dispatchEvent(new QoSEvent(QoSEvent.IDENT_COMPLETE, false, false, vo));
            };
            onIdentTimeout = function (_arg1:TimerEvent):void{
                removeListeners();
                debug(("QoS - ident timed out: " + _arg1.toString()));
                dispatchEvent(new QoSEvent(QoSEvent.IDENT_TIMEOUT));
            };
            onIdentLoadError = function (_arg1:Event):void{
                removeListeners();
                debug(("QoS - ident load error: " + _arg1.toString()));
                dispatchEvent(new QoSEvent(QoSEvent.IDENT_ERROR));
            };
            var addListeners:* = function ():void{
                loader.addEventListener(Event.COMPLETE, onIdentLoadComplete);
                loader.addEventListener(IOErrorEvent.IO_ERROR, onIdentLoadError);
                loader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onIdentLoadError);
                identTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onIdentTimeout);
            };
            var removeListeners:* = function ():void{
                loader.close();
                loader.removeEventListener(Event.COMPLETE, onIdentLoadComplete);
                loader.removeEventListener(IOErrorEvent.IO_ERROR, onIdentLoadError);
                loader.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, onIdentLoadError);
                identTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, onIdentTimeout);
                identTimer.stop();
                identTimer = null;
                loader = null;
            };
            identTimer = new Timer(REQUEST_TIMEOUT, 1);
            url = ((((url + "/") + URLUtils.getCacheBustString(5)) + IDENT_PATH) + this._queryString);
            loader = new URLLoader();
            addListeners();
            this.debug(("QoS - requesting ident from " + url));
            loader.load(new URLRequest(url));
            identTimer.start();
        }
        private function debug(_arg1:String):void{
            if (logger != null){
                logger.debug(_arg1);
            };
        }
        function set queryString(_arg1:String):void{
            this._queryString = ("&" + _arg1);
        }

    }
}//package com.akamai.qos 
﻿package com.akamai.qos {
    import org.osmf.logging.*;

    public class HDN1QoSManager extends QoSManager {

        private static const logger:Logger = Log.getLogger("com.akamai.qos.HDN1QoSManager");

        private var _identRequestTimedOut:Boolean;

        public function HDN1QoSManager(_arg1:Boolean){
            super(_arg1);
        }
        public function set onEdgeForceTag(_arg1:String):void{
            var _local2:RegExp;
            var _local3:Array;
            if ((((qosTimer == null)) || (!(qosTimer.running)))){
                _local2 = /[;|\-]+/;
                _local3 = _arg1.toString().split(_local2);
                if (_local3 != null){
                    HDN1IdentModel(primaryHostIdent).onEdgeForceTimeoutMin = _local3[1];
                    HDN1IdentModel(primaryHostIdent).onEdgeForceTimeoutMax = _local3[2];
                    forceSwitchDetected();
                };
                this.debug(((((("QoS - force value being set from onEdge event = " + _local3[0]) + " - TF1 = ") + _local3[1]) + " - TF2 = ") + _local3[2]));
            };
        }
        public function set onEdgeAlternateInRegionTag(_arg1:String):void{
            HDN1IdentModel(primaryHostIdent).onEdgeAIArray = _arg1.toString().split(/[;]+/);
        }
        public function get identRequestTimedOut():Boolean{
            return (this._identRequestTimedOut);
        }
        override protected function createPrimaryIdentModel(_arg1:XML):IdentModel{
            this._identRequestTimedOut = (_arg1 == null);
            return (new HDN1IdentModel(_arg1));
        }
        private function debug(_arg1:String):void{
            if (logger != null){
                logger.debug(_arg1);
            };
        }

    }
}//package com.akamai.qos 
﻿package com.akamai.qos {

    public class QoSEventVO {

        public static const PRIMARY_HOST_TYPE:String = "primary";
        public static const EUM_HOST_TYPE:String = "eum";
        public static const AI_HOST_TYPE:String = "ai";
        public static const AO_HOST_TYPE:String = "ao";
        public static const REASON_STARTUP:String = "startup";
        public static const REASON_DATA_GAP:String = "dataGap";
        public static const REASON_SERVER_FORCE:String = "serverForce";
        public static const REASON_PRIMARY_AVAILABLE:String = "primaryAvailable";
        public static const REASON_LOW_RTT:String = "lowRTT";

        public var xml:XML;
        public var ip:String;
        public var host:String;
        public var type:String;
        public var reason:String;
        public var asmEnabled:Boolean;
        public var eumEnabled:Boolean;
        public var rtt:Number;

    }
}//package com.akamai.qos 
﻿package com.akamai.qos {
    import flash.events.*;

    public class QoSEvent extends Event {

        public static const IDENT_COMPLETE:String = "identComplete";
        public static const IDENT_TIMEOUT:String = "identTimeout";
        public static const IDENT_ERROR:String = "identError";
        public static const LIVENESS_SUCCESS:String = "livenessSuccess";
        public static const LIVENESS_FAILURE:String = "livenessFailure";
        public static const FORCE_TIMEOUT:String = "forceTimeout";
        public static const ALTERNATE_HOST_DETERMINED:String = "alternateHostDetermined";
        public static const FAILBACK_TO_PRIMARY:String = "failbackToPrimary";
        public static const SERVER_CHANGED:String = "serverChanged";
        public static const STATUS_CHANGED:String = "statusChanged";

        private var _data:QoSEventVO;

        public function QoSEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:QoSEventVO=null){
            super(_arg1, _arg2, _arg3);
            this._data = _arg4;
        }
        public function get data():QoSEventVO{
            return (this._data);
        }
        override public function clone():Event{
            return (new QoSEvent(type, bubbles, cancelable, this.data));
        }

    }
}//package com.akamai.qos 
﻿package com.akamai.qos {
    import org.osmf.logging.*;

    public class HDN1IdentModel extends IdentModel {

        private static const logger:Logger = Log.getLogger("com.akamai.qos.HDN1IdentModel");

        private var _onEdgeForceTimeoutMin:Number;
        private var _onEdgeForceTimeoutMax:Number;
        private var _onEdgeAIArray:Array;

        public function HDN1IdentModel(_arg1:XML){
            super(_arg1);
        }
        public function set onEdgeForceTimeoutMin(_arg1:Number):void{
            this._onEdgeForceTimeoutMin = _arg1;
        }
        public function set onEdgeForceTimeoutMax(_arg1:Number):void{
            this._onEdgeForceTimeoutMax = _arg1;
        }
        public function set onEdgeAIArray(_arg1:Array):void{
            this._onEdgeAIArray = _arg1;
        }
        override public function get forceSwitchTimeout():Number{
            return (((((!(isNaN(this._onEdgeForceTimeoutMin))) && (!(isNaN(this._onEdgeForceTimeoutMax))))) ? randomNumber(this._onEdgeForceTimeoutMin, this._onEdgeForceTimeoutMax) : randomNumber(forceTimeoutMin, forceTimeoutMax)));
        }
        override public function get alternateInRegionHost():String{
            var _local1:String = ((ident)!=null) ? ident.ai.toString() : "";
            var _local2:String = ((this._onEdgeAIArray)!=null) ? this._onEdgeAIArray.toString() : _local1;
            return ((((_local2.length > 0)) ? _local2 : null));
        }
        override protected function createAlternateInRegionHostArray():Array{
            return (((this._onEdgeAIArray)!=null) ? this._onEdgeAIArray : ident.ai.toString().split(/[;]+/));
        }
        private function debug(_arg1:String):void{
            if (logger != null){
                logger.debug(_arg1);
            };
        }

    }
}//package com.akamai.qos 
﻿package com.akamai.version {

    public class HDCoreVersion {

        private static const VERSION:String = "2.3.2";

        public static function get version():String{
            return (VERSION);
        }

    }
}//package com.akamai.version 
﻿package com.akamai.rss {
    import org.openvideoplayer.events.*;
    import org.openvideoplayer.parsers.*;

    public class AkamaiBOSSParser extends ParserBase {

        public const VERSION:String = "2.0";
        public const METAFILE_VERSION_I:String = "METAFILE_VERSION_I";
        public const METAFILE_VERSION_II:String = "METAFILE_VERSION_II";
        public const METAFILE_VERSION_IV:String = "METAFILE_VERSION_IV";

        private var _serverName:String;
        private var _appName:String;
        private var _streamName:String;
        private var _protocol:String;
        private var _isLive:Boolean;
        private var _bufferTime:Number;
        private var _fallbackServerName:String;
        private var _connectAuthParams:String;
        private var _playAuthParams:String;
        private var _source:String;
        private var _title:String;
        private var _copyright:String;
        private var _author:String;
        private var _clipBegin:String;
        private var _clipEnd:String;
        private var _duration:String;
        private var _keywords:String;
        private var _secondaryEncoderSrc:String;
        private var _versionOfMetafile:String;
        private var _ns:Namespace;
        private var _hostName:String;

        public function AkamaiBOSSParser():void{
            super();
        }
        public function get serverName():String{
            return (this._serverName);
        }
        public function get appName():String{
            return (this._appName);
        }
        public function get streamName():String{
            return (this._streamName);
        }
        public function get hostName():String{
            return (this._hostName);
        }
        public function get isLive():Boolean{
            return (this._isLive);
        }
        public function get connectAuthParams():String{
            return (this._connectAuthParams);
        }
        public function get playAuthParams():String{
            return (this._playAuthParams);
        }
        public function get fallbackServerName():String{
            return (this._fallbackServerName);
        }
        public function get protocol():String{
            return (this._protocol);
        }
        public function get source():String{
            return (this._source);
        }
        public function get title():String{
            return (this._title);
        }
        public function get copyright():String{
            return (this._copyright);
        }
        public function get author():String{
            return (this._author);
        }
        public function get clipBegin():String{
            return (this._clipBegin);
        }
        public function get clipEnd():String{
            return (this._clipEnd);
        }
        public function get duration():String{
            return (this._duration);
        }
        public function get keywords():String{
            return (this._keywords);
        }
        public function get secondaryEncoderSrc():String{
            return (this._secondaryEncoderSrc);
        }
        public function get versionOfMetafile():String{
            return (this._versionOfMetafile);
        }
        public function get bufferTime():Number{
            return (this._bufferTime);
        }
        override protected function parseXML():void{
            if (!(this.verifyRSS(_xml))){
                dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.XML_BOSS_MALFORMED)));
            } else {
                switch (this._versionOfMetafile){
                    case this.METAFILE_VERSION_I:
                        this._serverName = _xml.serverName;
                        this._fallbackServerName = _xml.fallbackServerName;
                        this._appName = _xml.appName.split("?")[0];
                        this._streamName = _xml.streamName.split("?")[0];
                        this._hostName = ((this._serverName + "/") + this._appName);
                        this._isLive = (_xml.isLive.toString().toUpperCase() == "TRUE");
                        this._bufferTime = Number(xml.bufferTime);
                        this._connectAuthParams = _xml.appName.split("?")[1];
                        this._playAuthParams = _xml.streamName.split("?")[1];
                        dispatchEvent(new OvpEvent(OvpEvent.PARSED));
                        break;
                    case this.METAFILE_VERSION_II:
                        this._serverName = _xml.stream.entry.serverName;
                        this._appName = _xml.stream.entry.appName.split("?")[0];
                        this._streamName = _xml.stream.entry.streamName.split("?")[0];
                        this._hostName = ((this._serverName + "/") + this._appName);
                        this._isLive = (_xml.stream.entry.isLive.toString().toUpperCase() == "TRUE");
                        this._bufferTime = Number(xml.stream.entry.bufferTime);
                        this._connectAuthParams = _xml.stream.entry.appName.split("?")[1];
                        this._playAuthParams = _xml.stream.entry.streamName.split("?")[1];
                        dispatchEvent(new OvpEvent(OvpEvent.PARSED));
                        break;
                    case this.METAFILE_VERSION_IV:
                        this._source = _xml.this._ns::video.@src;
                        this._title = _xml.this._ns::video.@title;
                        this._author = _xml.this._ns::video.@author;
                        this._clipBegin = _xml.this._ns::video.@clipBegin;
                        this._clipEnd = _xml.this._ns::video.@clipEnd;
                        this._duration = _xml.this._ns::video.@dur;
                        this._connectAuthParams = _xml.this._ns::video.this._ns::param.(@name == "connectAuthParams").@value;
                        this._playAuthParams = _xml.this._ns::video.this._ns::param.(@name == "playAuthParams").@value;
                        this._keywords = _xml.this._ns::video.this._ns::param.(@name == "keywords").@value;
                        this._secondaryEncoderSrc = _xml.this._ns::video.this._ns::param.(@name == "secondaryEncoderSrc").@value;
                        this._serverName = this.parseServerName(this._source);
                        this._appName = this.parseAppName(this._source);
                        this._hostName = ((this._serverName + "/") + this._appName);
                        this._streamName = this.parseStreamName(this._source);
                        this._protocol = this.parseProtocol(this._source);
                        this._isLive = (_xml.this._ns::video.this._ns::param.(@name == "isLive").@value == "1");
                        dispatchEvent(new OvpEvent(OvpEvent.PARSED));
                        break;
                };
            };
            _busy = false;
        }
        private function parseServerName(s:String):String{
            return (s.split("/")[2]);
        }
        private function parseAppName(s:String):String{
            return (s.split("/")[3]);
        }
        private function parseStreamName(s:String):String{
            return (s.slice(((s.indexOf(this.hostName) + this.hostName.length) + 1)));
        }
        private function parseProtocol(s:String):String{
            return (s.slice(0, s.indexOf(":")).toLowerCase());
        }
        private function verifyRSS(src:XML):Boolean{
            var isVerified:Boolean;
            switch (src.localName()){
                case "FLVPlayerConfig":
                    if ((((src.stream == undefined)) && ((src.stream.entry == undefined)))){
                        this._versionOfMetafile = this.METAFILE_VERSION_I;
                        isVerified = !((((((((((src.serverName == undefined)) || ((src.appName == undefined)))) || ((src.streamName == undefined)))) || ((src.isLive == undefined)))) || ((src.bufferTime == undefined))));
                    } else {
                        this._versionOfMetafile = this.METAFILE_VERSION_II;
                        isVerified = !((((((((((src.stream.entry.serverName == undefined)) || ((src.stream.entry.appName == undefined)))) || ((src.stream.entry.streamName == undefined)))) || ((src.stream.entry.isLive == undefined)))) || ((src.stream.entry.bufferTime == undefined))));
                    };
                    break;
                case "smil":
                    if (src.attribute("title").toString() == "EdgeBOSS-SMIL:1.0"){
                        this._versionOfMetafile = this.METAFILE_VERSION_IV;
                        this._ns = new Namespace("http://www.w3.org/2005/SMIL21/Language");
                        isVerified = !((src.this._ns::video.@src == undefined));
                    } else {
                        isVerified = false;
                    };
                    break;
                default:
                    isVerified = false;
            };
            return (isVerified);
        }

    }
}//package com.akamai.rss 
﻿package com.akamai.utils {
    import org.osmf.utils.*;

    public class URLUtils {

        public static function getCacheBustString(_arg1:Number=5):String{
            var _local2:String = "";
            var _local3:Number = 0;
            while (_local3 < _arg1) {
                _local2 = (_local2 + String.fromCharCode((65 + Math.round((Math.random() * 25)))));
                _local3++;
            };
            return (_local2);
        }
        public static function modifyResourceHost(_arg1:String, _arg2:String):String{
            var _local3:URL = new URL(_arg1);
            var _local4:String = new String(((((_local3.protocol + "://") + _arg2) + "/") + _local3.path));
            if (((!((_local3.query == null))) && ((_local3.query.length > 0)))){
                _local4 = (_local4 + ("?" + _local3.query));
            };
            return (_local4);
        }
        public static function addQueryArg(_arg1:String, _arg2:String, _arg3:String):String{
            var _local4:String = _arg1;
            if (((!((_local4 == null))) && (!((_arg2 == null))))){
                _local4 = (_local4 + ((_local4.search(/\?/))==-1) ? "?" : "&");
                _local4 = (_local4 + _arg2);
                if (_arg3 != null){
                    _local4 = (_local4 + ("=" + _arg3));
                };
            };
            return (_local4);
        }

    }
}//package com.akamai.utils 
﻿package com.akamai.utils {
    import flash.utils.*;
    import com.akamai.hd.*;
    import flash.events.*;
    import flash.net.*;

    public class BandwidthEstimation extends EventDispatcher {

        public function BandwidthEstimation(_arg1:String, _arg2:Number=1){
            var totalBytesRead:* = 0;
            var urlStream:* = null;
            var timeout:* = 0;
            var startTime:* = NaN;
            var endTime:* = NaN;
            var onEstimationComplete:* = null;
            var errorHandler:* = null;
            var onComplete:* = null;
            var url:* = _arg1;
            var estimationPeriodInSeconds:int = _arg2;
            super();
            onEstimationComplete = function ():void{
                totalBytesRead = urlStream.bytesAvailable;
                closeStream();
                clearTimeout(timeout);
                dispatchEvent(new HDEvent(HDEvent.BANDWIDTH_ESTIMATION_COMPLETE, {value:getBandwidthEstimationInKbps()}));
            };
            var getBandwidthEstimationInKbps:* = function ():Number{
                var _local1:Number = ((!(isNaN(endTime))) ? endTime : estimationPeriodInSeconds);
                return (Math.round((((totalBytesRead * 8) / 1000) / _local1)));
            };
            errorHandler = function (_arg1:ErrorEvent):void{
                closeStream();
                clearTimeout(timeout);
                dispatchEvent(new HDEvent(HDEvent.ERROR, {value:_arg1.text}));
            };
            var addListeners:* = function ():void{
                urlStream.addEventListener(Event.COMPLETE, onComplete);
                urlStream.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
                urlStream.addEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandler);
            };
            onComplete = function (_arg1:Event):void{
                endTime = ((getTimer() - startTime) / 1000);
                clearTimeout(timeout);
                onEstimationComplete();
            };
            var removeListeners:* = function ():void{
                urlStream.removeEventListener(Event.COMPLETE, onComplete);
                urlStream.removeEventListener(IOErrorEvent.IO_ERROR, errorHandler);
                urlStream.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandler);
            };
            var closeStream:* = function ():void{
                urlStream.close();
                removeListeners();
            };
            totalBytesRead = 0;
            urlStream = new URLStream();
            timeout = setTimeout(onEstimationComplete, (estimationPeriodInSeconds * 1000));
            startTime = getTimer();
            var qString:* = ((url.indexOf("?"))==-1) ? "?bandwidthEstimationTest=true" : "&bandwidthEstimationTest=true";
            addListeners();
            urlStream.load(new URLRequest((url + qString)));
        }
    }
}//package com.akamai.utils 
﻿package com.akamai.net {
    import flash.events.*;
    import flash.net.*;
    import org.openvideoplayer.net.*;
    import org.openvideoplayer.events.*;
    import org.openvideoplayer.utilities.*;
    import org.openvideoplayer.version.*;

    public class AkamaiConnection extends OvpConnection {

        protected var _ip:String;
        protected var _isLive:Boolean;
        private var _overrideIP:String = "";

        public function AkamaiConnection(){
            this._isLive = false;
            super();
        }
        override public function set requestedPort(_arg1:String):void{
            var _local3:String;
            var _local2:Array = _arg1.split(",");
            for (_local3 in _local2) {
                if (!((((((((_local2[_local3].toLowerCase() == "any")) || ((_local2[_local3] == "1935")))) || ((_local2[_local3] == "80")))) || ((_local2[_local3] == "443"))))){
                    dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.PORT_NOT_SUPPORTED)));
                };
            };
            _port = _arg1;
        }
        override public function set requestedProtocol(_arg1:String):void{
            var _local3:String;
            var _local2:Array = _arg1.split(",");
            for (_local3 in _local2) {
                if (!((((((((((_local2[_local3].toLowerCase() == "any")) || ((_local2[_local3].toLowerCase() == "rtmp")))) || ((_local2[_local3].toLowerCase() == "rtmpt")))) || ((_local2[_local3].toLowerCase() == "rtmpe")))) || ((_local2[_local3].toLowerCase() == "rtmpte"))))){
                    dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.PROTOCOL_NOT_SUPPORTED)));
                };
            };
            _protocol = _arg1;
        }
        public function get connectionAuth():String{
            return (_authParams);
        }
        public function set connectionAuth(_arg1:String):void{
            _authParams = _arg1;
        }
        override public function get serverIPaddress():String{
            return (((_connectionEstablished) ? ((((this._ip) && (!((this._ip == ""))))) ? this._ip : _hostName) : null));
        }
        public function get subscribeRequiredForLiveStreams():Boolean{
            return (false);
        }
        public function get isLive():Boolean{
            return (this._isLive);
        }
        public function set overrideIP(_arg1:String):void{
            this._overrideIP = _arg1;
        }
        public function get overrideIP():String{
            return (this._overrideIP);
        }
        override public function connect(_arg1:String, ... _args):void{
            _connectionArgs = _args;
            if ((((_arg1 == null)) || ((_arg1 == "null")))){
                super.connect(_arg1, _args);
                return;
            };
            if (_arg1 == ""){
                dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.HOSTNAME_EMPTY)));
                return;
            };
            _isProgressive = false;
            _hostName = ((!((_arg1.indexOf("/") == -1))) ? _arg1.slice(0, _arg1.indexOf("/")) : _arg1);
            _appNameInstName = ((((!((_arg1.indexOf("/") == -1))) && (!((_arg1.indexOf("/") == (_arg1.length - 1)))))) ? _arg1.slice((_arg1.indexOf("/") + 1)) : "");
            this._isLive = ((!((_appNameInstName.indexOf("live") == -1))) ? true : false);
            _connectionEstablished = false;
            var _local3:Object = new Object();
            FlashPlayer.version(_local3);
            if (this._overrideIP != ""){
                this._ip = this._overrideIP;
                buildConnectionSequence();
            } else {
                if ((((_local3.major < 9)) || ((((_local3.major == 9)) && ((_local3.build < 60)))))){
                    _urlLoader = new URLLoader();
                    _urlLoader.addEventListener("complete", this.onXMLLoaded);
                    _urlLoader.addEventListener(IOErrorEvent.IO_ERROR, this.catchIOError);
                    _urlLoader.load(new URLRequest((("http://" + _hostName) + "/fcs/ident")));
                } else {
                    buildConnectionSequence();
                };
            };
        }
        public function callFCSubscribe(_arg1:String):void{
            dispatchEvent(new OvpEvent(OvpEvent.SUBSCRIBE_ATTEMPT));
            _nc.call("FCSubscribe", null, _arg1);
        }
        override protected function buildConnectionAddress(_arg1:String, _arg2:String):String{
            var _local3:String = (_arg1 + "://");
            _local3 = (_local3 + ((((this._ip) && (!((this._ip == ""))))) ? this._ip : _hostName));
            _local3 = (_local3 + ((((":" + _arg2) + "/") + _appNameInstName) + "?"));
            _local3 = (_local3 + ((((this._ip) && (!((this._ip == ""))))) ? (("_fcs_vhost=" + _hostName) + "&") : ""));
            _local3 = (_local3 + (("ovpfv=" + OvpVersion.version) + (((_authParams == "")) ? "" : ("&" + _authParams))));
            return (_local3);
        }
        protected function catchIOError(_arg1:IOErrorEvent):void{
            dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.IDENT_REQUEST_FAILED)));
            this._ip = _hostName;
            buildConnectionSequence();
        }
        protected function onXMLLoaded(_arg1:Event):void{
            this._ip = XML(_urlLoader.data).ip;
            buildConnectionSequence();
        }

    }
}//package com.akamai.net 
﻿package com.akamai.net {
    import org.openvideoplayer.events.*;
    import flash.events.*;
    import flash.utils.*;
    import org.openvideoplayer.net.*;
    import org.openvideoplayer.utilities.*;

    public class AkamaiNetStream extends OvpNetStream {

        protected const LIVE_RETRY_INTERVAL:Number = 15000;
        protected const LIVE_RETRY_TIMEOUT:Number = 1200000;

        protected var _liveStreamAuthParams:String;
        protected var _liveStreamRetryTimer:Timer;
        protected var _liveStreamTimeoutTimer:Timer;
        protected var _successfullySubscribed:Boolean;
        protected var _liveRetryInterval:Number;
        protected var _liveStreamMasterTimeout:Number;
        protected var _playingLiveStream:Boolean;
        protected var _pendingLiveStreamName:String;
        protected var _akamaiConnection:AkamaiConnection;
        protected var _retryLiveStreamsIfUnavailable:Boolean;
        protected var _playReissueRequired:Boolean;

        public function AkamaiNetStream(_arg1:Object){
            super(_arg1);
            if ((((_arg1 is AkamaiConnection)) && (AkamaiConnection(_arg1).isLive))){
                this._akamaiConnection = AkamaiConnection(_arg1);
                this._akamaiConnection.addEventListener(OvpEvent.FCSUBSCRIBE, this.onFCSubscribe);
                this._akamaiConnection.addEventListener(OvpEvent.FCUNSUBSCRIBE, this.onFCUnsubscribe);
                this.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus);
                _isLive = true;
                this._liveStreamAuthParams = "";
                this._liveRetryInterval = this.LIVE_RETRY_INTERVAL;
                this._liveStreamMasterTimeout = this.LIVE_RETRY_TIMEOUT;
                this._liveStreamRetryTimer = new Timer(this._liveRetryInterval);
                this._liveStreamRetryTimer.addEventListener(TimerEvent.TIMER, this.onRetryLiveStream);
                this._liveStreamTimeoutTimer = new Timer(this._liveStreamMasterTimeout, 1);
                this._liveStreamTimeoutTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.onLiveStreamTimeout);
                this._retryLiveStreamsIfUnavailable = true;
                this._playReissueRequired = false;
            };
        }
        public function get liveStreamAuthParams():String{
            return (this._liveStreamAuthParams);
        }
        public function set liveStreamAuthParams(_arg1:String):void{
            this._liveStreamAuthParams = _arg1;
        }
        public function get retryLiveStreamsIfUnavailable():Boolean{
            return (this._retryLiveStreamsIfUnavailable);
        }
        public function set retryLiveStreamsIfUnavailable(_arg1:Boolean):void{
            this._retryLiveStreamsIfUnavailable = _arg1;
        }
        public function get liveRetryInterval():Number{
            return ((this._liveRetryInterval / 1000));
        }
        public function set liveRetryInterval(_arg1:Number):void{
            this._liveRetryInterval = (_arg1 * 1000);
        }
        public function get liveStreamMasterTimeout():Number{
            return ((this._liveStreamMasterTimeout / 1000));
        }
        public function set liveStreamMasterTimeout(_arg1:Number):void{
            this._liveStreamMasterTimeout = (_arg1 * 1000);
            this._liveStreamTimeoutTimer.delay = this._liveStreamMasterTimeout;
        }
        override public function play(... _args):void{
            var _local2:String;
            if (((((!(_isProgressive)) && (_args))) && (_args.length))){
                _args[0] = this.addPrefix(_args[0]);
            };
            if (isLive){
                if (this._liveStreamAuthParams != ""){
                    _local2 = _args[0];
                    _args[0] = ((!((_local2.indexOf("?") == -1))) ? ((_local2 + "&") + this._liveStreamAuthParams) : ((_local2 + "?") + this._liveStreamAuthParams));
                };
                this._pendingLiveStreamName = (_args[0] as String);
                _args[1] = -1;
                this._liveStreamTimeoutTimer.reset();
                this._liveStreamTimeoutTimer.start();
            };
            super.play.apply(this, _args);
        }
        override public function close():void{
            super.close();
            if (isLive){
                this.resetAllLiveTimers();
            };
        }
        public function unsubscribe():Boolean{
            if (this._successfullySubscribed){
                this.resetAllLiveTimers();
                this._playingLiveStream = false;
                super.play(false);
                _nc.call("FCUnsubscribe", null, this._pendingLiveStreamName);
                return (true);
            };
            return (false);
        }
        protected function addPrefix(_arg1:String):String{
            return (StringUtil.addPrefix(_arg1));
        }
        private function onRetryLiveStream(_arg1:TimerEvent):void{
            var _local2:Array;
            if (this._retryLiveStreamsIfUnavailable){
                this._akamaiConnection.callFCSubscribe(this._pendingLiveStreamName.split("?")[0].toString());
                if (this._playReissueRequired){
                    this._playReissueRequired = false;
                    _local2 = new Array();
                    _local2.push(this._pendingLiveStreamName);
                    super.play.apply(this, _local2);
                };
                dispatchEvent(new OvpEvent(OvpEvent.SUBSCRIBE_ATTEMPT));
            } else {
                this.onLiveStreamTimeout(null);
            };
        }
        private function onLiveStreamTimeout(_arg1:TimerEvent):void{
            this.resetAllLiveTimers();
            dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.STREAM_NOT_FOUND)));
        }
        private function resetAllLiveTimers():void{
            this._liveStreamRetryTimer.reset();
            this._liveStreamTimeoutTimer.reset();
        }
        public function onFCSubscribe(_arg1:Object):void{
            switch (_arg1.data.code){
                case "NetStream.Play.StreamNotFound":
                    if (!(this._liveStreamRetryTimer.running)){
                        this.onRetryLiveStream(null);
                        this._liveStreamRetryTimer.reset();
                        this._liveStreamRetryTimer.start();
                    };
                    break;
            };
        }
        private function onFCUnsubscribe(_arg1:Object):void{
        }
        private function onNetStatus(_arg1:NetStatusEvent):void{
            switch (_arg1.info.code){
                case "NetStream.Play.PublishNotify":
                    this._successfullySubscribed = true;
                    dispatchEvent(new OvpEvent(OvpEvent.SUBSCRIBED));
                    this.resetAllLiveTimers();
                    break;
                case "NetStream.Play.UnpublishNotify":
                    this._successfullySubscribed = false;
                    this._playReissueRequired = true;
                    dispatchEvent(new OvpEvent(OvpEvent.UNSUBSCRIBED));
                    if (!(this._liveStreamRetryTimer.running)){
                        this.onRetryLiveStream(null);
                        this._liveStreamRetryTimer.reset();
                        this._liveStreamRetryTimer.start();
                        this._liveStreamTimeoutTimer.reset();
                        this._liveStreamTimeoutTimer.start();
                    };
                    break;
            };
        }

    }
}//package com.akamai.net 
﻿package com.akamai.net {
    import flash.net.*;
    import org.openvideoplayer.net.*;
    import org.openvideoplayer.events.*;
    import flash.events.*;
    import flash.utils.*;
    import org.openvideoplayer.net.dynamicstream.*;
    import org.openvideoplayer.utilities.*;

    public class AkamaiDynamicNetStream extends OvpDynamicNetStream {

        private const LIVE_RETRY_INTERVAL:Number = 15000;
        private const LIVE_RETRY_TIMEOUT:Number = 1200000;

        private var _liveStreamAuthParams:String;
        private var _liveStreamRetryTimer:Timer;
        private var _liveStreamTimeoutTimer:Timer;
        private var _successfullySubscribed:Boolean;
        private var _liveRetryInterval:Number;
        private var _liveStreamMasterTimeout:Number;
        private var _playingLiveStream:Boolean;
        private var _pendingLiveStreamName:String;
        private var _akamaiConnection:AkamaiConnection;
        private var _retryLiveStreamsIfUnavailable:Boolean;
        private var _playReissueRequired:Boolean;

        public function AkamaiDynamicNetStream(_arg1:Object){
            var _local2:NetConnection;
            if ((_arg1 is AkamaiConnection)){
                this._akamaiConnection = (_arg1 as AkamaiConnection);
                _local2 = this._akamaiConnection.netConnection;
            } else {
                if ((_arg1 is OvpConnection)){
                    _local2 = (_arg1 as OvpConnection).netConnection;
                } else {
                    _local2 = (_arg1 as NetConnection);
                };
            };
            super(_local2);
            if (((!((this._akamaiConnection == null))) && (this._akamaiConnection.isLive))){
                this._akamaiConnection.addEventListener(OvpEvent.FCSUBSCRIBE, this.onFCSubscribe);
                this._akamaiConnection.addEventListener(OvpEvent.FCUNSUBSCRIBE, this.onFCUnsubscribe);
                this.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus);
                isLive = true;
                this._liveStreamAuthParams = "";
                this._liveRetryInterval = this.LIVE_RETRY_INTERVAL;
                this._liveStreamMasterTimeout = this.LIVE_RETRY_TIMEOUT;
                this._liveStreamRetryTimer = new Timer(this._liveRetryInterval);
                this._liveStreamRetryTimer.addEventListener(TimerEvent.TIMER, this.onRetryLiveStream);
                this._liveStreamTimeoutTimer = new Timer(this._liveStreamMasterTimeout, 1);
                this._liveStreamTimeoutTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.onLiveStreamTimeout);
                this._retryLiveStreamsIfUnavailable = true;
                this._playReissueRequired = false;
            };
        }
        override public function play(... _args):void{
            var _local2:String;
            if ((((((((_args[0] is String)) && (!(_isProgressive)))) && (_args))) && (_args.length))){
                _args[0] = this.addPrefix(_args[0]);
                if (isLive){
                    if (this._liveStreamAuthParams != ""){
                        _local2 = _args[0];
                        _args[0] = ((!((_local2.indexOf("?") == -1))) ? ((_local2 + "&") + this._liveStreamAuthParams) : ((_local2 + "?") + this._liveStreamAuthParams));
                    };
                    this._pendingLiveStreamName = (_args[0] as String);
                    _args[1] = -1;
                    this._liveStreamTimeoutTimer.reset();
                    this._liveStreamTimeoutTimer.start();
                };
            } else {
                if ((((((_args[0] is DynamicStreamItem)) && (!((this._akamaiConnection == null))))) && (this._akamaiConnection.isLive))){
                    _dsi = (_args[0] as DynamicStreamItem);
                    _isMultibitrate = true;
                    isLive = true;
                    this._liveStreamTimeoutTimer.reset();
                    this._liveStreamTimeoutTimer.start();
                };
            };
            super.play.apply(this, _args);
        }
        override protected function prepareNetStreamPlayOptions(_arg1:uint, _arg2:Boolean):NetStreamPlayOptions{
            var _local3:NetStreamPlayOptions = new NetStreamPlayOptions();
            _local3.start = _dsi.start;
            _local3.len = _dsi.len;
            _local3.streamName = ((_arg2) ? _dsi.getNameAt(_arg1) : _dsi.getNameAt(_arg1).split("?")[0]);
            if (((_arg2) && (!((this._liveStreamAuthParams == ""))))){
                _local3.streamName = ((!((_local3.streamName.indexOf("?") == -1))) ? ((_local3.streamName + "&") + this._liveStreamAuthParams) : ((_local3.streamName + "?") + this._liveStreamAuthParams));
            };
            _local3.oldStreamName = _oldStreamName;
            _local3.transition = ((_arg2) ? NetStreamPlayTransitions.RESET : NetStreamPlayTransitions.SWITCH);
            _oldStreamName = _local3.streamName.split("?")[0];
            debug((((((("Switching to index " + _arg1) + " with name ") + _local3.streamName) + " at ") + Math.round(_dsi.getRateAt(_arg1))) + " kbps"));
            return (_local3);
        }
        public function get liveStreamAuthParams():String{
            return (this._liveStreamAuthParams);
        }
        public function set liveStreamAuthParams(_arg1:String):void{
            this._liveStreamAuthParams = _arg1;
        }
        public function get retryLiveStreamsIfUnavailable():Boolean{
            return (this._retryLiveStreamsIfUnavailable);
        }
        public function set retryLiveStreamsIfUnavailable(_arg1:Boolean):void{
            this._retryLiveStreamsIfUnavailable = _arg1;
        }
        public function get liveRetryInterval():Number{
            return ((this._liveRetryInterval / 1000));
        }
        public function set liveRetryInterval(_arg1:Number):void{
            this._liveRetryInterval = (_arg1 * 1000);
        }
        public function get liveStreamMasterTimeout():Number{
            return ((this._liveStreamMasterTimeout / 1000));
        }
        public function set liveStreamMasterTimeout(_arg1:Number):void{
            this._liveStreamMasterTimeout = (_arg1 * 1000);
            this._liveStreamTimeoutTimer.delay = this._liveStreamMasterTimeout;
        }
        public function unsubscribe():Boolean{
            if (this._successfullySubscribed){
                this.resetAllLiveTimers();
                this._playingLiveStream = false;
                super.play(false);
                _nc.call("FCUnsubscribe", null, this._pendingLiveStreamName);
                return (true);
            };
            return (false);
        }
        override public function close():void{
            super.close();
            if (isLive){
                this.resetAllLiveTimers();
            };
        }
        protected function addPrefix(_arg1:String):String{
            return (StringUtil.addPrefix(_arg1));
        }
        private function onRetryLiveStream(_arg1:TimerEvent):void{
            var _local2:int;
            var _local3:Array;
            if (this._retryLiveStreamsIfUnavailable){
                if (_isMultibitrate){
                    _local2 = 0;
                    while (_local2 < _dsi.streamCount) {
                        this._akamaiConnection.callFCSubscribe(_dsi.getNameAt(_local2).split("?")[0].toString());
                        _local2++;
                    };
                } else {
                    this._akamaiConnection.call("FCSubscribe", null, this._pendingLiveStreamName.split("?")[0].toString());
                };
                if (this._playReissueRequired){
                    this._playReissueRequired = false;
                    _local3 = new Array();
                    _local3.push(((_isMultibitrate) ? _dsi : this._pendingLiveStreamName));
                    super.play.apply(this, _local3);
                };
                dispatchEvent(new OvpEvent(OvpEvent.SUBSCRIBE_ATTEMPT));
            } else {
                this.onLiveStreamTimeout(null);
            };
        }
        private function onLiveStreamTimeout(_arg1:TimerEvent):void{
            this.resetAllLiveTimers();
            dispatchEvent(new OvpEvent(OvpEvent.ERROR, new OvpError(OvpError.STREAM_NOT_FOUND)));
        }
        private function resetAllLiveTimers():void{
            this._liveStreamRetryTimer.reset();
            this._liveStreamTimeoutTimer.reset();
        }
        public function onFCSubscribe(_arg1:Object):void{
            debug(("onFCSubscribe() - info.data.code=" + _arg1.data.code));
            switch (_arg1.data.code){
                case "NetStream.Play.StreamNotFound":
                    if (!(this._liveStreamRetryTimer.running)){
                        this.onRetryLiveStream(null);
                        this._liveStreamRetryTimer.reset();
                        this._liveStreamRetryTimer.start();
                    };
                    break;
            };
        }
        private function onFCUnsubscribe(_arg1:Object):void{
            debug(("onFCUnsubscribe() - info.data.code = " + _arg1.data.code));
        }
        private function onNetStatus(_arg1:NetStatusEvent):void{
            switch (_arg1.info.code){
                case "NetStream.Play.PublishNotify":
                    this._successfullySubscribed = true;
                    dispatchEvent(new OvpEvent(OvpEvent.SUBSCRIBED));
                    this.resetAllLiveTimers();
                    break;
                case "NetStream.Play.UnpublishNotify":
                    this._successfullySubscribed = false;
                    this._playReissueRequired = true;
                    dispatchEvent(new OvpEvent(OvpEvent.UNSUBSCRIBED));
                    if (!(this._liveStreamRetryTimer.running)){
                        this.onRetryLiveStream(null);
                        this._liveStreamRetryTimer.reset();
                        this._liveStreamRetryTimer.start();
                        this._liveStreamTimeoutTimer.reset();
                        this._liveStreamTimeoutTimer.start();
                    };
                    break;
            };
        }
        override protected function chooseDefaultStartingIndex():void{
            this._akamaiConnection.addEventListener(OvpEvent.BANDWIDTH, this.handleBandwidthResult);
            debug("Measuring bandwidth in order to determine a good starting point");
            this._akamaiConnection.detectBandwidth();
        }
        private function handleBandwidthResult(_arg1:OvpEvent):void{
            var _local2:int;
            var _local3:int;
            if (_arg1.data.bandwidth > 0){
                _local2 = (_dsi.streamCount - 1);
                while (_local2 >= 0) {
                    if (_arg1.data.bandwidth > _dsi.getRateAt(_local2)){
                        _streamIndex = _local2;
                        break;
                    };
                    _local2--;
                };
            } else {
                _local3 = 0;
                while (_local3 < _dsi.streamCount) {
                    if (300 < _dsi.getRateAt(_local3)){
                        _streamIndex = _local3;
                        break;
                    };
                    _local3++;
                };
            };
            if (isLive){
                this._pendingLiveStreamName = _dsi.getNameAt(_streamIndex);
            };
            makeFirstSwitch();
        }

    }
}//package com.akamai.net 
﻿package com.ibm.AS3util {

    public class PhpDate {

        public static var lang:String;

        private var _date:Date;
        private var weekdays:Array;
        private var months_en:Array;
        private var monthsShort_en:Array;
        private var months_fr:Array;
        private var monthsShort_fr:Array;
        private var months_es:Array;
        private var monthsShort_es:Array;
        private var timezones:Array;
        private var mondayStartingWeek:Array;

        public function PhpDate(date=null){
            var unixTimestamp:Number;
            this.weekdays = new Array("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday");
            this.months_en = new Array("January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December");
            this.monthsShort_en = new Array("Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sep", "Oct", "Nov", "Dec");
            this.months_fr = new Array("janvier", "f�vrier", "mars", "avril", "mai", "juin", "juillet", "ao�t", "septembre", "octobre", "novembre", "d�cembre");
            this.monthsShort_fr = new Array("janv", "f�vr", "mars", "avril", "mai", "juin", "juil", "ao�t", "sept", "oct", "nov", "d�c");
            this.months_es = new Array("enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre");
            this.monthsShort_es = new Array("enero", "feb", "marzo", "abril", "mayo", "junio", "julio", "ago", "sept", "oct", "nov", "dic");
            this.timezones = new Array("IDLW", "NT", "HST", "AKST", "PST", "MST", "CST", "EST", "AST", "ADT", "AT", "WAT", "GMT", "CET", "EET", "MSK", "ZP4", "ZP5", "ZP6", "WAST", "WST", "JST", "AEST", "AEDT", "NZST");
            this.mondayStartingWeek = new Array(7, 1, 2, 3, 4, 5, 6);
            super();
            if ((date is Date)){
                this._date = (date as Date);
            } else {
                if ((date is Number)){
                    unixTimestamp = (date as Number);
                    this._date = new Date((unixTimestamp * 1000));
                } else {
                    this._date = new Date();
                };
            };
        }
        public static function format(format:String, date=null):String{
            var phpDate:PhpDate = new PhpDate(date);
            return (phpDate.parseFormatString(format));
        }

        public function format(format:String):String{
            return (this.parseFormatString(format));
        }
        private function parseFormatString(format:String):String{
            var result:* = null;
            var format:* = format;
            result = "";
            var chars:* = format.split("");
            chars.forEach(function (item:String, index:int, array:Array):void{
                if ((((((index > 0)) && (!((array[(index - 1)] == "\\"))))) || ((index == 0)))){
                    result = (result + parseSingleChar(item));
                } else {
                    result = (result + item);
                };
            });
            return (result);
        }
        private function parseSingleChar(item:String):String{
            if (item.match(/a/)){
                return (this.getAmPm());
            };
            if (item.match(/A/)){
                return (this.getAmPm(true));
            };
            if (item.match(/B/)){
                return (this.getSwatchInternetTime());
            };
            if (item.match(/c/)){
                return (this.getIso8601());
            };
            if (item.match(/d/)){
                return (this.getDayOfMonth());
            };
            if (item.match(/D/)){
                return (this.getWeekDayAsText(true));
            };
            if (item.match(/F/)){
                return (this.getMonthAsText());
            };
            if (item.match(/g/)){
                return (this.getHours(false, true));
            };
            if (item.match(/G/)){
                return (this.getHours(false));
            };
            if (item.match(/h/)){
                return (this.getHours(true, true));
            };
            if (item.match(/H/)){
                return (this.getHours());
            };
            if (item.match(/i/)){
                return (this.getMinutes());
            };
            if (item.match(/I/)){
                return (this.getSummertime());
            };
            if (item.match(/j/)){
                return (this.getDayOfMonth(false));
            };
            if (item.match(/l/)){
                return (this.getWeekDayAsText());
            };
            if (item.match(/L/)){
                return (this.getLeapYear());
            };
            if (item.match(/m/)){
                return (this.getMonth());
            };
            if (item.match(/M/)){
                return (this.getMonthAsText(true));
            };
            if (item.match(/n/)){
                return (this.getMonth(false));
            };
            if (item.match(/N/)){
                return (this.getIso8601Day());
            };
            if (item.match(/O/)){
                return (this.getDifferenceBetweenGmt());
            };
            if (item.match(/P/)){
                return (this.getDifferenceBetweenGmt(":"));
            };
            if (item.match(/r/)){
                return (this.getRfc2822());
            };
            if (item.match(/s/)){
                return (this.getSeconds());
            };
            if (item.match(/S/)){
                return (this.getMonthDayOrdinalSuffix());
            };
            if (item.match(/t/)){
                return (this.getDaysOfMonth());
            };
            if (item.match(/T/)){
                return (this.getTimezone());
            };
            if (item.match(/u/)){
                return (this.getMilliseconds());
            };
            if (item.match(/U/)){
                return (this.getUnixTimestamp());
            };
            if (item.match(/w/)){
                return (this.getWeekDay());
            };
            if (item.match(/W/)){
                return (this.getWeekOfYear());
            };
            if (item.match(/y/)){
                return (this.getYear(true));
            };
            if (item.match(/Y/)){
                return (this.getYear());
            };
            if (item.match(/z/)){
                return (this.getDayOfYear());
            };
            if (item.match(/Z/)){
                return (this.getTimezoneOffset());
            };
            return (item);
        }
        private function getSummertime():String{
            if (this.isSummertime()){
                return ("1");
            };
            return ("0");
        }
        private function isSummertime():Boolean{
            var referenceOffset:Number;
            var currentOffset:Number = this._date.getTimezoneOffset();
            var month:Number = 1;
            while (month--) {
                referenceOffset = new Date(this._date.getFullYear(), month, 1).getTimezoneOffset();
                if (((!((currentOffset == referenceOffset))) && ((currentOffset < referenceOffset)))){
                    return (true);
                };
            };
            return (false);
        }
        private function getUnixTimestamp():String{
            return (String(Math.floor((this._date.getTime() / 1000))));
        }
        private function getIso8601():String{
            return ((((((((((((this.getYear() + "-") + this.getMonth()) + "-") + this.getDayOfMonth()) + "T") + this.getHours()) + ":") + this.getMinutes()) + ":") + this.getSeconds()) + this.getDifferenceBetweenGmt(":")));
        }
        private function getIso8601Day():String{
            return (String(this.mondayStartingWeek[this._date.getDay()]));
        }
        private function getRfc2822():String{
            return (((((((((((((((this.getWeekDayAsText(true) + ", ") + this.getDayOfMonth()) + " ") + this.getMonthAsText(true)) + " ") + this.getYear()) + " ") + this.getHours()) + ":") + this.getMinutes()) + ":") + this.getSeconds()) + " ") + this.getDifferenceBetweenGmt()));
        }
        private function getTimezone():String{
            var offset:Number = Math.round((11 + -((this._date.getTimezoneOffset() / 60))));
            if (this.isSummertime()){
                offset--;
            };
            return (this.timezones[offset]);
        }
        private function getDifferenceBetweenGmt(seperator:String=""):String{
            var pre:String;
            var timezoneOffset:Number = -(this._date.getTimezoneOffset());
            if (timezoneOffset > 0){
                pre = "+";
            } else {
                pre = "-";
            };
            var hours:Number = Math.floor((timezoneOffset / 60));
            var min:Number = (timezoneOffset - (hours * 60));
            var result:String = pre;
            if (hours < 9){
                result = (result + "0");
            };
            result = (result + hours.toString());
            result = (result + seperator);
            if (min < 9){
                result = (result + "0");
            };
            result = (result + min);
            return (result);
        }
        private function getTimezoneOffset():String{
            return (String((this._date.getTimezoneOffset() * 60)));
        }
        private function getDaysOfMonth():String{
            return (String(new Date(this._date.getFullYear(), (this._date.getMonth() + 1), 0).getDate()));
        }
        private function getSwatchInternetTime():String{
            var daySeconds:int = ((((this._date.getUTCHours() * 3600) + (this._date.getUTCMinutes() * 60)) + this._date.getUTCSeconds()) + 3600);
            return (String(Math.round((daySeconds * 0.01157))));
        }
        private function getMonthDayOrdinalSuffix():String{
            var day:String = this._date.getDate().toString();
            switch (day.charAt((day.length - 1))){
                case "1":
                    return ("st");
                case "2":
                    return ("nd");
                case "3":
                    return ("rd");
                default:
                    return ("th");
            };
        }
        private function getMonthAsText(short:Boolean=false):String{
            if (short == true){
                return (this[("monthsShort_" + lang)][this._date.month]);
            };
            return (this[("months_" + lang)][this._date.month]);
        }
        private function getMilliseconds():String{
            return (String(this._date.getMilliseconds()));
        }
        private function getSeconds(leadingZero:Boolean=true):String{
            if ((((leadingZero == true)) && ((this._date.getSeconds() <= 9)))){
                return (("0" + this._date.getSeconds().toString()));
            };
            return (String(this._date.getSeconds()));
        }
        private function getMinutes(leadingZero:Boolean=true):String{
            if ((((leadingZero == true)) && ((this._date.getMinutes() <= 9)))){
                return (("0" + this._date.getMinutes().toString()));
            };
            return (String(this._date.getMinutes()));
        }
        private function getHours(leadingZero:Boolean=true, twelfHours:Boolean=false):String{
            var hours:int;
            if (twelfHours == true){
                if (this._date.getHours() > 12){
                    hours = (this._date.getHours() - 12);
                } else {
                    hours = this._date.getHours();
                };
            } else {
                hours = this._date.getHours();
            };
            if ((((leadingZero == true)) && ((hours <= 9)))){
                return (("0" + hours.toString()));
            };
            return (String(hours));
        }
        private function getAmPm(upperCase:Boolean=false):String{
            var result:String = "am";
            if (this._date.hours > 12){
                result = "pm";
            };
            if (upperCase == true){
                return (result.toUpperCase());
            };
            return (result);
        }
        private function getWeekDay():String{
            return (String(this._date.getDay()));
        }
        private function getWeekDayAsText(short:Boolean=false):String{
            if (short == true){
                return (String(this.weekdays[this._date.getDay()]).substr(0, 3));
            };
            return (this.weekdays[this._date.getDay()]);
        }
        private function getLeapYear():String{
            if (this.isLeapYear()){
                return ("1");
            };
            return ("0");
        }
        private function isLeapYear():Boolean{
            if (((((this._date.getFullYear() % 4) == 0)) && (((!(((this._date.getFullYear() % 100) == 0))) || (((this._date.getFullYear() % 400) == 0)))))){
                return (true);
            };
            return (false);
        }
        private function getWeekOfYear():String{
            var dayOfYear:Number = Number(this.getDayOfYear());
            var firstDay:Date = new Date(this._date.getFullYear(), 0, 1);
            var fullWeeks:Number = ((dayOfYear - (this.mondayStartingWeek[this._date.getDay()] + (7 - this.mondayStartingWeek[firstDay.getDay()]))) / 7);
            if (this.mondayStartingWeek[firstDay.getDay()] <= 4){
                fullWeeks++;
            };
            fullWeeks++;
            return (String(fullWeeks));
        }
        private function getDayOfYear():String{
            var firstDayOfYear:Date = new Date(this._date.getFullYear(), 0, 1);
            var millisecondsOffset:Number = (this._date.getTime() - firstDayOfYear.getTime());
            return (String(Math.floor((millisecondsOffset / 86400000))));
        }
        private function getYear(twoDigits:Boolean=false):String{
            if (twoDigits == true){
                return (String(this._date.getFullYear()).substr(2, 2));
            };
            return (String(this._date.getFullYear()));
        }
        private function getMonth(leadingZero:Boolean=true):String{
            var month:Number = (this._date.getMonth() + 1);
            if ((((leadingZero == true)) && ((month <= 9)))){
                return (("0" + String(month)));
            };
            return (String(month));
        }
        private function getDayOfMonth(leadingZero:Boolean=true):String{
            if ((((leadingZero == true)) && ((this._date.getDate() <= 9)))){
                return (("0" + String(this._date.getDate())));
            };
            return (String(this._date.getDate()));
        }

    }
}//package com.ibm.AS3util 
﻿package com.ibm.AS3util {
    import flash.text.*;

    public class DefaultTextField {

        public static function getOne(tformat:TextFormat=null, embedFonts:Boolean=true, name:String=null):TextField{
            var tf:TextField = new TextField();
            tf.antiAliasType = AntiAliasType.ADVANCED;
            tf.selectable = false;
            tf.autoSize = TextFieldAutoSize.LEFT;
            tf.embedFonts = embedFonts;
            tf.mouseEnabled = false;
            tf.width = 10;
            tf.height = 10;
            if (name != null){
                tf.name = name;
            };
            if (tformat != null){
                tf.defaultTextFormat = tformat;
            };
            return (tf);
        }

    }
}//package com.ibm.AS3util 
﻿package com.ibm.AS3util {
    import flash.system.*;
    import flash.display.*;
    import flash.events.*;
    import flash.net.*;

    public class ImageLoader {

        private static var _imageLoading:Array = new Array();
        private static var _imageLoader:Loader;

        public static function loadImage(url:String, parent:MovieClip, width:int, height:int, errorImage:BitmapData, byteMin:int=-1):void{
            parent.visible = false;
            var ldrContext:LoaderContext = new LoaderContext(true);
            _imageLoading.push(new Array(url, parent, width, height, byteMin, errorImage));
            _imageLoader = new Loader();
            _imageLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, imageLoadComplete);
            _imageLoader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
            _imageLoader.load(new URLRequest(url), ldrContext);
        }
        private static function ioErrorHandler(event:IOErrorEvent):void{
            drawImages(event.text, -2, null);
        }
        private static function imageLoadComplete(event:Event):void{
            drawImages(event.target.url, event.target.bytesTotal, event.target.content.bitmapData);
        }
        private static function drawImages(imageURL:String, bytesLoaded:int, bitmap:BitmapData):void{
            var imageData:BitmapData;
            var loadedImage:Bitmap;
            var x:int;
            while (x < _imageLoading.length) {
                if (imageURL.match(_imageLoading[x][0])){
                    if (bytesLoaded > _imageLoading[x][4]){
                        imageData = bitmap;
                    } else {
                        imageData = _imageLoading[x][5];
                    };
                    loadedImage = new Bitmap(imageData);
                    loadedImage.smoothing = true;
                    loadedImage.x = 0;
                    loadedImage.y = 0;
                    loadedImage.width = _imageLoading[x][2];
                    loadedImage.height = _imageLoading[x][3];
                    _imageLoading[x][1].addChild(loadedImage);
                    _imageLoading[x][1].visible = true;
                    break;
                };
                x++;
            };
            _imageLoading.splice(x, 1);
        }

    }
}//package com.ibm.AS3util 
﻿package com.ibm.AS3util {
    import flash.external.*;

    public class Debug {

        private static var _instance:Debug = null;

        public var debug:String;

        public function Debug(h:Function){
            super();
            if (h != hidden){
                throw (new Error("Singleton and can only be accessed through Singleton.getInstance()"));
            };
        }
        public static function getInstance():Debug{
            if (_instance == null){
                _instance = new Debug(hidden);
            };
            return (_instance);
        }
        private static function hidden():void{
        }

        public function traceDebug(text:String):void{
            var text:* = text;
            if (this.debug == "true"){
                try {
                    ExternalInterface.call("flashLog", "debug", text);
                } catch(e:Error) {
                    trace(text);
                };
            };
        }
        public function traceInfo(text:String):void{
            var text:* = text;
            if (this.debug == "true"){
                try {
                    ExternalInterface.call("flashLog", "info", text);
                } catch(e:Error) {
                    trace(text);
                };
            };
        }
        public function traceError(text:String):void{
            var text:* = text;
            if (this.debug == "true"){
                try {
                    ExternalInterface.call("flashLog", "error", text);
                } catch(e:Error) {
                    trace(text);
                };
            };
        }
        public function traceFatal(text:String):void{
            var text:* = text;
            if (this.debug == "true"){
                try {
                    ExternalInterface.call("flashLog", "fatal", text);
                } catch(e:Error) {
                    trace(text);
                };
            };
        }

    }
}//package com.ibm.AS3util 
﻿package com.ibm.media {
    import com.ibm.AS3util.*;
    import flash.net.*;
    import flash.events.*;
    import flash.utils.*;
    import com.akamai.playeranalytics.*;
    import com.akamai.hd.*;

    public class AkamaiHDCoreConnection extends ConvivaMediaConnection implements IMediaServerConnection {

        public static var LIVE:String = "live";
        public static var ONDEMAND:String = "ondemand";

        public const INIT_LIVE_TIMEOUT:int = 3600;
        public const CDN:String = "Akamai";

        private var _bytesLoaded:Number;
        private var _currentVolume:Number;
        private var _bitrate:Number;
        private var _startPosition:Number;
        private var _initialSeek:Boolean;
        private var _isPlaying:Boolean;
        private var _isAvailable:Boolean;
        private var _bandwidth:String;
        private var _latency:String;
        private var _metricsTimer:Timer;
        private var _checkMetrics:Boolean;
        private var _metricsObject:Object;
        private var _videoStats:VideoStats;
        private var _timeRemaining:uint;
        private var _liveTimeout:int;
        private var _secureConnect:Boolean;
        private var _securePlay:Boolean;
        private var _connectParams:String;
        private var _playParams:String;
        private var _maxBitrate:int = -1;
        private var _streamname:String;
        private var _streamtype:String;
        private var _dvrTime:int;
        private var _dvrAvailable:int;
        private var _currentTime:Number = 0;
        private var _liveTime:Number = 0;
        private var _minTime:Number = 0;
        private var _mediaAnalytics:Boolean = false;
        private var _isConnectionInfoCalled:Boolean;
        private var count:int = 0;

        public function AkamaiHDCoreConnection(id:String, streamInfo:StreamObject):void{
            super(id, streamInfo);
            this._isPlaying = false;
            this._isAvailable = true;
            this._checkMetrics = false;
            _nc = new NetConnection();
            _nc.addEventListener(NetStatusEvent.NET_STATUS, this.netStatusHandler);
            this._metricsObject = new Object();
            this._metricsTimer = new Timer(1000);
            this._metricsTimer.addEventListener(TimerEvent.TIMER, this.updateVideoMetrics);
        }
        private static function getDisplayTime(num=null):String{
            if (num){
                return (PhpDate.format("H:i:s", Math.round((num / 1000))));
            };
            return ("N/A");
        }

        public function startPlayback(url:String, streamType:String, seekPos:Number, dvrTime:int=0, buffer:int=3, liveTimeout:int=3600, bitrate:Number=0):void{
            var temp:Array;
            var streamURL:Array = String(url).split("?");
            this._secureConnect = (((streamURL[1] > 0)) ? true : false);
            this._dvrTime = dvrTime;
            this._dvrAvailable = this._dvrTime;
            this._bitrate = bitrate;
            this._startPosition = seekPos;
            this._liveTimeout = liveTimeout;
            this._initialSeek = true;
            this._isPlaying = true;
            this._isAvailable = false;
            var streamname:String = "";
            this._streamname = url;
            this._streamtype = ((streamType)==LIVE) ? LIVE : ONDEMAND;
            Debug.getInstance().traceInfo(((((((("AkamaiHDCoreConnection[" + _id) + "].startPlayback: ") + this._streamtype) + " ") + this._startPosition) + " ") + this._streamname));
            this.makeConnection();
        }
        private function makeConnection():void{
            Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].makeConnection: startPos ") + this._startPosition));
            if (((!(_nc.connected)) || (this._secureConnect))){
                if (this._mediaAnalytics){
                    Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].MakeConnection1 MA: ") + this._isConnectionInfoCalled));
                    AnalyticsPluginLoader.setNetConnectionInfo(_nc, null);
                    this._isConnectionInfoCalled = true;
                };
                _nc.close();
                super.connectNetConnection(NetConnection, null);
            } else {
                if (this._mediaAnalytics){
                    Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].MakeConnection2 MA: ") + this._isConnectionInfoCalled));
                    if (!(this._isConnectionInfoCalled)){
                        AnalyticsPluginLoader.setNetConnectionInfo(_nc, null);
                    };
                    AnalyticsPluginLoader.setNetStreamInfo(_ns, this._streamname);
                    this._isConnectionInfoCalled = false;
                };
                _ns.play(this._streamname, this._startPosition);
            };
        }
        public function stopPlayback():void{
            Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].stopPlayback: ") + _ns));
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STOPPED, this));
            try {
                _ns.close();
            } catch(e:Error) {
                Debug.getInstance().traceError(((("AkamaiHDCoreConnection[" + _id) + "].stopPlayback ERROR: ") + e));
            };
            this._isPlaying = false;
            this._isAvailable = true;
            this._metricsTimer.stop();
        }
        public function pause():void{
            _ns.pause();
        }
        public function resume():void{
            _ns.resume();
        }
        public function seek(position:Number):void{
            Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].postion = ") + position));
            _ns.seek(position);
        }
        public function goLive():void{
            Debug.getInstance().traceInfo((("AkamaiHDCoreConnection[" + _id) + "].goLive: "));
            _ns.seek(this._liveTime);
        }
        public function setVolume(value:Number):void{
            this._currentVolume = value;
            try {
                _ns.volume = this._currentVolume;
            } catch(e:Error) {
            };
        }
        public function getVolume():Number{
            return (this._currentVolume);
        }
        public function setMaxBitrate(value:int):void{
            Debug.getInstance().traceDebug(((("AkamaiHDCoreConnection[" + _id) + "].setMaxBitrate: ") + value));
            this._maxBitrate = value;
            if (((_ns) && ((this._maxBitrate > -1)))){
                _ns.maximumBitrateAllowed = this._maxBitrate;
            };
        }
        public function close():void{
        }
        public function updateBuffer(value:int):void{
        }
        public function setVideoStats(videoStats:VideoStats):void{
            this._videoStats = videoStats;
            if (this._videoStats){
                this._videoStats.removeEventListener(Event.CHANGE, this.onVideoMetrics);
                this._videoStats.addEventListener(Event.CHANGE, this.onVideoMetrics);
                this.onVideoMetrics(new Event(Event.CHANGE));
            };
            Debug.getInstance().traceDebug(((("AkamaiHDCoreConnection[" + _id) + "].setVideoStats: ") + this._checkMetrics));
        }
        public function setMediaAnalytics(value:Boolean):void{
            Debug.getInstance().traceDebug(((("AkamaiHDCoreConnection[" + _id) + "].setMediaAnalytics: ") + value));
            this._mediaAnalytics = value;
        }
        private function onVideoMetrics(e:Event):void{
            this._checkMetrics = this._videoStats.showMetrics;
            Debug.getInstance().traceDebug(((("AkamaiHDCoreConnection[" + _id) + "].onMetrics: ") + this._checkMetrics));
            if (((this._checkMetrics) && (!(this._metricsTimer.running)))){
                this._metricsTimer.start();
            };
            if (!(this._checkMetrics)){
                this._metricsTimer.stop();
            };
        }
        private function updateVideoMetrics(e:TimerEvent):void{
            if (_ns){
                this._metricsObject.currentIndex = _ns.currentIndex;
                this._metricsObject.currentBitrate = Math.round(_ns.currentIndexBitrate);
                this._metricsObject.bwEstimate = (Math.round(_ns.estimatedCurrentBandwidth) + " kbps");
                this._metricsObject.expectedFPS = Math.round(_ns.nominalFPS);
                this._metricsObject.currentFPS = Math.round(_ns.currentFPS);
                this._metricsObject.avgDroppedFPS = Math.round(_ns.droppedFrames);
                this._metricsObject.curDroppedFPS = Math.round(_ns.droppedFPS);
                this._metricsObject.bufferLength = Math.round(_ns.bufferLength);
                this._metricsObject.bufferTime = Math.round(_ns.bufferTime);
                this._metricsObject.serverIP = ((_ns.edgeIP) ? _ns.edgeIP : "");
                this._videoStats.updateStats(this._metricsObject);
            };
        }
        private function connectedHandler():void{
            Debug.getInstance().traceDebug((("AkamaiHDCoreConnection[" + _id) + "].connectedHandler: Successfully connected"));
            Debug.getInstance().traceDebug(((("AkamaiHDCoreConnection[" + _id) + "].connectedHandler: startPos ") + this._startPosition));
            if (_ns){
                _ns = null;
            };
            super.attachLivePassStreamer(HDNetStream);
            _ns.client = this;
            if (this._maxBitrate > -1){
                _ns.maximumBitrateAllowed = this._maxBitrate;
            };
            if (this._streamtype == ONDEMAND){
            };
            _ns.addEventListener(HDEvent.NET_STATUS, this.onNetStatus);
            _ns.addEventListener(HDEvent.PROGRESS, this.onProgress);
            _ns.addEventListener(HDEvent.METADATA, this.onMetaData);
            _ns.addEventListener(HDEvent.STREAM_NOT_FOUND, this.onStreamNotFound);
            _ns.addEventListener(HDEvent.DEBUG, this.onHDDebug);
            _ns.addEventListener(HDEvent.COMPLETE, this.onComplete);
            _ns.addEventListener(HDEvent.ERROR, this.onError);
            _ns.addEventListener(HDEvent.SWITCH_START, this.onSwitchStart);
            _ns.addEventListener(HDEvent.SWITCH_COMPLETE, this.onSwitchComplete);
            _ns.addEventListener(HDEvent.IS_LIVE_STREAM, this.onLiveStream);
            _ns.addEventListener(HDEvent.IS_PLAYING_LIVE, this.onPlayingLive);
            _ns.addEventListener(HDEvent.BANDWIDTH, this.onBandwidth);
            _ns.addEventListener(HDEvent.SEEK, this.onSeek);
            _ns.addEventListener(HDEvent.DATA_MESSAGE, this.onDataMessage);
            if (this._mediaAnalytics){
                Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].connectedHandler MA: ") + this._isConnectionInfoCalled));
                if (!(this._isConnectionInfoCalled)){
                    AnalyticsPluginLoader.setNetConnectionInfo(_nc, null);
                };
                AnalyticsPluginLoader.setNetStreamInfo(_ns, this._streamname);
                this._isConnectionInfoCalled = false;
            };
            Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].connectedHandler play: ") + this._streamname));
            _ns.play(this._streamname, this._startPosition);
            this.setVolume(this._currentVolume);
        }
        private function netStatusHandler(e:NetStatusEvent):void{
            Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].netStatusHandler ") + e.info.code));
            switch (e.info.code){
                case "NetConnection.Connect.Rejected":
                    Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].netStatusHandler Rejected by server. Reason is ") + e.info.description));
                    super.reportNetStatusEvent(e);
                    break;
                case "NetConnection.Connect.Success":
                    this.connectedHandler();
                    break;
                default:
                    super.reportNetStatusEvent(e);
            };
        }
        private function onNetStatus(e:HDEvent):void{
            switch (e.data.code){
                case "NetStream.Play.Start":
                    Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].onNetStatus ") + e.data.code));
                    Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].maxIndexAvailableBitrate ") + _ns.maxIndexAvailableBitrate));
                    Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].isPlayingMBRcontent ") + _ns.isPlayingMBRcontent()));
                    this._isPlaying = true;
                    if (_ns.isPlayingMBRcontent()){
                        _ns.useFixedThrottleForSBR = false;
                    } else {
                        _ns.useFixedThrottleForSBR = true;
                    };
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.RENDITION_SWITCH, _ns.currentIndex));
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STARTED, this));
                    break;
                case "NetStream.Play.Stop":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STOPPED, this));
                    break;
                case "NetStream.Buffer.Full":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.BUFFER_FULL, this));
                    break;
                case "NetStream.Play.InsufficientBW":
                    break;
                case "NetStream.Failed":
                    break;
            };
        }
        private function onStreamNotFound(e:HDEvent):void{
            Debug.getInstance().traceInfo((("AkamaiHDCoreConnection[" + _id) + "].onStreamNotFound"));
            this.stopPlayback();
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, this));
        }
        private function onPlayingLive(e:HDEvent):void{
            Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].onPlayingLive ") + e.data));
        }
        private function onComplete(e:HDEvent):void{
            Debug.getInstance().traceInfo((("AkamaiHDCoreConnection[" + _id) + "].onComplete "));
        }
        private function onHDDebug(e:HDEvent):void{
        }
        private function onError(e:HDEvent):void{
            var desc:String;
            Debug.getInstance().traceInfo((("AkamaiHDCoreConnection[" + _id) + "].onError"));
            switch ((e.data as Number)){
                case 1:
                    desc = "STREAM NOT FOUND";
                    break;
                case 2:
                    desc = "TRACK NOT FOUND";
                    break;
                case 3:
                    desc = "SEEK OUT OF BOUNDS";
                    break;
                case 4:
                    desc = "AUTHENTICATION FAILED";
                    break;
                case 5:
                    desc = "DVR DISABLED";
                    break;
                case 6:
                    desc = "INVALID BITRATE TEST";
                    break;
                case 7:
                    desc = "RTMP FALLBACK";
                    break;
            };
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, desc));
        }
        private function onProgress(e:HDEvent):void{
            var videoTime:Object = new Object();
            videoTime.timeAsTimeCode = _ns.timeAsTimeCode;
            videoTime.streamLengthAsTimeCode = _ns.durationAsTimeCode;
            videoTime.time = _ns.time;
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_PROGRESS, videoTime));
            if (this._dvrTime == 1){
                this._dvrAvailable = (_ns.duration * 1000);
            } else {
                this._dvrAvailable = ((((_ns.duration * 1000) < this._dvrTime)) ? (_ns.duration * 1000) : this._dvrTime);
            };
            this._liveTime = (_ns.streamStartTime + (_ns.duration * 1000));
            this._minTime = (this._liveTime - this._dvrAvailable);
            this._currentTime = (_ns.streamStartTime + (_ns.time * 1000));
            dispatchEvent(new ConnectionEvent(ConnectionEvent.TIME_UPDATE, {
                minTime:this._minTime,
                maxTime:this._liveTime,
                currentTime:this._currentTime
            }));
            if ((((this._dvrTime > 0)) && ((this.count == 20)))){
                Debug.getInstance().traceInfo(((((((((("AkamaiHDCoreConnection[" + _id) + "].gotTime- nsTime:") + getDisplayTime(_ns.timeAsTimeCode)) + " min:") + getDisplayTime(this._minTime)) + " max:") + getDisplayTime(this._liveTime)) + " cur:") + getDisplayTime(this._currentTime)));
                Debug.getInstance().traceInfo(((((((("AkamaiHDCoreConnection[" + _id) + "].gotTime- initSeek:") + getDisplayTime((_ns.streamStartTime + (this._startPosition * 1000)))) + " start:") + getDisplayTime(_ns.streamStartTime)) + " ") + _ns.streamStartTime));
                this.count = 0;
            } else {
                this.count++;
            };
        }
        private function onMetaData(e:HDEvent):void{
            var propName:String;
            for (propName in e.data) {
            };
            dispatchEvent(new ConnectionEvent(ConnectionEvent.META_DATA, e.data));
        }
        private function onDataMessage(e:HDEvent):void{
            var obj:Object = e.data.value;
        }
        private function onSwitchStart(e:HDEvent):void{
            Debug.getInstance().traceInfo(((((("AkamaiHDCoreConnection[" + _id) + "].onSwitchStart ") + e.data["index"]) + " ") + e.data["reason"]));
            Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].maxIndexAvailableBitrate ") + _ns.maxIndexAvailableBitrate));
        }
        private function onSwitchComplete(e:HDEvent):void{
            Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].onSwitchComplete ") + (e.data as Number)));
            super.setCurrentBitrate(new uint(e.data));
            dispatchEvent(new ConnectionEvent(ConnectionEvent.RENDITION_SWITCH, (e.data as Number)));
        }
        private function onLiveStream(e:HDEvent):void{
            Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].onLiveStream ") + e.data));
        }
        private function onBandwidth(e:HDEvent):void{
            Debug.getInstance().traceInfo((((("AkamaiHDCoreConnection[" + _id) + "].onBandwidth ") + e.data.toString()) + " kbps"));
            (this._metricsObject.bwEstimate = (e.data.toString() + "kbps"));
        }
        private function onSeek(e:HDEvent):void{
            Debug.getInstance().traceInfo((((((("AkamaiHDCoreConnection[" + _id) + "].onSeek - seeking from ") + (e.data["seekFrom"] as Number)) + "s to ") + (e.data["seekTo"] as Number)) + "s"));
        }
        private function onXMPData(info:Object):void{
            var cueXML:XML;
            var xmpXML:XML = new XML(info.data);
            var xmpDM:Namespace = new Namespace("http://ns.adobe.com/xmp/1.0/DynamicMedia/");
            var rdf:Namespace = new Namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#");
            var cueFrameRateString:String = xmpXML..xmpDM::Tracks..rdf::Description.@xmpDM::frameRate;
            var cueFrameRate:Number = Number(cueFrameRateString.substr(1, cueFrameRateString.length));
            Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].onXMPData: frameRate for DVA Ticks divisor:") + cueFrameRate));
            var cuePointList:XMLList = xmpXML..xmpDM::markers.rdf::Seq.rdf::li;
            var len:int = cuePointList.length();
            Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].onXMPData: number of cuePoints:") + len));
            var i:int;
            while (i < len) {
                cueXML = cuePointList[i];
                Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].onXMPData: \tname:") + cueXML.@xmpDM::name));
                Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].onXMPData: \ttype:") + cueXML.@xmpDM::cuePointType));
                Debug.getInstance().traceInfo(((("AkamaiHDCoreConnection[" + _id) + "].onXMPData: \tstartTime:") + (cueXML.@xmpDM::startTime / cueFrameRate)));
                i++;
            };
        }
        public function get netStream():NetStream{
            return (_ns);
        }
        public function get id():String{
            return (_id);
        }
        public function get isPlaying():Boolean{
            return (this._isPlaying);
        }
        public function get isAvailable():Boolean{
            return (this._isAvailable);
        }
        public function get streamtype():String{
            return (this._streamtype);
        }
        public function get dvrAvailable():int{
            return (this._dvrAvailable);
        }
        public function get startPosition():Number{
            return (this._startPosition);
        }
        public function get recycledConnection():Boolean{
            return (_recycledConnection);
        }
        public function set recycledConnection(value:Boolean):void{
            (_recycledConnection = value);
        }
        public function startConvivaMonitorSession(streamInfo:StreamObject):void{
            super.startMonitor(streamInfo);
        }
        public function stopConvivaMonitorSession():void{
            super.stopMonitor();
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import flash.events.*;
    import flash.text.*;
    import flash.display.*;

    public class TimelineMarker extends MovieClip {

        private var _indicator:MovieClip;
        private var _eventName:String;
        private var _thumbURL:String;
        private var _time:Number;
        private var _toolTip:ToolTipTimeline;

        public function TimelineMarker(name:String, thumb:String, textFormat:TextFormat, time:Number, indicator:MovieClip){
            super();
            this._indicator = indicator;
            this._time = time;
            this._eventName = name;
            this._thumbURL = thumb;
            this._toolTip = ToolTipTimeline.createToolTip(this, textFormat, 0, 0.6, ToolTipTimeline.SQUARE_TIP);
            this.addEventListener(MouseEvent.MOUSE_OVER, this.showTip);
            this.addEventListener(MouseEvent.MOUSE_OUT, this.hideTip);
            this.addChild(this._indicator);
        }
        private function hideTip(e:MouseEvent):void{
            this._toolTip.removeTip();
        }
        private function showTip(e:MouseEvent):void{
            this._toolTip.addTip(this, this._eventName, "", this._indicator.x, (this._indicator.y - 8));
        }
        public function get time():Number{
            return (this._time);
        }
        public function get eventName():String{
            return (this._eventName);
        }
        public function get indicator():MovieClip{
            return (this._indicator);
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import flash.display.*;
    import flash.text.*;
    import flash.events.*;
    import flash.filters.*;
    import com.ibm.AS3util.*;

    public class ToolTipTimeline extends Sprite {

        public static const ROUND_TIP:String = "roundTip";
        public static const SQUARE_TIP:String = "squareTip";

        private static var OBO_TT:ToolTipTimeline;

        private var _adv:Boolean;
        private var _tipText:TextField;
        private var _tipColor:uint;
        private var _tipAlpha:Number;
        private var _format:TextFormat;
        private var _ds:DropShadowFilter;
        private var _root:DisplayObjectContainer;
        private var _userTip:String;
        private var _orgX:int;
        private var _orgY:int;

        public function ToolTipTimeline(func:Function, myRoot:DisplayObjectContainer, format:TextFormat, tipColor:uint=0xFFFFFF, tipAlpha:Number=1, tipShape:String="roundTip", advRendering:Boolean=true){
            super();
            if (!((func == makeInstance))){
                throw (new Error("ToolTip class must be instantiated with static method ToolTip.createToolTip() method."));
            };
            this._root = myRoot;
            this._tipColor = tipColor;
            this._tipAlpha = tipAlpha;
            this._userTip = tipShape;
            this._adv = advRendering;
            this._format = format;
            this._ds = new DropShadowFilter(3, 45, 0, 0.7, 2, 2, 1, 3);
            this.mouseEnabled = false;
        }
        public static function createToolTip(myRoot:DisplayObjectContainer, format:TextFormat, tipColor:uint=0xFFFFFF, tipAlpha:Number=1, tipShape:String="roundTip", advRendering:Boolean=true):ToolTipTimeline{
            if (OBO_TT == null){
                OBO_TT = ToolTipTimeline.makeInstance(myRoot, format, tipColor, tipAlpha, tipShape, advRendering);
            };
            return (OBO_TT);
        }
        private static function makeInstance(myRoot:DisplayObjectContainer, format:TextFormat, tipColor:uint=0xFFFFFF, tipAlpha:Number=1, tipShape:String="roundTip", advRendering:Boolean=true):ToolTipTimeline{
            return (new ToolTipTimeline(arguments.callee, myRoot, format, tipColor, tipAlpha, tipShape, advRendering));
        }

        public function addTip(myRoot:MovieClip, words:String, thumbURL:String, xPos:int, yPos:int):void{
            var tipShape:Array;
            this._root = myRoot;
            this._root.addChild(this);
            var imageHolder:MovieClip = new MovieClip();
            if (thumbURL != ""){
                ImageLoader.loadImage(thumbURL, imageHolder, 96, 56, null);
            };
            this._tipText = new TextField();
            this._tipText.mouseEnabled = false;
            this._tipText.selectable = false;
            this._tipText.defaultTextFormat = this._format;
            this._tipText.antiAliasType = ((this._adv) ? AntiAliasType.ADVANCED : AntiAliasType.NORMAL);
            this._tipText.width = 96;
            this._tipText.height = 1;
            this._tipText.autoSize = TextFieldAutoSize.LEFT;
            this._tipText.embedFonts = true;
            this._tipText.multiline = true;
            this._tipText.wordWrap = true;
            this._tipText.text = words.replace(/\\n/g, "\n");
            this._tipText.height = (this._tipText.textHeight + 4);
            var w:Number = 96;
            var h:Number = (this._tipText.textHeight + ((thumbURL)!="") ? 64 : 12);
            switch (this._userTip){
                case ROUND_TIP:
                    tipShape = [[-4, -8], [0, 0], [4, -8], [((w / 2) + 2), -8], [((w / 2) + 8), -8, ((w / 2) + 8), -14], [((w / 2) + 8), -((h + 6))], [((w / 2) + 8), -((h + 12)), ((w / 2) + 2), -((h + 12))], [-(((w / 2) + 2)), -((h + 12))], [-(((w / 2) + 8)), -((h + 12)), -(((w / 2) + 8)), -((h + 6))], [-(((w / 2) + 8)), -14], [-(((w / 2) + 8)), -8, -(((w / 2) + 2)), -8], [-(((w / 2) + 2)), -8]];
                    break;
                case SQUARE_TIP:
                    tipShape = [[-(((w / 2) + 5)), -16], [-(((w / 2) + 5)), -(((18 + h) + 4))], [((w / 2) + 5), -(((18 + h) + 4))], [((w / 2) + 5), -16], [6, -16], [0, 0], [-6, -16], [-(((w / 2) + 5)), -16]];
                    break;
                default:
                    throw (new Error("Undefined tool tip shape in ToolTip!"));
            };
            var len:int = tipShape.length;
            this.graphics.lineStyle(1, 39679, 0.7, true);
            this.graphics.beginFill(this._tipColor, this._tipAlpha);
            var i:int;
            while (i < len) {
                if (i == 0){
                    this.graphics.moveTo(tipShape[i][0], tipShape[i][1]);
                } else {
                    if (tipShape[i].length == 2){
                        this.graphics.lineTo(tipShape[i][0], tipShape[i][1]);
                    } else {
                        if (tipShape[i].length == 4){
                            this.graphics.curveTo(tipShape[i][0], tipShape[i][1], tipShape[i][2], tipShape[i][3]);
                        };
                    };
                };
                i++;
            };
            this.graphics.endFill();
            this.x = xPos;
            this.y = yPos;
            var owner:TimelineMarker = (this._root as TimelineMarker);
            Debug.getInstance().traceDebug(((((((("ToolTip.addTip: " + words) + " ") + owner.eventName) + " ") + this.x) + " ") + this.y));
            this.filters = [this._ds];
            this._tipText.x = Math.round(-((w / 2)));
            this._orgX = this._tipText.x;
            this._tipText.y = Math.round(-((h + 11)));
            this._orgY = this._tipText.y;
            imageHolder.x = this._tipText.x;
            imageHolder.y = (this._tipText.y + this._tipText.height);
            this.addChild(this._tipText);
            if (thumbURL != ""){
                this.addChild(imageHolder);
            };
        }
        private function onTipMove(me:MouseEvent):void{
            this.x = Math.round(me.stageX);
            this.y = Math.round((me.stageY - 2));
            if ((this.y - this.height) < 0){
                this.scaleY = (this._tipText.scaleY = -1);
                this._tipText.y = ((this._userTip)==ROUND_TIP) ? -18 : -16;
                this.y = Math.round((me.stageY + 5));
            } else {
                this.scaleY = (this._tipText.scaleY = 1);
                this._tipText.y = this._orgY;
            };
            if ((this.x - (this.width - 18)) < 0){
                if (this._userTip == ROUND_TIP){
                    this.scaleX = (this._tipText.scaleX = -1);
                    this._tipText.x = 5;
                };
            } else {
                this.scaleX = (this._tipText.scaleX = 1);
                this._tipText.x = this._orgX;
            };
            me.updateAfterEvent();
        }
        public function removeTip():void{
            this.removeChild(this._tipText);
            this.graphics.clear();
            this._root.removeChild(this);
        }
        public function set tipShape(shape:String):void{
            if (((!((shape == ROUND_TIP))) && (!((shape == SQUARE_TIP))))){
                throw (new Error((("Invalid tip shape \"" + shape) + "\" specified at ToolTip.tipShape.")));
            };
            this._userTip = shape;
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import flash.utils.*;
    import flash.events.*;
    import com.ibm.AS3util.*;
    import octoshape.*;
    import flash.media.*;
    import flash.net.*;

    public class OctoshapeConnection extends ConvivaMediaConnection implements IMediaServerConnection {

        private var _os:OctoshapeSystemBase;
        private var _osStreamPlayerLive:StreamPlayerLive;
        private var _currentVolume:Number;
        private var _authInfo:String;
        private var _authHash:String;
        private var _startPosition:Number;
        private var _metricsTimer:Timer;
        private var _checkMetrics:Boolean;
        private var _metricsObject:Object;
        private var _videoStats:VideoStats;
        private var _isPlaying:Boolean;
        private var _isAvailable:Boolean;
        private var _streamtype:String;
        private var _currentTime:Number = 0;
        private var _liveTime:Number = 0;
        private var _minTime:Number = 0;
        private var _dvrAvailable:int;

        public function OctoshapeConnection(id:String, streamInfo:StreamObject):void{
            super(id, streamInfo);
            this._isPlaying = false;
            this._isAvailable = true;
            this._metricsObject = new Object();
            this._metricsTimer = new Timer(1000);
            this._metricsTimer.addEventListener(TimerEvent.TIMER, this.updateVideoMetrics);
        }
        public function startPlayback(uri:String, streamType:String, seekPos:Number, dvrTime:int=0, buffer:int=3, liveTimeout:int=3600, bitrate:Number=0):void{
            this._streamtype = streamType;
            this._dvrAvailable = dvrTime;
            this._startPosition = seekPos;
            var authParams:Array = uri.split(";");
            if (authParams.length > 1){
                this._authInfo = authParams[1].substring((authParams[1].indexOf("=") + 1), authParams[1].length);
                this._authHash = authParams[2].substring((authParams[2].indexOf("=") + 1), authParams[2].length);
            };
            Debug.getInstance().traceInfo(("OctoshapeConnection.startOctoshapePlayback: " + uri));
            if (!(this._os)){
                this.initOctoshape();
            };
            this._osStreamPlayerLive = this._os.liveStream(uri, true, false);
            this._osStreamPlayerLive.addEventListener(ProblemEvent.PROBLEM, this.octoshapeStreamProblem);
            this._osStreamPlayerLive.addEventListener(UrlEvent.URL, this.octoshapeGotUrl);
            this._osStreamPlayerLive.addEventListener(AuthRequiredEvent.AUTHREQUIRED, this.octoshapeAuthRequired);
            this._osStreamPlayerLive.addEventListener(OctoProgressEvent.PROGRESS, this.octoshapeProgress);
            this._osStreamPlayerLive.addEventListener(TimeEventLive.TYPE, this.gotTime);
            this._osStreamPlayerLive.addEventListener(MetaDataEvent.TYPE, this.metadataHandler);
            this.setVolume(0);
            Debug.getInstance().traceInfo(("OctoshapeConnection.startOctoshapePlayback: " + seekPos));
            if (seekPos < 0){
                this._osStreamPlayerLive.playLive();
            } else {
                this._osStreamPlayerLive.playPosition(seekPos);
            };
            this._isPlaying = true;
            this._isAvailable = false;
        }
        public function setVideoStats(videoStats:VideoStats):void{
            this._videoStats = videoStats;
            if (this._videoStats){
                this._videoStats.removeEventListener(Event.CHANGE, this.onVideoMetrics);
                this._videoStats.addEventListener(Event.CHANGE, this.onVideoMetrics);
                this.onVideoMetrics(new Event(Event.CHANGE));
            };
            Debug.getInstance().traceDebug(((("AkamaiHDCoreConnection[" + _id) + "].setVideoStats: ") + this._checkMetrics));
        }
        private function onVideoMetrics(e:Event):void{
            this._checkMetrics = this._videoStats.showMetrics;
            Debug.getInstance().traceDebug(((("AkamaiHDCoreConnection[" + _id) + "].onMetrics: ") + this._checkMetrics));
            if (((this._checkMetrics) && (!(this._metricsTimer.running)))){
                this._metricsTimer.start();
            };
            if (!(this._checkMetrics)){
                this._metricsTimer.stop();
            };
        }
        private function updateVideoMetrics(e:TimerEvent):void{
            if (_ns){
                this._metricsObject.currentIndex = "";
                this._metricsObject.currentBitrate = "";
                this._metricsObject.bwEstimate = "";
                this._metricsObject.expectedFPS = "";
                this._metricsObject.currentFPS = Math.round(_ns.currentFPS);
                this._metricsObject.avgDroppedFPS = "";
                this._metricsObject.curDroppedFPS = "";
                this._metricsObject.bufferLength = Math.round(_ns.bufferLength);
                this._metricsObject.bufferTime = _ns.bufferTime;
                this._metricsObject.serverIP = "";
                this._videoStats.updateStats(this._metricsObject);
            };
        }
        private function initOctoshape():void{
            this.initNetconnection();
            var os:OctoshapeSystemOph = new OctoshapeSystemOph();
            if (!(os.isInstalled())){
                this._os = new OctoshapeSystemOcto(false);
            } else {
                this._os = os;
            };
            this._os.addEventListener(ProblemEvent.PROBLEM, this.octoshapeSystemProblem);
            Debug.getInstance().traceInfo(((("OctoshapeConnection.initOctoshape: version=" + this._os) + " ") + this._os.version()));
            this._os.start();
        }
        public function stopPlayback():void{
            Debug.getInstance().traceInfo(("OctoshapeConnection.stopPlayback: " + this._osStreamPlayerLive));
            if (this._osStreamPlayerLive){
                this._osStreamPlayerLive.playAbort();
                this._osStreamPlayerLive.removeEventListener(ProblemEvent.PROBLEM, this.octoshapeStreamProblem);
                this._osStreamPlayerLive.removeEventListener(UrlEvent.URL, this.octoshapeGotUrl);
                this._osStreamPlayerLive.removeEventListener(AuthRequiredEvent.AUTHREQUIRED, this.octoshapeAuthRequired);
                this._osStreamPlayerLive.close();
                this._osStreamPlayerLive = null;
            };
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STOPPED, this));
            if (_ns){
                _ns.pause();
                this.removeNetstream();
            };
            if (_nc){
                this.removeNetconnection();
            };
            this._isPlaying = false;
            this._isAvailable = true;
        }
        public function pause():void{
            _ns.pause();
        }
        public function resume():void{
            _ns.resume();
        }
        public function seek(time:Number):void{
            Debug.getInstance().traceDebug(((((("OctoshapeConnection.seek: " + time) + " ") + this._liveTime) + " ") + this._minTime));
            if (time == 0){
                this._osStreamPlayerLive.playLive();
            } else {
                this._osStreamPlayerLive.playPosition(time);
            };
        }
        public function goLive():void{
            this._osStreamPlayerLive.playLive();
        }
        public function setVolume(value:Number):void{
            this._currentVolume = value;
            var st:SoundTransform = new SoundTransform(this._currentVolume, 0);
            try {
                _ns.soundTransform = st;
            } catch(e:Error) {
            };
        }
        public function setMaxBitrate(value:int):void{
        }
        public function getVolume():Number{
            return (this._currentVolume);
        }
        public function close():void{
        }
        public function setMediaAnalytics(value:Boolean):void{
        }
        private function initNetconnection():void{
            _nc = new NetConnection();
            _nc.addEventListener(NetStatusEvent.NET_STATUS, this.octoshapeEventHandler);
            _nc.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.octoshapeEventHandler);
            super.connectNetConnection(NetConnection, null);
        }
        private function initNetstream():void{
            super.attachLivePassStreamer(NetStream);
            _ns.bufferTime = 2;
            _ns.addEventListener(AsyncErrorEvent.ASYNC_ERROR, this.octoshapeEventHandler);
            _ns.addEventListener(NetStatusEvent.NET_STATUS, this.octoshapeNetStatus);
            _ns.addEventListener(IOErrorEvent.IO_ERROR, this.octoshapeEventHandler);
            _ns.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.octoshapeEventHandler);
            _ns.client = this;
        }
        private function removeNetstream():void{
            if (_ns != null){
                _ns.removeEventListener(AsyncErrorEvent.ASYNC_ERROR, this.octoshapeEventHandler);
                _ns.removeEventListener(NetStatusEvent.NET_STATUS, this.octoshapeNetStatus);
                _ns.removeEventListener(IOErrorEvent.IO_ERROR, this.octoshapeEventHandler);
                _ns.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, this.octoshapeEventHandler);
                _ns.close();
                _ns = null;
            };
        }
        private function removeNetconnection():void{
            if (_nc != null){
                _nc.removeEventListener(NetStatusEvent.NET_STATUS, this.octoshapeEventHandler);
                _nc.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, this.octoshapeEventHandler);
                _nc.close();
                _nc = null;
            };
        }
        private function octoshapeAuthRequired(e:AuthRequiredEvent):void{
            Debug.getInstance().traceInfo(((((("OctoshapeConnection.octoshapeAuthRequired: " + e.authid()) + " | ") + this._authInfo) + " | ") + this._authHash));
            this._osStreamPlayerLive.setAuthorization(this._authInfo, this._authHash);
        }
        private function octoshapeEventHandler(e:Event):void{
            Debug.getInstance().traceInfo(("OctoshapeConnection.octoshapeEventHandler: " + e));
        }
        private function octoshapeNetStatus(e:NetStatusEvent):void{
            Debug.getInstance().traceInfo(((("OctoshapeConnection.octoshapeNetStatus: " + e.info.code) + " | ") + e.info.level));
            if (e.info.code == "NetStream.Play.Start"){
                Debug.getInstance().traceInfo("OctoshapeConnection.playbackStarted");
                dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STARTED, {
                    cdn:ConnectionManager.CDN_OCTOSHAPE,
                    length:-1
                }));
                this._isPlaying = true;
            } else {
                if (e.info.code == "NetStream.Buffer.Full"){
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.BUFFER_FULL, this));
                } else {
                    if (e.info.code == "NetStream.Buffer.Empty"){
                    } else {
                        if (e.info.code == "NetStream.Play.UnpublishNotify"){
                        } else {
                            if (e.info.level == "error"){
                                super.reportNetStatusEvent(e);
                            } else {
                                if (e.info.code == "NetStream.Play.InsufficientBW"){
                                };
                            };
                        };
                    };
                };
            };
        }
        private function octoshapeSystemProblem(e:ProblemEvent):void{
            Debug.getInstance().traceInfo(("OctoshapeConnection.octoshapeSystemProblem: " + e.toString()));
            if (e.hasProblemIds("install", "canceled", "distrusted", "pluginbasic")){
                dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, "octoshape_rejected"));
            } else {
                if (e.hasProblemIds("notsupported", "install", "pluginbasic")){
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, "octoshape_rejected"));
                } else {
                    if (e.hasProblemIds("pluginbasic", "connect", "security")){
                        dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, "octoshape_rejected"));
                    } else {
                        if (e.hasProblemIds("pluginbasic", "attempt", "install", "normal")){
                            dispatchEvent(new ConnectionEvent(ConnectionEvent.OCTOSHAPE_ASK, "octoshape_ask"));
                        } else {
                            if (e.hasProblemIds("install", "pluginbasic", "canceled")){
                                dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, "rejected"));
                            } else {
                                if (e.hasProblemIds("pluginbasic", "ready", "normal")){
                                    dispatchEvent(new ConnectionEvent(ConnectionEvent.OCTOSHAPE_INSTALLED, "octoshape_installed"));
                                } else {
                                    if (e.hasProblemIds("pluginbasic", "connect", "rejected", "eula", "refused")){
                                        dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, "rejected"));
                                    } else {
                                        if (e.hasProblemIds("pluginbasic", "install", "notsupported")){
                                            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, "octoshape_rejected"));
                                        } else {
                                            if (e.hasProblemIds("weberror", "pluginbasic", "detection")){
                                                dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, "octoshape_plugin"));
                                            } else {
                                                if (e.hasProblemIds("nostream")){
                                                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, "other"));
                                                } else {
                                                    if (!(e.hasProblemIds("normal"))){
                                                        dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, "other"));
                                                    } else {
                                                        dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, e.toString()));
                                                    };
                                                };
                                            };
                                        };
                                    };
                                };
                            };
                        };
                    };
                };
            };
        }
        private function octoshapeStreamProblem(e:ProblemEvent):void{
            Debug.getInstance().traceInfo(("OctoshapeConnection.octoshapeStreamProblem: " + e.toString()));
            if (e.hasProblemIds("normal")){
                if (e.hasProblemIds("endofstream")){
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_COMPLETE, ""));
                };
            } else {
                if (e.hasProblemIds("protoerr", "localerr")){
                    dispatchEvent(new VideoControlEvent(VideoControlEvent.SCRUB_ERROR, this._currentTime));
                } else {
                    if (e.hasProblemIds("authexpired")){
                        dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, "expired"));
                    } else {
                        if (e.hasProblemIds("noresponse", "link")){
                            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, "octoshape_link_error"));
                        } else {
                            if (e.hasProblemIds("nompever", "mplayer", "notconnected")){
                                dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, "octoshape_link_error"));
                            } else {
                                dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, e.toString()));
                            };
                        };
                    };
                };
            };
        }
        private function octoshapeGotUrl(e:UrlEvent):void{
            Debug.getInstance().traceInfo(("OctoshapeConnection.octoshapeGotUrl: " + e.url));
            this.removeNetstream();
            this.initNetconnection();
            this.initNetstream();
            _ns.play(e.url);
        }
        private function octoshapeProgress(e:OctoProgressEvent):void{
        }
        private function gotTime(e:TimeEventLive):void{
            var near:Number;
            if (((!(((e.maxLive - this._dvrAvailable) == this._minTime))) || (!((e.maxLive == this._liveTime))))){
                this._currentTime = e.current;
                this._liveTime = e.maxLive;
                this._minTime = (this._liveTime - this._dvrAvailable);
                dispatchEvent(new ConnectionEvent(ConnectionEvent.TIME_UPDATE, {
                    minTime:this._minTime,
                    maxTime:this._liveTime,
                    currentTime:this._currentTime
                }));
            };
        }
        private function metadataHandler(e:MetaDataEvent):void{
            var propName:String;
            Debug.getInstance().traceDebug(((("OctoshapeConnection[" + _id) + "].metadataHandler: ") + e.xml));
            for (propName in e.data) {
                Debug.getInstance().traceDebug(((((("OctoshapeConnection[" + _id) + "].metadataHandler: ") + propName) + " = ") + e.data[propName]));
            };
        }
        public function onMetaData(info:Object):void{
            var propName:String;
            for (propName in info) {
                Debug.getInstance().traceDebug(((((("OctoshapeConnection[" + _id) + "].onMetaData: ") + propName) + " = ") + info[propName]));
            };
            dispatchEvent(new ConnectionEvent(ConnectionEvent.META_DATA, info));
        }
        public function onCuePoint(info:Object):void{
        }
        public function updateBuffer(value:int):void{
        }
        public function getMetrics(valueBW:Boolean, valueFPS:Boolean):void{
            Debug.getInstance().traceDebug((("OctoshapeConnection[" + _id) + "].getMetrics: "));
        }
        public function get netStream():NetStream{
            return (_ns);
        }
        public function get id():String{
            return (_id);
        }
        public function get isPlaying():Boolean{
            return (this._isPlaying);
        }
        public function get isAvailable():Boolean{
            return (this._isAvailable);
        }
        public function get streamtype():String{
            return (this._streamtype);
        }
        public function get dvrAvailable():int{
            return (this._dvrAvailable);
        }
        public function get startPosition():Number{
            return (this._startPosition);
        }
        public function get recycledConnection():Boolean{
            return (_recycledConnection);
        }
        public function set recycledConnection(value:Boolean):void{
            _recycledConnection = value;
        }
        public function startConvivaMonitorSession(streamInfo:StreamObject):void{
            super.startMonitor(streamInfo);
        }
        public function stopConvivaMonitorSession():void{
            super.stopMonitor();
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import com.akamai.net.*;
    import org.openvideoplayer.events.*;
    import org.openvideoplayer.net.*;
    import flash.events.*;
    import flash.utils.*;
    import org.openvideoplayer.parsers.*;
    import com.ibm.AS3util.*;
    import com.akamai.playeranalytics.*;
    import org.openvideoplayer.net.dynamicstream.*;
    import flash.net.*;

    public class LimelightFMSConnectionMBR extends ConvivaMediaConnection implements IMediaServerConnection {

        public const INIT_BUFFER:int = 3;
        public const INIT_LIVE_TIMEOUT:int = 3600;
        public const LIVE:String = "live";
        public const ONDEMAND:String = "ondemand";

        private var _bytesLoaded:Number;
        private var _currentVolume:Number;
        private var _bitrate:Number;
        private var _startPosition:Number;
        private var _initialSeek:Boolean;
        private var _isPlaying:Boolean;
        private var _isAvailable:Boolean;
        private var _bandwidth:String;
        private var _latency:String;
        private var _metricsTimer:Timer;
        private var _checkMetrics:Boolean;
        private var _metricsObject:Object;
        private var _videoStats:VideoStats;
        private var _mediaAnalytics:Boolean = false;
        private var _isConnectionInfoCalled:Boolean;
        private var _akBoss:AkamaiBOSS;
        private var _timeRemaining:uint;
        private var _buffer:int;
        private var _liveTimeout:int;
        private var _secureConnect:Boolean;
        private var _securePlay:Boolean;
        private var _connectParams:String;
        private var _playParams:String;
        private var _dynamicSmilParser:DynamicSmilParser;
        private var _dsi:DynamicStreamItem;
        private var _maxBitrate:int = -1;
        private var _hostname:String;
        private var _streamname;
        private var _streamtype:String;
        private var _dvrAvailable:int;

        public function LimelightFMSConnectionMBR(id:String, streamInfo:StreamObject):void{
            super(id, streamInfo);
            this._isPlaying = false;
            this._isAvailable = true;
            _nc = new AkamaiConnection();
            _nc.addEventListener(OvpEvent.ERROR, this.onError);
            _nc.addEventListener(NetStatusEvent.NET_STATUS, this.netStatusHandler);
            _nc.addEventListener(OvpEvent.BANDWIDTH, this.bandwidthHandler);
            this._metricsObject = new Object();
            this._metricsTimer = new Timer(1000);
            this._metricsTimer.addEventListener(TimerEvent.TIMER, this.updateVideoMetrics);
        }
        public function startPlayback(url:String, streamType:String, seekPos:Number, dvrTime:int=0, buffer:int=3, liveTimeout:int=3600, bitrate:Number=0):void{
            var temp:Array;
            var x:Number;
            var streamURL:Array = String(url).split("?");
            this._streamtype = streamType;
            this._secureConnect = (((streamURL[1] > 0)) ? true : false);
            this._bitrate = bitrate;
            this._startPosition = ((seekPos)==-1) ? -2 : seekPos;
            this._buffer = buffer;
            this._liveTimeout = liveTimeout;
            this._initialSeek = (((this._startPosition > 0)) ? true : false);
            this._isPlaying = true;
            this._isAvailable = false;
            var hostname:String = "";
            var streamname:String = "";
            if (String(streamURL[0]).match(".xml")){
                this._akBoss = new AkamaiBOSS(_id);
                this._akBoss.addEventListener(ConnectionEvent.BOSS_DATA, this.bossDataHandler);
                this._akBoss.loadBoss(streamURL[0]);
            } else {
                temp = streamURL[0].split("/");
                if (temp[0].indexOf("rtmp") == 0){
                    temp.splice(0, 2);
                };
                if (temp[(temp.length - 1)].lastIndexOf(".flv") > -1){
                    temp[(temp.length - 1)] = temp[(temp.length - 1)].substring(0, (temp[(temp.length - 1)].length - 4));
                };
                hostname = ((temp[0] + "/") + temp[1]);
                if (temp.length > 3){
                    x = 2;
                    while (x < temp.length) {
                        streamname = (streamname + temp[x]);
                        if (x < (temp.length - 1)){
                            streamname = (streamname + "/");
                        };
                        x++;
                    };
                } else {
                    streamname = temp[(temp.length - 1)];
                };
                if (temp[(temp.length - 1)].lastIndexOf(".smil") > -1){
                    this._dynamicSmilParser = new DynamicSmilParser();
                    this._dynamicSmilParser.addEventListener(OvpEvent.PARSED, this.onSmilParsed);
                    this._dynamicSmilParser.addEventListener(OvpEvent.ERROR, this.onSmilError);
                    this._dynamicSmilParser.addEventListener(OvpEvent.LOADED, this.onSmilLoaded);
                    this._dynamicSmilParser.load(streamURL[0]);
                    return;
                };
                this._streamname = streamname;
                Debug.getInstance().traceInfo(((((((("LimelightFMSConnectionMBR[" + _id) + "].startPlayback: ") + hostname) + " | ") + this._streamtype) + " | ") + this._streamname));
                this.finishPlayback(hostname, this._secureConnect);
            };
        }
        private function finishPlayback(hostname:String, secure:Boolean):void{
            var hostname:* = hostname;
            var secure:* = secure;
            Debug.getInstance().traceInfo(((((("LimelightFMSConnectionMBR[" + _id) + "].finishplayback: ") + !((this._hostname == hostname))) + " ") + this._secureConnect));
            if (((((!((this._hostname == hostname))) || (!(_ns)))) || (this._secureConnect))){
                _nc.close();
                this._hostname = hostname;
                if (this._mediaAnalytics){
                    Debug.getInstance().traceInfo(((("LimelightFMSConnectionMBR[" + _id) + "].finishplayback1 MA: ") + this._isConnectionInfoCalled));
                    AnalyticsPluginLoader.setNetConnectionInfo(_nc, this._hostname);
                    this._isConnectionInfoCalled = true;
                };
                _nc.connectionAuth = this._connectParams;
                super.connectNetConnection(AkamaiConnection, this._hostname);
            } else {
                try {
                    _ns.maxBufferLength = this._buffer;
                    if (this._securePlay){
                        _ns.liveStreamAuthParams = this._playParams;
                    };
                    if (this._mediaAnalytics){
                        Debug.getInstance().traceInfo(((("LimelightFMSConnectionMBR[" + _id) + "].finishplayback2 MA: ") + this._isConnectionInfoCalled));
                        if (!(this._isConnectionInfoCalled)){
                            AnalyticsPluginLoader.setNetConnectionInfo(_nc, this._hostname);
                        };
                        AnalyticsPluginLoader.setNetStreamInfo(_ns, this._streamname);
                        this._isConnectionInfoCalled = false;
                    };
                    _ns.play(this._streamname);
                } catch(e:Error) {
                    _nc.close();
                    _hostname = hostname;
                    super.connectNetConnection(AkamaiConnection, _hostname);
                };
            };
        }
        private function bossDataHandler(e:ConnectionEvent):void{
            this._streamname = e.info.streamName;
            this._streamtype = ((e.info.isLive) ? this.LIVE : this.ONDEMAND);
            this._secureConnect = ((!((e.info.connectionAuth == null))) ? true : false);
            this._connectParams = e.info.connectionAuth;
            this._securePlay = ((!((e.info.playAuth == null))) ? true : false);
            this._playParams = e.info.playAuth;
            this.finishPlayback(e.info.hostName, this._secureConnect);
        }
        public function stopPlayback():void{
            Debug.getInstance().traceInfo(((((("LimelightFMSConnectionMBR[" + _id) + "].stopPlayback: ") + _nc.isLive) + " ") + _ns));
            try {
                _ns.close();
            } catch(e:Error) {
                Debug.getInstance().traceError(((("LimelightFMSConnectionMBR[" + _id) + "].stopPlayback ERROR: ") + e));
            };
            this._isPlaying = false;
            this._isAvailable = true;
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STOPPED, this));
        }
        public function pause():void{
            _ns.pause();
        }
        public function resume():void{
            _ns.resume();
        }
        public function seek(position:Number):void{
            _ns.seek(position);
        }
        public function goLive():void{
        }
        public function updateBuffer(value:int):void{
            _ns.maxBufferLength = value;
        }
        public function setVolume(value:Number):void{
            this._currentVolume = value;
            try {
                _ns.volume = this._currentVolume;
            } catch(e:Error) {
            };
        }
        public function getVolume():Number{
            return (this._currentVolume);
        }
        public function setMaxBitrate(value:int):void{
            var bandwidthRule:BandwidthRuleEvents;
            this._maxBitrate = value;
            if (_ns){
                bandwidthRule = new BandwidthRuleEvents(_ns.metricsProvider, this._maxBitrate);
                _ns.clearRules();
                _ns.addRule(bandwidthRule);
                _ns.addRule(new FrameDropRule(_ns.metricsProvider));
                _ns.addRule(new BufferRule(_ns.metricsProvider));
            };
        }
        public function close():void{
        }
        public function setVideoStats(videoStats:VideoStats):void{
            this._videoStats = videoStats;
            if (this._videoStats){
                this._videoStats.removeEventListener(Event.CHANGE, this.onVideoMetrics);
                this._videoStats.addEventListener(Event.CHANGE, this.onVideoMetrics);
                this.onVideoMetrics(new Event(Event.CHANGE));
            };
            Debug.getInstance().traceDebug(((("LimelightFMSConnectionMBR[" + _id) + "].setVideoStats: ") + this._checkMetrics));
        }
        public function setMediaAnalytics(value:Boolean):void{
            Debug.getInstance().traceDebug(((("LimelightFMSConnectionMBR[" + _id) + "].setMediaAnalytics: ") + value));
            this._mediaAnalytics = value;
        }
        private function onSmilLoaded(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((("LimelightFMSConnectionMBR[" + _id) + "].onSmilLoaded: ") + e.toString()));
        }
        private function onSmilError(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((("LimelightFMSConnectionMBR[" + _id) + "].onSmilError: ") + e.data.errorDescription));
        }
        private function onSmilParsed(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((("LimelightFMSConnectionMBR[" + _id) + "].onSmilParsed: ") + e.toString()));
            this._dsi = this._dynamicSmilParser.dsi;
            this._streamname = this._dsi;
            Debug.getInstance().traceDebug(((("LimelightFMSConnectionMBR[" + _id) + "].onSmilParsed - hostname: ") + this._dynamicSmilParser.hostName));
            Debug.getInstance().traceDebug(((("LimelightFMSConnectionMBR[" + _id) + "].onSmilParsed - dsi: ") + this._dsi));
            this.finishPlayback(this._dynamicSmilParser.hostName, false);
        }
        private function onVideoMetrics(e:Event):void{
            this._checkMetrics = this._videoStats.showMetrics;
            Debug.getInstance().traceDebug(((("LimelightFMSConnectionMBR[" + _id) + "].onMetrics: ") + this._checkMetrics));
            if (((this._checkMetrics) && (!(this._metricsTimer.running)))){
                this._metricsTimer.start();
            };
            if (!(this._checkMetrics)){
                this._metricsTimer.stop();
            };
        }
        private function updateVideoMetrics(e:TimerEvent):void{
            if (_ns){
                this._metricsObject.currentIndex = _ns.metricsProvider.currentIndex;
                this._metricsObject.currentBitrate = Math.round(_ns.currentStreamBitRate);
                this._metricsObject.bwEstimate = (Math.round(_ns.metricsProvider.averageMaxBandwidth) + " kbps");
                this._metricsObject.expectedFPS = Math.round(_ns.metricsProvider.expectedFPS);
                this._metricsObject.currentFPS = Math.round(_ns.currentFPS);
                this._metricsObject.avgDroppedFPS = Math.round(_ns.metricsProvider.averageDroppedFPS);
                this._metricsObject.curDroppedFPS = Math.round(_ns.metricsProvider.droppedFPS);
                this._metricsObject.bufferLength = Math.round(_ns.metricsProvider.bufferLength);
                this._metricsObject.bufferTime = Math.round(_ns.metricsProvider.bufferTime);
                this._metricsObject.targetBufferTime = Math.round(_ns.metricsProvider.targetBufferTime);
                this._metricsObject.serverIP = _nc.serverIPaddress;
                this._videoStats.updateStats(this._metricsObject);
            };
        }
        private function connectedHandler():void{
            var stream:Object;
            Debug.getInstance().traceDebug(((((("LimelightFMSConnectionMBR[" + _id) + "].connectedHandler: Successfully connected using ") + _nc.actualProtocol) + " on port ") + _nc.actualPort));
            if (_ns){
                _ns.removeEventListener(NetStatusEvent.NET_STATUS, this.netStreamStatusHandler);
                _ns = null;
            };
            super.attachLivePassStreamer(AkamaiDynamicNetStream);
            if (this._dynamicSmilParser){
                for each (stream in this._dynamicSmilParser.dsi.streams) {
                    (_nc as AkamaiConnection).callFCSubscribe((stream.name as String).split("?")[0].toString());
                };
            } else {
                (_nc as AkamaiConnection).callFCSubscribe(this._streamname);
            };
            _ns.client = this;
            this.setMaxBitrate(this._maxBitrate);
            if (this._streamtype == this.LIVE){
                _ns.metricsProvider.optimizeForLivebandwidthEstimate = true;
            };
            _ns.addEventListener(OvpEvent.PROGRESS, this.progressHandler);
            _ns.addEventListener(NetStatusEvent.NET_STATUS, this.netStreamStatusHandler);
            _ns.addEventListener(OvpEvent.COMPLETE, this.completeHandler);
            _ns.addEventListener(OvpEvent.NETSTREAM_METADATA, this.metadataHandler);
            _ns.addEventListener(OvpEvent.STREAM_LENGTH, this.streamLengthHandler);
            _ns.addEventListener(OvpEvent.ERROR, this.onNetstreamError);
            _ns.addEventListener(OvpEvent.DATA_MESSAGE, this.onDataMessage);
            _ns.addEventListener(OvpEvent.NETSTREAM_XMPDATA, this.onXMPData);
            _ns.addEventListener(OvpEvent.NETSTREAM_CUEPOINT, this.onCuePoint);
            _ns.addEventListener(OvpEvent.NETSTREAM_TEXTDATA, this.onTextData);
            _ns.addEventListener(OvpEvent.NETSTREAM_PLAYSTATUS, this.onPlayStatus);
            _ns.addEventListener(OvpEvent.SWITCH_COMPLETE, this.onSwitchComplete);
            _ns.addEventListener(OvpEvent.SWITCH_REQUESTED, this.onSwitchRequested);
            _ns.maxBufferLength = this._buffer;
            if (this._securePlay){
                _ns.liveStreamAuthParams = this._playParams;
            };
            if (this._mediaAnalytics){
                Debug.getInstance().traceInfo(((("LimelightFMSConnectionMBR[" + _id) + "].connectedHandler MA: ") + this._isConnectionInfoCalled));
                if (!(this._isConnectionInfoCalled)){
                    AnalyticsPluginLoader.setNetConnectionInfo(_nc, this._hostname);
                };
                AnalyticsPluginLoader.setNetStreamInfo(_ns, this._streamname);
                this._isConnectionInfoCalled = false;
            };
            _ns.play(this._streamname);
            this.setVolume(this._currentVolume);
        }
        private function netStatusHandler(e:NetStatusEvent):void{
            Debug.getInstance().traceInfo(((("LimelightFMSConnectionMBR[" + _id) + "].netStatusHandler ") + e.info.code));
            switch (e.info.code){
                case "NetConnection.Connect.Rejected":
                    Debug.getInstance().traceInfo(((("LimelightFMSConnectionMBR[" + _id) + "].netStatusHandler Rejected by server. Reason is ") + e.info.description));
                    super.reportNetStatusEvent(e);
                    break;
                case "NetConnection.Connect.Success":
                    this.connectedHandler();
                    break;
                case "NetConnection.Connect.Closed":
                    this._hostname = "";
                    super.reportNetStatusEvent(e);
                    break;
                default:
                    super.reportNetStatusEvent(e);
            };
        }
        private function netStreamStatusHandler(e:NetStatusEvent):void{
            Debug.getInstance().traceInfo(((("LimelightFMSConnectionMBR[" + _id) + "].netStreamStatusHandler ") + e.info.code));
            switch (e.info.code){
                case "NetStream.Play.Start":
                    if (!(this._initialSeek)){
                        this._isPlaying = true;
                        dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STARTED, this));
                        Debug.getInstance().traceInfo(((("LimelightFMSConnectionMBR[" + _id) + "].netStreamStatusHandler start: ") + _ns.renderingIndex));
                    };
                    break;
                case "NetStream.Play.Stop":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STOPPED, this));
                    break;
                case "NetStream.Buffer.Full":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.BUFFER_FULL, this));
                    break;
                case "NetStream.Play.InsufficientBW":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.BANDWIDTH_WARNING, this));
                    break;
                case "NetStream.Failed":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, this));
                    break;
            };
        }
        private function onPlayStatus(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((("LimelightFMSConnectionMBR[" + _id) + "].onPlayStatus: ") + e.data.code));
        }
        private function onSwitchComplete(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((((("LimelightFMSConnectionMBR[" + _id) + "].onSwitchComplete: newInd:") + e.data.renderingIndex) + " newBitrate:") + e.data.renderingBitrate));
            super.setCurrentBitrate(new uint(e.data));
            dispatchEvent(new ConnectionEvent(ConnectionEvent.RENDITION_SWITCH, parseInt(e.data.renderingIndex)));
        }
        private function onSwitchRequested(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((((("LimelightFMSConnectionMBR[" + _id) + "].onSwitchRequested: reqInd:") + e.data.targetIndex) + " reason:") + e.data.reason));
        }
        private function progressHandler(e:OvpEvent):void{
            var videoTime:Object = new Object();
            videoTime.timeAsTimeCode = _ns.timeAsTimeCode;
            videoTime.streamLengthAsTimeCode = _ns.streamLength;
            videoTime.time = _ns.time;
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_PROGRESS, videoTime));
        }
        private function completeHandler(e:OvpEvent):void{
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_COMPLETE, this));
        }
        private function streamLengthHandler(e:OvpEvent):void{
            Debug.getInstance().traceInfo(((("LimelightFMSConnectionMBR[" + _id) + "].streamLengthHandler: ") + _nc.streamLengthAsTimeCode(_ns.streamLength)));
        }
        private function onError(e:OvpEvent):void{
            Debug.getInstance().traceInfo(((("LimelightFMSConnectionMBR[" + _id) + "].onError ") + e.data.errorDescription));
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, e.data.errorDescription));
        }
        private function metadataHandler(e:OvpEvent):void{
            var propName:String;
            for (propName in e.data) {
            };
            if (this._initialSeek){
                (this._initialSeek = false);
                _ns.seek(this._startPosition);
            };
            dispatchEvent(new ConnectionEvent(ConnectionEvent.META_DATA, e.data));
        }
        private function onDataMessage(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((((("LimelightFMSConnectionMBR[" + _id) + "].onDataMessage: ") + e.data.name) + " ") + e.data.value));
        }
        private function onXMPData(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((((("LimelightFMSConnectionMBR[" + _id) + "].onXMPDataMessage: ") + e.data.name) + " ") + e.data.value));
        }
        private function onCuePoint(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((((("LimelightFMSConnectionMBR[" + _id) + "].onCuePoint: ") + e.data.name) + " ") + e.data.value));
        }
        private function onTextData(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((((("LimelightFMSConnectionMBR[" + _id) + "].onTextData: ") + e.data.name) + " ") + e.data.value));
        }
        private function bandwidthHandler(e:OvpEvent):void{
            if (e.data.bandwidth < this._bitrate){
            };
            (this._bandwidth = (e.data.bandwidth + " kbps"));
            (this._latency = (e.data.latency + " ms"));
            Debug.getInstance().traceInfo((((("AkamaiConnection.bandwidthHandler: " + this._bandwidth) + " and the latency is ") + this._latency) + "."));
        }
        private function onNetstreamError(e:OvpEvent):void{
            Debug.getInstance().traceInfo(((((("LimelightFMSConnectionMBR[" + _id) + "].onNetstreamError ") + e.data.errorNumber) + " ") + e.data.errorDescription));
            if ((((e.data.errorNumber == 9)) || ((e.data.errorNumber == 6)))){
                dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, e.data));
            };
        }
        public function get netStream():NetStream{
            return (_ns);
        }
        public function get id():String{
            return (_id);
        }
        public function get isPlaying():Boolean{
            return (this._isPlaying);
        }
        public function get isAvailable():Boolean{
            return (this._isAvailable);
        }
        public function get streamtype():String{
            return (this._streamtype);
        }
        public function get dvrAvailable():int{
            return (this._dvrAvailable);
        }
        public function get startPosition():Number{
            return (this._startPosition);
        }
        public function get recycledConnection():Boolean{
            return (_recycledConnection);
        }
        public function set recycledConnection(value:Boolean):void{
            (_recycledConnection = value);
        }
        public function startConvivaMonitorSession(streamInfo:StreamObject):void{
            super.startMonitor(streamInfo);
        }
        public function stopConvivaMonitorSession():void{
            super.stopMonitor();
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import com.ibm.AS3util.*;
    import flash.net.*;
    import flash.events.*;

    public class ConnectionManager extends EventDispatcher {

        private static var _instance:ConnectionManager = null;
        public static var CDN_AKAMAI:String = "Akamai";
        public static var CDN_AKAMAI_MBR:String = "Akamai_MBR";
        public static var CDN_AKAMAI_HD_CORE:String = "Akamai_HDCore";
        public static var CDN_LEVEL3:String = "Level3";
        public static var CDN_LEVEL3_MBR:String = "Level3_MBR";
        public static var CDN_LIMELIGHT:String = "Limelight";
        public static var CDN_LIMELIGHT_MBR:String = "Limelight_MBR";
        public static var CDN_FMS:String = "FMS";
        public static var CDN_FMS_MBR:String = "FMS_MBR";
        public static var CDN_LOCAL:String = "Local";
        public static var CDN_OCTOSHAPE:String = "Octoshape";

        private var _currentConnections:Object;

        public function ConnectionManager(h:Function){
            this._currentConnections = new Object();
            super();
            if (h != hidden){
                throw (new Error("Singleton and can only be accessed through Singleton.getInstance()"));
            };
        }
        public static function getInstance():ConnectionManager{
            if (_instance == null){
                _instance = new ConnectionManager(hidden);
            };
            return (_instance);
        }
        private static function hidden():void{
        }

        public function init(locations:Array, cdns:Array):void{
            var y:int;
            var x:int;
            while (x < locations.length) {
                y = 0;
                while (y < cdns.length) {
                    this._currentConnections[((cdns[y] + "_") + locations[x])] = null;
                    y++;
                };
                x++;
            };
        }
        public function getConnection(location:String, cdn:String, streamObject:StreamObject):IMediaServerConnection{
            var connection:IMediaServerConnection;
            Debug.getInstance().traceDebug(((("ConnectionManager.getConnection: " + cdn) + " ") + location));
            if (!(this._currentConnections.hasOwnProperty(((cdn + "_") + location)))){
                this._currentConnections[((cdn + "_") + location)] = null;
            };
            if (this._currentConnections[((cdn + "_") + location)] == null){
                switch (cdn){
                    case CDN_AKAMAI:
                        connection = new AkamaiFMSConnection(location, streamObject);
                        break;
                    case CDN_AKAMAI_MBR:
                        connection = new AkamaiFMSConnectionMBR(location, streamObject);
                        break;
                    case CDN_AKAMAI_HD_CORE:
                        connection = new AkamaiHDCoreConnection(location, streamObject);
                        break;
                    case CDN_LIMELIGHT:
                        connection = new FMSConnection(location, streamObject);
                        break;
                    case CDN_LIMELIGHT_MBR:
                        connection = new LimelightFMSConnectionMBR(location, streamObject);
                        break;
                    case CDN_LOCAL:
                        connection = new LocalConnection(location, streamObject);
                        break;
                    case CDN_OCTOSHAPE:
                        connection = new OctoshapeConnection(location, streamObject);
                        break;
                    default:
                        Debug.getInstance().traceError(("ConnectionManager.getConnection: INVALID CDN: " + cdn));
                };
                this._currentConnections[((cdn + "_") + location)] = connection;
            } else {
                connection = this._currentConnections[((cdn + "_") + location)];
                connection.recycledConnection = true;
            };
            return (connection);
        }
        public function stopPlayback(connectionID:int):void{
            var connection:IMediaServerConnection = this.getConnectionByID(connectionID);
            connection.stopPlayback();
        }
        public function pause(connectionID:int):void{
            var connection:IMediaServerConnection = this.getConnectionByID(connectionID);
            connection.pause();
        }
        public function resume(connectionID:int):void{
            var connection:IMediaServerConnection = this.getConnectionByID(connectionID);
            connection.resume();
        }
        public function seek(connectionID:int, position:Number):void{
            var connection:IMediaServerConnection = this.getConnectionByID(connectionID);
            connection.seek(position);
        }
        public function updateBuffer(connectionID:int, value:int):void{
            var connection:IMediaServerConnection = this.getConnectionByID(connectionID);
            connection.updateBuffer(value);
        }
        public function getNetstream(connection:IMediaServerConnection):NetStream{
            if (connection.netStream){
                return (connection.netStream);
            };
            return (null);
        }
        private function getConnectionByID(id:int):IMediaServerConnection{
            var x:int;
            while (x < this._currentConnections.length) {
                if (this._currentConnections[x].id == id){
                    return (this._currentConnections[x]);
                };
                x++;
            };
            return (null);
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import flash.text.*;
    import flash.utils.*;
    import com.ibm.AS3util.*;
    import flash.display.*;
    import flash.events.*;
    import flash.system.*;

    public class VideoStats extends MovieClip {

        private const PLOT_HEIGHT:int = 100;
        private const CHANNEL_LENGTH:int = 0x0100;

        private var _keyentry:String;
        private var _titleFormat:TextFormat;
        private var _labelFormat:TextFormat;
        private var _valueFormat:TextFormat;
        private var _title:TextField;
        private var _stats:Array;
        private var _labelY:int;
        private var _showMetrics:Boolean;
        private var bytes:ByteArray;
        private var _spectrumDisplay:Sprite;

        public function VideoStats(stage:Stage):void{
            var currentField:TextField;
            this.bytes = new ByteArray();
            super();
            Debug.getInstance().traceDebug(("VideoStats.constructor: " + stage));
            this.visible = false;
            this._showMetrics = false;
            var bg:Shape = new Shape();
            bg.graphics.beginFill(0x333333);
            bg.graphics.drawRect(0, 0, 197, 287);
            bg.graphics.endFill();
            this.addChild(bg);
            this._titleFormat = new TextFormat("Arial", 11, 0xFF6500, true);
            this._labelFormat = new TextFormat("Arial", 10, 0xCCCCCC, true, false, false, null, null, TextFormatAlign.RIGHT);
            this._valueFormat = new TextFormat("Arial", 10, 0xFFFFFF, true);
            this._stats = new Array();
            this._stats.push(new Array("cdn", "Current CDN:"));
            this._stats.push(new Array("server", "Server IP or ID:"));
            this._stats.push(new Array("renditionIndex", "Rendition Index:"));
            this._stats.push(new Array("renditionBitrate", "Rendition Bitrate:"));
            this._stats.push(new Array("renditionSize", "Rendition Size:"));
            this._stats.push(new Array("buffers", "Buffer Length (s):"));
            this._stats.push(new Array("bwEstimate", "BW Estimate:"));
            this._stats.push(new Array("FPS", "Current FPS:"));
            this._stats.push(new Array("droppedFPS", "Dropped FPS:"));
            this._stats.push(new Array("smoothing", "Smoothing:"));
            this._stats.push(new Array("memory", "Memory:"));
            this._title = DefaultTextField.getOne(this._titleFormat, false);
            this._title.text = "Key Statistics".toUpperCase();
            this._title.x = 2;
            this._title.y = 1;
            this.addChild(this._title);
            this._labelY = 18;
            var x:int;
            while (x < this._stats.length) {
                this.addChild(DefaultTextField.getOne(this._labelFormat, false, ("label_" + this._stats[x][0])));
                currentField = (this.getChildByName(("label_" + this._stats[x][0])) as TextField);
                currentField.autoSize = TextFieldAutoSize.NONE;
                currentField.width = 92;
                currentField.x = 0;
                currentField.y = this._labelY;
                currentField.text = this._stats[x][1];
                currentField.height = (currentField.textHeight + 5);
                this.addChild(DefaultTextField.getOne(this._valueFormat, false, this._stats[x][0]));
                currentField = (this.getChildByName(this._stats[x][0]) as TextField);
                currentField.autoSize = TextFieldAutoSize.NONE;
                currentField.width = 95;
                currentField.height = 15;
                currentField.x = 95;
                currentField.y = this._labelY;
                this._labelY = (this._labelY + 16);
                x++;
            };
            bg.height = this._labelY;
            this.addEventListener(MouseEvent.MOUSE_DOWN, this.onMouseDown);
            this.addEventListener(MouseEvent.MOUSE_UP, this.onMouseUp);
            this._keyentry = "";
            stage.addEventListener(KeyboardEvent.KEY_DOWN, this.reportKeyDown);
        }
        public function updateSmoothing(value:Boolean):void{
            (this.getChildByName("smoothing") as TextField).text = ((value) ? "ON" : "OFF");
        }
        public function updateSize(width:int, height:int):void{
            (this.getChildByName("renditionSize") as TextField).text = ((width + "x") + height);
        }
        public function updateCDN(value:String):void{
            if (value == ConnectionManager.CDN_AKAMAI_HD_CORE){
                value = "HD Network";
            };
            (this.getChildByName("cdn") as TextField).text = value;
        }
        public function updateStats(values:Object):void{
            var currentField:TextField;
            var i:String;
            var bufferLength:String = " ";
            var bufferTime:String = " ";
            var targetBufferTime:String = " ";
            var expectedFPS:String = " ";
            var currentFPS:String = " ";
            var avgDroppedFPS:String = " ";
            var curDroppedFPS:String = " ";
            for (i in values) {
                switch (i){
                    case "serverIP":
                        (this.getChildByName("server") as TextField).text = values[i];
                        break;
                    case "bufferLength":
                        bufferLength = values[i];
                        break;
                    case "bufferTime":
                        bufferTime = values[i];
                        break;
                    case "targetBufferTime":
                        targetBufferTime = values[i];
                        break;
                    case "expectedFPS":
                        expectedFPS = values[i];
                        break;
                    case "currentFPS":
                        currentFPS = values[i];
                        break;
                    case "avgDroppedFPS":
                        avgDroppedFPS = values[i];
                        break;
                    case "curDroppedFPS":
                        curDroppedFPS = values[i];
                        break;
                    case "bwEstimate":
                        (this.getChildByName("bwEstimate") as TextField).text = values[i];
                        break;
                    case "currentIndex":
                        (this.getChildByName("renditionIndex") as TextField).text = values[i];
                        break;
                    case "currentBitrate":
                        (this.getChildByName("renditionBitrate") as TextField).text = values[i];
                        break;
                };
            };
            currentField = (this.getChildByName("buffers") as TextField);
            currentField.text = ((((bufferLength + "|") + bufferTime) + "|") + targetBufferTime);
            currentField = (this.getChildByName("FPS") as TextField);
            currentField.text = ((currentFPS + "|") + expectedFPS);
            currentField = (this.getChildByName("droppedFPS") as TextField);
            currentField.text = ((curDroppedFPS + "|") + avgDroppedFPS);
            currentField = (this.getChildByName("memory") as TextField);
            currentField.text = (Math.round((System.totalMemory / 1000)) + "K");
        }
        private function onMouseDown(e:MouseEvent):void{
            this.startDrag();
        }
        private function onMouseUp(e:MouseEvent):void{
            this.stopDrag();
        }
        private function reportKeyDown(event:KeyboardEvent):void{
            this._keyentry = (this._keyentry + String.fromCharCode(event.charCode));
            if (this._keyentry.length > 9){
                this._keyentry = this._keyentry.substr(1, (this._keyentry.length - 1));
            };
            if ((((this._keyentry.indexOf("ilovelamp") == 0)) || ((this._keyentry.indexOf("videostat") == 0)))){
                this.visible = !(this.visible);
                this._showMetrics = !(this._showMetrics);
                dispatchEvent(new Event(Event.CHANGE, this._showMetrics));
            };
            if (this._keyentry.indexOf("godawgs") > -1){
            };
        }
        public function get showMetrics():Boolean{
            return (this._showMetrics);
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import flash.net.*;
    import flash.events.*;

    public interface IMediaServerConnection extends IEventDispatcher {

        function startPlayback(_arg1:String, _arg2:String, _arg3:Number, _arg4:int=0, _arg5:int=3, _arg6:int=3600, _arg7:Number=0):void;
        function stopPlayback():void;
        function pause():void;
        function resume():void;
        function seek(_arg1:Number):void;
        function goLive():void;
        function updateBuffer(_arg1:int):void;
        function setVolume(_arg1:Number):void;
        function getVolume():Number;
        function setVideoStats(_arg1:VideoStats):void;
        function setMaxBitrate(_arg1:int):void;
        function setMediaAnalytics(_arg1:Boolean):void;
        function close():void;
        function get netStream():NetStream;
        function get id():String;
        function get isPlaying():Boolean;
        function get streamtype():String;
        function get dvrAvailable():int;
        function get startPosition():Number;
        function get recycledConnection():Boolean;
        function set recycledConnection(_arg1:Boolean):void;
        function startConvivaMonitorSession(_arg1:StreamObject):void;
        function stopConvivaMonitorSession():void;

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import flash.events.*;

    public class VideoEvent extends Event {

        public static const STOP_MAIN:String = "stop_main";
        public static const PLAYBACK_STARTED:String = "playback_started";
        public static const PLAYBACK_ENDED:String = "playback_ended";
        public static const PLAYBACK_CONTINUED:String = "playback_continued";
        public static const PLAYBACK_PROGRESS:String = "playback_progress";
        public static const PLAYBACK_COMPLETE:String = "playback_complete";
        public static const STREAM_ERROR:String = "stream_error";
        public static const BANDWIDTH_WARNING:String = "bandwidth_warning";
        public static const STATUS_MESSAGE:String = "status_message";
        public static const STOP_PIP:String = "stop_pip";
        public static const SWAP_VIDEO:String = "swap_video";
        public static const SWITCH_BITRATE:String = "switch_bitrate";
        public static const TIME_UPDATE:String = "time_update";

        public var info:Object;

        public function VideoEvent(type:String, info:Object){
            super(type);
            this.info = info;
        }
        override public function clone():Event{
            return (new VideoEvent(type, this.info));
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import org.openvideoplayer.net.*;
    import org.openvideoplayer.events.*;
    import flash.events.*;
    import flash.utils.*;
    import com.ibm.AS3util.*;
    import flash.net.*;

    public class LocalConnection extends ConvivaMediaConnection implements IMediaServerConnection {

        public const INIT_BUFFER:int = 3;
        public const INIT_LIVE_TIMEOUT:int = 3600;
        public const CDN:String = "Akamai";
        public const LIVE:String = "live";
        public const ONDEMAND:String = "ondemand";

        private var _bytesLoaded:Number;
        private var _currentVolume:Number;
        private var _bitrate:Number;
        private var _startPosition:Number;
        private var _initialSeek:Boolean;
        private var _isPlaying:Boolean;
        private var _isAvailable:Boolean;
        private var _bandwidth:String;
        private var _latency:String;
        private var _fpsTimer:Timer;
        private var _bandwidthTimer:Timer;
        private var _checkMetrics:Boolean;
        private var _videoStats:VideoStats;
        private var _timeRemaining:uint;
        private var _checkBandwidth:Boolean;
        private var _checkFPS:Boolean;
        private var _buffer:int;
        private var _liveTimeout:int;
        private var _hostname:String;
        private var _streamname:String;
        private var _streamtype:String;
        private var _dvrAvailable:int;

        public function LocalConnection(id:String, streamInfo:StreamObject):void{
            super(id, streamInfo);
            this._isPlaying = false;
            this._isAvailable = true;
            this._checkBandwidth = false;
            this._checkFPS = false;
            _nc = new OvpConnection();
            _nc.addEventListener(OvpEvent.ERROR, this.onError);
            _nc.addEventListener(NetStatusEvent.NET_STATUS, this.netStatusHandler);
            _nc.addEventListener(IOErrorEvent.IO_ERROR, this.ioErrorHandler);
            _nc.addEventListener(OvpEvent.BANDWIDTH, this.bandwidthHandler);
            this._fpsTimer = new Timer(1000);
            this._fpsTimer.addEventListener(TimerEvent.TIMER, this.updateFPS);
            this._bandwidthTimer = new Timer(10000);
            this._bandwidthTimer.addEventListener(TimerEvent.TIMER, this.updateBandwidth);
        }
        public function startPlayback(url:String, streamType:String, seekPos:Number, dvrTime:int=0, buffer:int=3, liveTimeout:int=3600, bitrate:Number=0):void{
            var temp:Array;
            var streamURL:Array = String(url).split("?");
            var secure:Boolean = (((streamURL[1] > 0)) ? true : false);
            this._bitrate = bitrate;
            this._startPosition = seekPos;
            this._buffer = buffer;
            this._liveTimeout = liveTimeout;
            this._initialSeek = true;
            this._isPlaying = true;
            this._isAvailable = false;
            var hostname:String = "";
            var streamname:String = "";
            this._streamtype = streamType;
            temp = streamURL[0].split("/");
            if (temp[0].indexOf("rtmp") == 0){
                temp.splice(0, 2);
            };
            if (temp[(temp.length - 1)].lastIndexOf(".flv") > -1){
                temp[(temp.length - 1)] = temp[(temp.length - 1)].substring(0, (temp[(temp.length - 1)].length - 4));
            };
            hostname = null;
            this._streamname = streamURL[0];
            Debug.getInstance().traceInfo(((((("LocalConnection[" + _id) + "].startPlayback: ") + _ns) + " | ") + secure));
            if (((((!((this._hostname == hostname))) || (!((_ns is OvpNetStream))))) || (secure))){
                if ((_nc.netConnection is NetConnection)){
                    _nc.close();
                };
                this._hostname = hostname;
                super.connectNetConnection(OvpConnection, this._hostname);
            } else {
                _ns.maxBufferLength = this._buffer;
                _ns.play(this._streamname);
            };
        }
        public function stopPlayback():void{
            Debug.getInstance().traceInfo((("LocalConnection[" + _id) + "].stopPlayback: "));
            if (_ns){
                _ns.close();
            };
            this._isPlaying = false;
            this._isAvailable = true;
            this._fpsTimer.stop();
            this._bandwidthTimer.stop();
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STOPPED, this));
        }
        public function pause():void{
            _ns.pause();
        }
        public function resume():void{
            _ns.resume();
        }
        public function seek(position:Number):void{
            _ns.seek(position);
        }
        public function goLive():void{
        }
        public function updateBuffer(value:int):void{
            _ns.maxBufferLength = value;
        }
        public function setVolume(value:Number):void{
            this._currentVolume = value;
            if (_ns){
                _ns.volume = this._currentVolume;
            };
        }
        public function getVolume():Number{
            return (this._currentVolume);
        }
        public function setMaxBitrate(value:int):void{
        }
        public function close():void{
        }
        public function setVideoStats(videoStats:VideoStats):void{
            this._videoStats = videoStats;
            if (this._videoStats){
                this._videoStats.removeEventListener(Event.CHANGE, this.onMetrics);
                this._videoStats.addEventListener(Event.CHANGE, this.onMetrics);
                this.onMetrics(new Event(Event.CHANGE));
            };
            Debug.getInstance().traceDebug(((("AkamaiFMSConnection[" + _id) + "].setVideoStats: ") + this._checkMetrics));
        }
        public function setMediaAnalytics(value:Boolean):void{
        }
        private function onMetrics(e:Event):void{
            this._checkMetrics = this._videoStats.showMetrics;
            this._checkBandwidth = this._checkMetrics;
            this._checkFPS = this._checkMetrics;
            Debug.getInstance().traceDebug(((((("AkamaiConnection[" + _id) + "].getMetrics: ") + this._checkBandwidth) + " ") + this._checkFPS));
            if (((this._checkBandwidth) && (!(this._bandwidthTimer.running)))){
                this._bandwidthTimer.start();
            };
            if (((this._checkFPS) && (!(this._fpsTimer.running)))){
                this._fpsTimer.start();
            };
            if (!(this._checkBandwidth)){
                this._bandwidthTimer.stop();
            };
            if (!(this._checkFPS)){
                this._fpsTimer.stop();
            };
        }
        private function updateFPS(e:TimerEvent):void{
            var statusObj:Object = new Object();
            if (_ns){
                Debug.getInstance().traceDebug((("LocalConnection[" + _id) + "].updateFPS: "));
                statusObj.FPS = Math.round(_ns.currentFPS);
                statusObj.Buffer = _ns.bufferLength;
                statusObj.Server = ((_nc.serverIPaddress + ":") + _nc.actualPort);
                statusObj.Bandwidth = this._bandwidth;
                statusObj.Latency = this._latency;
            };
        }
        private function updateBandwidth(e:TimerEvent):void{
            if (this._checkBandwidth){
                _nc.detectBandwidth();
            };
        }
        private function connectedHandler():void{
            Debug.getInstance().traceDebug(((((("LocalConnection[" + _id) + "].connectedHandler: Successfully connected using ") + _nc.actualProtocol) + " on port ") + _nc.actualPort));
            Debug.getInstance().traceDebug(((("LocalConnection[" + _id) + "].connectedHandler: LiveTimout - ") + this._liveTimeout));
            super.attachLivePassStreamer(OvpNetStream);
            _ns.streamTimeout = this._liveTimeout;
            _ns.client = this;
            if (this._streamtype == this.ONDEMAND){
            };
            _ns.addEventListener(NetStatusEvent.NET_STATUS, this.netStreamStatusHandler);
            _ns.addEventListener(OvpEvent.COMPLETE, this.completeHandler);
            _ns.addEventListener(OvpEvent.NETSTREAM_METADATA, this.metadataHandler);
            _ns.addEventListener(OvpEvent.STREAM_LENGTH, this.streamLengthHandler);
            _ns.addEventListener(OvpEvent.PROGRESS, this.progressHandler);
            _ns.addEventListener(OvpEvent.ERROR, this.onNetstreamError);
            _ns.maxBufferLength = this._buffer;
            _ns.play(this._streamname);
            this.setVolume(this._currentVolume);
        }
        private function netStatusHandler(e:NetStatusEvent):void{
            Debug.getInstance().traceInfo(((("LocalConnection[" + _id) + "].netStatusHandler ") + e.info.code));
            switch (e.info.code){
                case "NetConnection.Connect.Rejected":
                    Debug.getInstance().traceInfo(((("LocalConnection[" + _id) + "].netStatusHandler Rejected by server. Reason is ") + e.info.description));
                    super.reportNetStatusEvent(e);
                    break;
                case "NetConnection.Connect.Success":
                    this.connectedHandler();
                    break;
                case "NetConnection.Connect.Closed":
                    this._hostname = "";
                    super.reportNetStatusEvent(e);
                    break;
                default:
                    super.reportNetStatusEvent(e);
            };
        }
        private function ioErrorHandler(e:IOErrorEvent):void{
            Debug.getInstance().traceInfo(((("LocalConnection[" + _id) + "].ioErrorHandler ") + e.toString()));
        }
        private function netStreamStatusHandler(e:NetStatusEvent):void{
            switch (e.info.code){
                case "NetStream.Play.Start":
                    this._isPlaying = true;
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STARTED, this));
                    Debug.getInstance().traceInfo(((("LocalConnection[" + _id) + "].netStreamStatusHandler ") + _ns.streamTimeout));
                    break;
                case "NetStream.Play.Stop":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STOPPED, this));
                    break;
                case "NetStream.Buffer.Full":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.BUFFER_FULL, this));
                    break;
                case "NetStream.Play.InsufficientBW":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.BANDWIDTH_WARNING, this));
                    break;
                case "NetStream.Failed":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, this));
                    break;
            };
        }
        private function progressHandler(e:OvpEvent):void{
            var videoTime:Object = new Object();
            videoTime.timeAsTimeCode = _ns.timeAsTimeCode;
            videoTime.streamLengthAsTimeCode = _nc.streamLengthAsTimeCode(_ns.streamLength);
            videoTime.streamLength = _ns.streamLength;
            videoTime.time = _ns.time;
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_PROGRESS, videoTime));
        }
        private function completeHandler(e:OvpEvent):void{
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_COMPLETE, ""));
        }
        private function streamLengthHandler(e:OvpEvent):void{
            Debug.getInstance().traceInfo(((("LocalConnection[" + _id) + "].streamLengthHandler: ") + _nc.streamLengthAsTimeCode(_ns.streamLength)));
        }
        private function onError(e:OvpEvent):void{
            Debug.getInstance().traceInfo(((((("LocalConnection[" + _id) + "].onError ") + e.data.errorNumber) + " ") + e.data.errorDescription));
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, e.data.errorDescription));
        }
        private function metadataHandler(e:OvpEvent):void{
            var propName:String;
            for (propName in e.data) {
                Debug.getInstance().traceDebug(((((("LocalConnection[" + _id) + "].metadataHandler: ") + propName) + " = ") + e.data[propName]));
            };
            dispatchEvent(new ConnectionEvent(ConnectionEvent.META_DATA, e.data));
        }
        private function bandwidthHandler(e:OvpEvent):void{
            if (e.data.bandwidth < this._bitrate){
            };
            this._bandwidth = (e.data.bandwidth + " kbps");
            this._latency = (e.data.latency + " ms");
        }
        private function onNetstreamError(e:OvpEvent):void{
            Debug.getInstance().traceInfo(((((("LocalConnection[" + _id) + "].onNetstreamError ") + e.data.errorNumber) + " ") + e.data.errorDescription));
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, e.data));
        }
        public function get netStream():NetStream{
            return (_ns);
        }
        public function get id():String{
            return (_id);
        }
        public function get isPlaying():Boolean{
            return (this._isPlaying);
        }
        public function get isAvailable():Boolean{
            return (this._isAvailable);
        }
        public function get streamtype():String{
            return (this._streamtype);
        }
        public function get dvrAvailable():int{
            return (this._dvrAvailable);
        }
        public function get startPosition():Number{
            return (0);
        }
        public function get recycledConnection():Boolean{
            return (_recycledConnection);
        }
        public function set recycledConnection(value:Boolean):void{
            _recycledConnection = value;
        }
        public function startConvivaMonitorSession(streamInfo:StreamObject):void{
            super.startMonitor(streamInfo);
        }
        public function stopConvivaMonitorSession():void{
            super.stopMonitor();
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import com.akamai.net.*;
    import org.openvideoplayer.events.*;
    import org.openvideoplayer.net.*;
    import flash.events.*;
    import flash.utils.*;
    import org.openvideoplayer.parsers.*;
    import com.ibm.AS3util.*;
    import com.akamai.playeranalytics.*;
    import org.openvideoplayer.net.dynamicstream.*;
    import flash.net.*;

    public class AkamaiFMSConnectionMBR extends ConvivaMediaConnection implements IMediaServerConnection {

        public const INIT_BUFFER:int = 3;
        public const INIT_LIVE_TIMEOUT:int = 3600;
        public const LIVE:String = "live";
        public const ONDEMAND:String = "ondemand";

        private var _bytesLoaded:Number;
        private var _currentVolume:Number;
        private var _bitrate:Number;
        private var _startPosition:Number;
        private var _initialSeek:Boolean;
        private var _isPlaying:Boolean;
        private var _isAvailable:Boolean;
        private var _bandwidth:String;
        private var _latency:String;
        private var _metricsTimer:Timer;
        private var _checkMetrics:Boolean;
        private var _metricsObject:Object;
        private var _videoStats:VideoStats;
        private var _mediaAnalytics:Boolean = false;
        private var _isConnectionInfoCalled:Boolean;
        private var _akBoss:AkamaiBOSS;
        private var _timeRemaining:uint;
        private var _buffer:int;
        private var _liveTimeout:int;
        private var _secureConnect:Boolean;
        private var _securePlay:Boolean;
        private var _connectParams:String;
        private var _playParams:String;
        private var _dynamicSmilParser:DynamicSmilParser;
        private var _dsi:DynamicStreamItem;
        private var _maxBitrate:int = -1;
        private var _hostname:String;
        private var _streamname;
        private var _streamtype:String;
        private var _dvrAvailable:int;

        public function AkamaiFMSConnectionMBR(id:String, streamInfo:StreamObject):void{
            super(id, streamInfo);
            this._isPlaying = false;
            this._isAvailable = true;
            _nc = new AkamaiConnection();
            _nc.addEventListener(OvpEvent.ERROR, this.onError);
            _nc.addEventListener(NetStatusEvent.NET_STATUS, this.netStatusHandler);
            _nc.addEventListener(OvpEvent.BANDWIDTH, this.bandwidthHandler);
            this._metricsObject = new Object();
            this._metricsTimer = new Timer(1000);
            this._metricsTimer.addEventListener(TimerEvent.TIMER, this.updateVideoMetrics);
        }
        public function startPlayback(url:String, streamType:String, seekPos:Number, dvrTime:int=0, buffer:int=3, liveTimeout:int=3600, bitrate:Number=0):void{
            var temp:Array;
            var x:Number;
            var streamURL:Array = String(url).split("?");
            this._streamtype = streamType;
            this._secureConnect = (((streamURL[1] > 0)) ? true : false);
            this._bitrate = bitrate;
            this._startPosition = ((seekPos)==-1) ? -2 : seekPos;
            this._buffer = buffer;
            this._liveTimeout = liveTimeout;
            this._initialSeek = (((this._startPosition > 0)) ? true : false);
            this._isPlaying = true;
            this._isAvailable = false;
            var hostname:String = "";
            var streamname:String = "";
            if (String(streamURL[0]).match(".xml")){
                this._akBoss = new AkamaiBOSS(_id);
                this._akBoss.addEventListener(ConnectionEvent.BOSS_DATA, this.bossDataHandler);
                this._akBoss.loadBoss(streamURL[0]);
            } else {
                temp = streamURL[0].split("/");
                if (temp[0].indexOf("rtmp") == 0){
                    temp.splice(0, 2);
                };
                if (temp[(temp.length - 1)].lastIndexOf(".flv") > -1){
                    temp[(temp.length - 1)] = temp[(temp.length - 1)].substring(0, (temp[(temp.length - 1)].length - 4));
                };
                hostname = ((temp[0] + "/") + temp[1]);
                if (temp.length > 3){
                    x = 2;
                    while (x < temp.length) {
                        streamname = (streamname + temp[x]);
                        if (x < (temp.length - 1)){
                            streamname = (streamname + "/");
                        };
                        x++;
                    };
                } else {
                    streamname = temp[(temp.length - 1)];
                };
                if (temp[(temp.length - 1)].lastIndexOf(".smil") > -1){
                    this._dynamicSmilParser = new DynamicSmilParser();
                    this._dynamicSmilParser.addEventListener(OvpEvent.PARSED, this.onSmilParsed);
                    this._dynamicSmilParser.addEventListener(OvpEvent.ERROR, this.onSmilError);
                    this._dynamicSmilParser.addEventListener(OvpEvent.LOADED, this.onSmilLoaded);
                    this._dynamicSmilParser.load(streamURL[0]);
                    return;
                };
                this._streamname = streamname;
                Debug.getInstance().traceInfo(((((((("AkamaiFMSConnectionMBR[" + _id) + "].startPlayback: ") + hostname) + " | ") + this._streamtype) + " | ") + this._streamname));
                this.finishPlayback(hostname, this._secureConnect);
            };
        }
        private function finishPlayback(hostname:String, secure:Boolean):void{
            var hostname:* = hostname;
            var secure:* = secure;
            Debug.getInstance().traceInfo(((((("AkamaiFMSConnectionMBR[" + _id) + "].finishplayback: ") + !((this._hostname == hostname))) + " ") + this._secureConnect));
            if (((((!((this._hostname == hostname))) || (!(_ns)))) || (this._secureConnect))){
                _nc.close();
                this._hostname = hostname;
                if (this._mediaAnalytics){
                    Debug.getInstance().traceInfo(((("AkamaiFMSConnectionMBR[" + _id) + "].finishplayback1 MA: ") + this._isConnectionInfoCalled));
                    AnalyticsPluginLoader.setNetConnectionInfo(_nc, this._hostname);
                    this._isConnectionInfoCalled = true;
                };
                _nc.connectionAuth = this._connectParams;
                super.connectNetConnection(AkamaiConnection, this._hostname);
            } else {
                try {
                    _ns.maxBufferLength = this._buffer;
                    if (this._securePlay){
                        _ns.liveStreamAuthParams = this._playParams;
                    };
                    if (this._mediaAnalytics){
                        Debug.getInstance().traceInfo(((("AkamaiFMSConnectionMBR[" + _id) + "].finishplayback2 MA: ") + this._isConnectionInfoCalled));
                        if (!(this._isConnectionInfoCalled)){
                            AnalyticsPluginLoader.setNetConnectionInfo(_nc, this._hostname);
                        };
                        AnalyticsPluginLoader.setNetStreamInfo(_ns, this._streamname);
                        this._isConnectionInfoCalled = false;
                    };
                    _ns.play(this._streamname);
                } catch(e:Error) {
                    _nc.close();
                    _hostname = hostname;
                    super.connectNetConnection(AkamaiConnection, _hostname);
                };
            };
        }
        private function bossDataHandler(e:ConnectionEvent):void{
            this._streamname = e.info.streamName;
            this._streamtype = ((e.info.isLive) ? this.LIVE : this.ONDEMAND);
            this._secureConnect = ((!((e.info.connectionAuth == null))) ? true : false);
            this._connectParams = e.info.connectionAuth;
            this._securePlay = ((!((e.info.playAuth == null))) ? true : false);
            this._playParams = e.info.playAuth;
            this.finishPlayback(e.info.hostName, this._secureConnect);
        }
        public function stopPlayback():void{
            Debug.getInstance().traceInfo(((((("AkamaiFMSConnectionMBR[" + _id) + "].stopPlayback: ") + _nc.isLive) + " ") + _ns));
            try {
                _ns.close();
            } catch(e:Error) {
                Debug.getInstance().traceError(((("AkamaiFMSConnectionMBR[" + _id) + "].stopPlayback ERROR: ") + e));
            };
            this._isPlaying = false;
            this._isAvailable = true;
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STOPPED, this));
        }
        public function pause():void{
            _ns.pause();
        }
        public function resume():void{
            _ns.resume();
        }
        public function seek(position:Number):void{
            _ns.seek(position);
        }
        public function goLive():void{
        }
        public function updateBuffer(value:int):void{
            _ns.maxBufferLength = value;
        }
        public function setVolume(value:Number):void{
            this._currentVolume = value;
            try {
                _ns.volume = this._currentVolume;
            } catch(e:Error) {
            };
        }
        public function getVolume():Number{
            return (this._currentVolume);
        }
        public function setMaxBitrate(value:int):void{
            var bandwidthRule:BandwidthRuleEvents;
            this._maxBitrate = value;
            if (_ns){
                bandwidthRule = new BandwidthRuleEvents(_ns.metricsProvider, this._maxBitrate);
                _ns.clearRules();
                _ns.addRule(bandwidthRule);
                _ns.addRule(new FrameDropRule(_ns.metricsProvider));
                _ns.addRule(new BufferRule(_ns.metricsProvider));
            };
        }
        public function close():void{
        }
        public function setVideoStats(videoStats:VideoStats):void{
            this._videoStats = videoStats;
            if (this._videoStats){
                this._videoStats.removeEventListener(Event.CHANGE, this.onVideoMetrics);
                this._videoStats.addEventListener(Event.CHANGE, this.onVideoMetrics);
                this.onVideoMetrics(new Event(Event.CHANGE));
            };
            Debug.getInstance().traceDebug(((("AkamaiFMSConnectionMBR[" + _id) + "].setVideoStats: ") + this._checkMetrics));
        }
        public function setMediaAnalytics(value:Boolean):void{
            Debug.getInstance().traceDebug(((("AkamaiFMSConnection[" + _id) + "].setMediaAnalytics: ") + value));
            this._mediaAnalytics = value;
        }
        private function onSmilLoaded(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((("AkamaiFMSConnectionMBR[" + _id) + "].onSmilLoaded: ") + e.toString()));
        }
        private function onSmilError(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((("AkamaiFMSConnectionMBR[" + _id) + "].onSmilError: ") + e.data.errorDescription));
        }
        private function onSmilParsed(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((("AkamaiFMSConnectionMBR[" + _id) + "].onSmilParsed: ") + e.toString()));
            this._dsi = this._dynamicSmilParser.dsi;
            this._streamname = this._dsi;
            Debug.getInstance().traceDebug(((("AkamaiFMSConnectionMBR[" + _id) + "].onSmilParsed - hostname: ") + this._dynamicSmilParser.hostName));
            Debug.getInstance().traceDebug(((("AkamaiFMSConnectionMBR[" + _id) + "].onSmilParsed - dsi: ") + this._dsi));
            this.finishPlayback(this._dynamicSmilParser.hostName, false);
        }
        private function onVideoMetrics(e:Event):void{
            this._checkMetrics = this._videoStats.showMetrics;
            Debug.getInstance().traceDebug(((("AkamaiFMSConnectionMBR[" + _id) + "].onMetrics: ") + this._checkMetrics));
            if (((this._checkMetrics) && (!(this._metricsTimer.running)))){
                this._metricsTimer.start();
            };
            if (!(this._checkMetrics)){
                this._metricsTimer.stop();
            };
        }
        private function updateVideoMetrics(e:TimerEvent):void{
            if (_ns){
                this._metricsObject.currentIndex = _ns.metricsProvider.currentIndex;
                this._metricsObject.currentBitrate = Math.round(_ns.currentStreamBitRate);
                this._metricsObject.bwEstimate = (Math.round(_ns.metricsProvider.averageMaxBandwidth) + " kbps");
                this._metricsObject.expectedFPS = Math.round(_ns.metricsProvider.expectedFPS);
                this._metricsObject.currentFPS = Math.round(_ns.currentFPS);
                this._metricsObject.avgDroppedFPS = Math.round(_ns.metricsProvider.averageDroppedFPS);
                this._metricsObject.curDroppedFPS = Math.round(_ns.metricsProvider.droppedFPS);
                this._metricsObject.bufferLength = Math.round(_ns.metricsProvider.bufferLength);
                this._metricsObject.bufferTime = Math.round(_ns.metricsProvider.bufferTime);
                this._metricsObject.targetBufferTime = Math.round(_ns.metricsProvider.targetBufferTime);
                this._metricsObject.serverIP = _nc.serverIPaddress;
                this._videoStats.updateStats(this._metricsObject);
            };
        }
        private function connectedHandler():void{
            Debug.getInstance().traceDebug(((((("AkamaiFMSConnectionMBR[" + _id) + "].connectedHandler: Successfully connected using ") + _nc.actualProtocol) + " on port ") + _nc.actualPort));
            if (_ns){
                _ns.removeEventListener(NetStatusEvent.NET_STATUS, this.netStreamStatusHandler);
                _ns = null;
            };
            super.attachLivePassStreamer(AkamaiDynamicNetStream);
            _ns.client = this;
            this.setMaxBitrate(this._maxBitrate);
            if (this._streamtype == this.LIVE){
                _ns.metricsProvider.optimizeForLivebandwidthEstimate = true;
            };
            _ns.addEventListener(OvpEvent.PROGRESS, this.progressHandler);
            _ns.addEventListener(NetStatusEvent.NET_STATUS, this.netStreamStatusHandler);
            _ns.addEventListener(OvpEvent.COMPLETE, this.completeHandler);
            _ns.addEventListener(OvpEvent.NETSTREAM_METADATA, this.metadataHandler);
            _ns.addEventListener(OvpEvent.STREAM_LENGTH, this.streamLengthHandler);
            _ns.addEventListener(OvpEvent.ERROR, this.onNetstreamError);
            _ns.addEventListener(OvpEvent.DATA_MESSAGE, this.onDataMessage);
            _ns.addEventListener(OvpEvent.NETSTREAM_XMPDATA, this.onXMPData);
            _ns.addEventListener(OvpEvent.NETSTREAM_CUEPOINT, this.onCuePoint);
            _ns.addEventListener(OvpEvent.NETSTREAM_TEXTDATA, this.onTextData);
            _ns.addEventListener(OvpEvent.NETSTREAM_PLAYSTATUS, this.onPlayStatus);
            _ns.addEventListener(OvpEvent.SWITCH_COMPLETE, this.onSwitchComplete);
            _ns.addEventListener(OvpEvent.SWITCH_REQUESTED, this.onSwitchRequested);
            _ns.maxBufferLength = this._buffer;
            if (this._securePlay){
                _ns.liveStreamAuthParams = this._playParams;
            };
            if (this._mediaAnalytics){
                Debug.getInstance().traceInfo(((("AkamaiFMSConnectionMBR[" + _id) + "].connectedHandler MA: ") + this._isConnectionInfoCalled));
                if (!(this._isConnectionInfoCalled)){
                    AnalyticsPluginLoader.setNetConnectionInfo(_nc, this._hostname);
                };
                AnalyticsPluginLoader.setNetStreamInfo(_ns, this._streamname);
                this._isConnectionInfoCalled = false;
            };
            _ns.play(this._streamname);
            this.setVolume(this._currentVolume);
        }
        private function netStatusHandler(e:NetStatusEvent):void{
            Debug.getInstance().traceInfo(((("AkamaiFMSConnectionMBR[" + _id) + "].netStatusHandler ") + e.info.code));
            switch (e.info.code){
                case "NetConnection.Connect.Rejected":
                    Debug.getInstance().traceInfo(((("AkamaiFMSConnectionMBR[" + _id) + "].netStatusHandler Rejected by server. Reason is ") + e.info.description));
                    super.reportNetStatusEvent(e);
                    break;
                case "NetConnection.Connect.Success":
                    this.connectedHandler();
                    break;
                case "NetConnection.Connect.Closed":
                    this._hostname = "";
                    super.reportNetStatusEvent(e);
                    break;
                default:
                    super.reportNetStatusEvent(e);
            };
        }
        private function netStreamStatusHandler(e:NetStatusEvent):void{
            Debug.getInstance().traceInfo(((("AkamaiFMSConnectionMBR[" + _id) + "].netStreamStatusHandler ") + e.info.code));
            switch (e.info.code){
                case "NetStream.Play.Start":
                    if (!(this._initialSeek)){
                        this._isPlaying = true;
                        dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STARTED, this));
                        Debug.getInstance().traceInfo(((("AkamaiFMSConnectionMBR[" + _id) + "].netStreamStatusHandler start: ") + _ns.renderingIndex));
                    };
                    break;
                case "NetStream.Play.Stop":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STOPPED, this));
                    break;
                case "NetStream.Buffer.Full":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.BUFFER_FULL, this));
                    break;
                case "NetStream.Play.InsufficientBW":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.BANDWIDTH_WARNING, this));
                    break;
                case "NetStream.Failed":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, this));
                    break;
            };
        }
        private function onPlayStatus(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((("AkamaiFMSConnectionMBR[" + _id) + "].onPlayStatus: ") + e.data.code));
        }
        private function onSwitchComplete(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((((("AkamaiFMSConnectionMBR[" + _id) + "].onSwitchComplete: newInd:") + e.data.renderingIndex) + " newBitrate:") + e.data.renderingBitrate));
            super.setCurrentBitrate(new uint(e.data));
            dispatchEvent(new ConnectionEvent(ConnectionEvent.RENDITION_SWITCH, parseInt(e.data.renderingIndex)));
        }
        private function onSwitchRequested(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((((("AkamaiFMSConnectionMBR[" + _id) + "].onSwitchRequested: reqInd:") + e.data.targetIndex) + " reason:") + e.data.reason));
        }
        private function progressHandler(e:OvpEvent):void{
            var videoTime:Object = new Object();
            videoTime.timeAsTimeCode = _ns.timeAsTimeCode;
            videoTime.streamLengthAsTimeCode = _ns.streamLength;
            videoTime.time = _ns.time;
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_PROGRESS, videoTime));
        }
        private function completeHandler(e:OvpEvent):void{
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_COMPLETE, this));
        }
        private function streamLengthHandler(e:OvpEvent):void{
            Debug.getInstance().traceInfo(((("AkamaiFMSConnectionMBR[" + _id) + "].streamLengthHandler: ") + _nc.streamLengthAsTimeCode(_ns.streamLength)));
        }
        private function onError(e:OvpEvent):void{
            Debug.getInstance().traceInfo(((("AkamaiFMSConnectionMBR[" + _id) + "].onError ") + e.data.errorDescription));
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, e.data.errorDescription));
        }
        private function metadataHandler(e:OvpEvent):void{
            var propName:String;
            for (propName in e.data) {
            };
            if (this._initialSeek){
                (this._initialSeek = false);
                _ns.seek(this._startPosition);
            };
            dispatchEvent(new ConnectionEvent(ConnectionEvent.META_DATA, e.data));
        }
        private function onDataMessage(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((((("AkamaiFMSConnectionMBR[" + _id) + "].onDataMessage: ") + e.data.name) + " ") + e.data.value));
        }
        private function onXMPData(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((((("AkamaiFMSConnectionMBR[" + _id) + "].onXMPDataMessage: ") + e.data.name) + " ") + e.data.value));
        }
        private function onCuePoint(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((((("AkamaiFMSConnectionMBR[" + _id) + "].onCuePoint: ") + e.data.name) + " ") + e.data.value));
        }
        private function onTextData(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((((("AkamaiFMSConnectionMBR[" + _id) + "].onTextData: ") + e.data.name) + " ") + e.data.value));
        }
        private function bandwidthHandler(e:OvpEvent):void{
            if (e.data.bandwidth < this._bitrate){
            };
            (this._bandwidth = (e.data.bandwidth + " kbps"));
            (this._latency = (e.data.latency + " ms"));
            Debug.getInstance().traceInfo((((("AkamaiConnection.bandwidthHandler: " + this._bandwidth) + " and the latency is ") + this._latency) + "."));
        }
        private function onNetstreamError(e:OvpEvent):void{
            Debug.getInstance().traceInfo(((((("AkamaiFMSConnectionMBR[" + _id) + "].onNetstreamError ") + e.data.errorNumber) + " ") + e.data.errorDescription));
            if ((((e.data.errorNumber == 9)) || ((e.data.errorNumber == 6)))){
                dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, e.data));
            };
        }
        public function get netStream():NetStream{
            return (_ns);
        }
        public function get id():String{
            return (_id);
        }
        public function get isPlaying():Boolean{
            return (this._isPlaying);
        }
        public function get isAvailable():Boolean{
            return (this._isAvailable);
        }
        public function get streamtype():String{
            return (this._streamtype);
        }
        public function get dvrAvailable():int{
            return (this._dvrAvailable);
        }
        public function get startPosition():Number{
            return (this._startPosition);
        }
        public function get recycledConnection():Boolean{
            return (_recycledConnection);
        }
        public function set recycledConnection(value:Boolean):void{
            (_recycledConnection = value);
        }
        public function startConvivaMonitorSession(streamInfo:StreamObject):void{
            super.startMonitor(streamInfo);
        }
        public function stopConvivaMonitorSession():void{
            super.stopMonitor();
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import com.akamai.net.*;
    import org.openvideoplayer.events.*;
    import org.openvideoplayer.net.*;
    import flash.events.*;
    import flash.utils.*;
    import com.ibm.AS3util.*;
    import flash.net.*;

    public class AkamaiFMSConnection extends ConvivaMediaConnection implements IMediaServerConnection {

        public const INIT_BUFFER:int = 3;
        public const INIT_LIVE_TIMEOUT:int = 3600;
        public const CDN:String = "Akamai";
        public const LIVE:String = "live";
        public const ONDEMAND:String = "ondemand";

        private var _bytesLoaded:Number;
        private var _currentVolume:Number;
        private var _bitrate:Number;
        private var _startPosition:Number;
        private var _initialSeek:Boolean;
        private var _isPlaying:Boolean;
        private var _isAvailable:Boolean;
        private var _bandwidth:String;
        private var _latency:String;
        private var _metricsTimer:Timer;
        private var _checkMetrics:Boolean;
        private var _metricsObject:Object;
        private var _videoStats:VideoStats;
        private var _akBoss:AkamaiBOSS;
        private var _timeRemaining:uint;
        private var _buffer:int;
        private var _liveTimeout:int;
        private var _secureConnect:Boolean;
        private var _securePlay:Boolean;
        private var _connectParams:String;
        private var _playParams:String;
        private var _hostname:String;
        private var _streamname:String;
        private var _streamtype:String;
        private var _dvrAvailable:int;

        public function AkamaiFMSConnection(id:String, streamInfo:StreamObject):void{
            super(id, streamInfo);
            this._isPlaying = false;
            this._isAvailable = true;
            _nc = new AkamaiConnection();
            _nc.addEventListener(OvpEvent.ERROR, this.onError);
            _nc.addEventListener(NetStatusEvent.NET_STATUS, this.netStatusHandler);
            _nc.addEventListener(OvpEvent.BANDWIDTH, this.bandwidthHandler);
            this._metricsObject = new Object();
            this._metricsTimer = new Timer(1000);
            this._metricsTimer.addEventListener(TimerEvent.TIMER, this.updateVideoMetrics);
        }
        public function startPlayback(url:String, streamType:String, seekPos:Number, dvrTime:int=0, buffer:int=3, liveTimeout:int=3600, bitrate:Number=0):void{
            var temp:Array;
            var x:Number;
            var streamURL:Array = String(url).split("?");
            this._secureConnect = (((streamURL[1] > 0)) ? true : false);
            this._bitrate = bitrate;
            this._startPosition = ((seekPos)==-1) ? -2 : seekPos;
            this._buffer = buffer;
            this._liveTimeout = liveTimeout;
            this._initialSeek = (((this._startPosition > 0)) ? true : false);
            this._isPlaying = true;
            this._isAvailable = false;
            var hostname:String = "";
            var streamname:String = "";
            if (String(streamURL[0]).match(".xml")){
                this._akBoss = new AkamaiBOSS(_id);
                this._akBoss.addEventListener(ConnectionEvent.BOSS_DATA, this.bossDataHandler);
                this._akBoss.loadBoss(streamURL[0]);
            } else {
                temp = streamURL[0].split("/");
                if (temp[0].indexOf("rtmp") == 0){
                    temp.splice(0, 2);
                };
                if (temp[(temp.length - 1)].lastIndexOf(".flv") > -1){
                    temp[(temp.length - 1)] = temp[(temp.length - 1)].substring(0, (temp[(temp.length - 1)].length - 4));
                };
                hostname = ((temp[0] + "/") + temp[1]);
                if (temp.length > 3){
                    x = 2;
                    while (x < temp.length) {
                        streamname = (streamname + temp[x]);
                        if (x < (temp.length - 1)){
                            streamname = (streamname + "/");
                        };
                        x++;
                    };
                } else {
                    streamname = temp[(temp.length - 1)];
                };
                this._streamname = streamname;
                this._streamtype = (((this.streamtype == this.LIVE)) ? this.LIVE : this.ONDEMAND);
                Debug.getInstance().traceInfo(((((((("AkamaiFMSConnection[" + _id) + "].startPlayback: ") + hostname) + " | ") + this._streamtype) + " | ") + this._streamname));
                this.makeConnection(hostname);
            };
        }
        private function makeConnection(hostname:String):void{
            var hostname:* = hostname;
            Debug.getInstance().traceInfo(((((("AkamaiFMSConnection[" + _id) + "].makeConnection: ") + !((this._hostname == hostname))) + " ") + this._secureConnect));
            if (((((!((this._hostname == hostname))) || (!(_ns)))) || (this._secureConnect))){
                _nc.close();
                this._hostname = hostname;
                _nc.connectionAuth = this._connectParams;
                super.connectNetConnection(AkamaiConnection, this._hostname);
            } else {
                try {
                    _ns.maxBufferLength = this._buffer;
                    if (this._securePlay){
                        _ns.liveStreamAuthParams = this._playParams;
                    };
                    _ns.play(this._streamname);
                } catch(e:Error) {
                    _nc.close();
                    _hostname = hostname;
                    super.connectNetConnection(AkamaiConnection, _hostname);
                };
            };
        }
        private function bossDataHandler(e:ConnectionEvent):void{
            this._streamname = e.info.streamName;
            this._streamtype = ((e.info.isLive) ? this.LIVE : this.ONDEMAND);
            this._secureConnect = ((!((e.info.connectionAuth == null))) ? true : false);
            this._connectParams = e.info.connectionAuth;
            this._securePlay = ((!((e.info.playAuth == null))) ? true : false);
            this._playParams = e.info.playAuth;
            this.makeConnection(e.info.hostName);
        }
        public function stopPlayback():void{
            Debug.getInstance().traceInfo(((((("AkamaiFMSConnection[" + _id) + "].stopPlayback: ") + _nc.isLive) + " ") + _ns));
            try {
                _ns.close();
            } catch(e:Error) {
                Debug.getInstance().traceError(((("AkamaiFMSConnection[" + _id) + "].stopPlayback ERROR: ") + e));
            };
            this._isPlaying = false;
            this._isAvailable = true;
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STOPPED, this));
        }
        public function pause():void{
            _ns.pause();
        }
        public function resume():void{
            _ns.resume();
        }
        public function seek(position:Number):void{
            _ns.seek(position);
        }
        public function goLive():void{
        }
        public function updateBuffer(value:int):void{
            _ns.maxBufferLength = value;
        }
        public function setVolume(value:Number):void{
            this._currentVolume = value;
            try {
                _ns.volume = this._currentVolume;
            } catch(e:Error) {
            };
        }
        public function getVolume():Number{
            return (this._currentVolume);
        }
        public function setMaxBitrate(value:int):void{
        }
        public function close():void{
        }
        public function setVideoStats(videoStats:VideoStats):void{
            this._videoStats = videoStats;
            if (this._videoStats){
                this._videoStats.removeEventListener(Event.CHANGE, this.onVideoMetrics);
                this._videoStats.addEventListener(Event.CHANGE, this.onVideoMetrics);
                this.onVideoMetrics(new Event(Event.CHANGE));
            };
            Debug.getInstance().traceDebug(((("AkamaiFMSConnection[" + _id) + "].setVideoStats: ") + this._checkMetrics));
        }
        public function setMediaAnalytics(value:Boolean):void{
        }
        private function onVideoMetrics(e:Event):void{
            this._checkMetrics = this._videoStats.showMetrics;
            Debug.getInstance().traceDebug(((("AkamaiFMSConnectionMBR[" + _id) + "].onMetrics: ") + this._checkMetrics));
            if (((this._checkMetrics) && (!(this._metricsTimer.running)))){
                this._metricsTimer.start();
            };
            if (!(this._checkMetrics)){
                this._metricsTimer.stop();
            };
        }
        private function updateVideoMetrics(e:TimerEvent):void{
            if (_ns){
                this._metricsObject.currentIndex = "N/A";
                this._metricsObject.currentBitrate = "N/A";
                this._metricsObject.bwEstimate = "N/A";
                this._metricsObject.expectedFPS = " ";
                this._metricsObject.currentFPS = Math.round(_ns.currentFPS);
                this._metricsObject.avgDroppedFPS = " ";
                this._metricsObject.curDroppedFPS = " ";
                this._metricsObject.bufferLength = Math.round(_ns.bufferLength);
                this._metricsObject.bufferTime = Math.round(_ns.bufferTime);
                this._metricsObject.targetBufferTime = " ";
                this._metricsObject.serverIP = _nc.serverIPaddress;
                this._videoStats.updateStats(this._metricsObject);
            };
        }
        private function connectedHandler():void{
            Debug.getInstance().traceDebug(((((("AkamaiFMSConnection[" + _id) + "].connectedHandler: Successfully connected using ") + _nc.actualProtocol) + " on port ") + _nc.actualPort));
            if (_ns){
                _ns.removeEventListener(NetStatusEvent.NET_STATUS, this.netStreamStatusHandler);
                _ns = null;
            };
            super.attachLivePassStreamer(AkamaiNetStream);
            if (_nc.subscribeRequiredForLiveStreams){
                _ns.addEventListener(OvpEvent.SUBSCRIBED, this.subscribedHandler);
                _ns.addEventListener(OvpEvent.UNSUBSCRIBED, this.unsubscribedHandler);
                _ns.addEventListener(OvpEvent.SUBSCRIBE_ATTEMPT, this.subscribeAttemptHandler);
            };
            if (this._streamtype == this.ONDEMAND){
            };
            _ns.addEventListener(OvpEvent.PROGRESS, this.progressHandler);
            _ns.addEventListener(NetStatusEvent.NET_STATUS, this.netStreamStatusHandler);
            _ns.addEventListener(OvpEvent.COMPLETE, this.completeHandler);
            _ns.addEventListener(OvpEvent.NETSTREAM_METADATA, this.onMetaData);
            _ns.addEventListener(OvpEvent.STREAM_LENGTH, this.streamLengthHandler);
            _ns.addEventListener(OvpEvent.ERROR, this.onNetstreamError);
            _ns.addEventListener(OvpEvent.DATA_MESSAGE, this.onDataMessage);
            _ns.addEventListener(OvpEvent.NETSTREAM_XMPDATA, this.onXMPData);
            _ns.addEventListener(OvpEvent.NETSTREAM_CUEPOINT, this.onCuePoint);
            _ns.addEventListener(OvpEvent.NETSTREAM_TEXTDATA, this.onTextData);
            _ns.maxBufferLength = this._buffer;
            if (this._securePlay){
                _ns.liveStreamAuthParams = this._playParams;
            };
            _ns.play(this._streamname);
            this.setVolume(this._currentVolume);
        }
        private function netStatusHandler(e:NetStatusEvent):void{
            Debug.getInstance().traceInfo(((("AkamaiFMSConnection[" + _id) + "].netStatusHandler ") + e.info.code));
            switch (e.info.code){
                case "NetConnection.Connect.Rejected":
                    Debug.getInstance().traceInfo(((("AkamaiFMSConnection[" + _id) + "].netStatusHandler Rejected by server. Reason is ") + e.info.description));
                    super.reportNetStatusEvent(e);
                    break;
                case "NetConnection.Connect.Success":
                    this.connectedHandler();
                    break;
                case "NetConnection.Connect.Closed":
                    this._hostname = "";
                    super.reportNetStatusEvent(e);
                    break;
                default:
                    super.reportNetStatusEvent(e);
            };
        }
        private function netStreamStatusHandler(e:NetStatusEvent):void{
            Debug.getInstance().traceInfo(((("AkamaiFMSConnection[" + _id) + "].netStreamStatusHandler ") + e.info.code));
            switch (e.info.code){
                case "NetStream.Play.Start":
                    if (!(this._initialSeek)){
                        this._isPlaying = true;
                        dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STARTED, this));
                        Debug.getInstance().traceInfo(((("AkamaiFMSConnection[" + _id) + "].netStreamStatusHandler ") + _ns.liveStreamMasterTimeout));
                    };
                    break;
                case "NetStream.Play.Stop":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STOPPED, this));
                    break;
                case "NetStream.Buffer.Full":
                    if (!(this._initialSeek)){
                        dispatchEvent(new ConnectionEvent(ConnectionEvent.BUFFER_FULL, this));
                    };
                    break;
                case "NetStream.Play.InsufficientBW":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.BANDWIDTH_WARNING, this));
                    break;
                case "NetStream.Failed":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, this));
                    break;
            };
        }
        private function progressHandler(e:OvpEvent):void{
            var videoTime:Object = new Object();
            videoTime.timeAsTimeCode = _ns.timeAsTimeCode;
            videoTime.streamLengthAsTimeCode = _nc.streamLengthAsTimeCode(_ns.streamLength);
            videoTime.time = _ns.time;
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_PROGRESS, videoTime));
        }
        private function completeHandler(e:OvpEvent):void{
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_COMPLETE, this));
        }
        private function streamLengthHandler(e:OvpEvent):void{
            Debug.getInstance().traceInfo(((("AkamaiFMSConnection[" + _id) + "].streamLengthHandler: ") + _nc.streamLengthAsTimeCode(_ns.streamLength)));
        }
        private function onError(e:OvpEvent):void{
            Debug.getInstance().traceInfo(((("AkamaiFMSConnection[" + _id) + "].onError ") + e.data.errorDescription));
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, e.data.errorDescription));
        }
        private function subscribedHandler(e:OvpEvent):void{
            Debug.getInstance().traceInfo(((("AkamaiFMSConnection[" + _id) + "].subscribedHandler ") + e));
        }
        private function unsubscribedHandler(e:OvpEvent):void{
            Debug.getInstance().traceInfo((("AkamaiFMSConnection[" + _id) + "].unsubscribedHandler "));
            this._timeRemaining = getTimer();
            _ns.close();
        }
        private function subscribeAttemptHandler(e:OvpEvent):void{
            Debug.getInstance().traceInfo((("AkamaiFMSConnection[" + _id) + "].subscribeAttemptHandler"));
        }
        private function onMetaData(e:OvpEvent):void{
            var propName:String;
            for (propName in e.data) {
            };
            if (this._initialSeek){
                (this._initialSeek = false);
                _ns.seek(this._startPosition);
            };
            dispatchEvent(new ConnectionEvent(ConnectionEvent.META_DATA, e.data));
        }
        private function onDataMessage(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((((("AkamaiFMSConnection[" + _id) + "].onDataMessage: ") + e.data.name) + " ") + e.data.value));
        }
        private function onXMPData(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((((("AkamaiFMSConnection[" + _id) + "].onXMPDataMessage: ") + e.data.name) + " ") + e.data.value));
        }
        private function onCuePoint(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((((("AkamaiFMSConnection[" + _id) + "].onCuePoint: ") + e.data.name) + " ") + e.data.value));
        }
        private function onTextData(e:OvpEvent):void{
            Debug.getInstance().traceDebug(((((("AkamaiFMSConnection[" + _id) + "].onTextData: ") + e.data.name) + " ") + e.data.value));
        }
        private function bandwidthHandler(e:OvpEvent):void{
            if (e.data.bandwidth < this._bitrate){
            };
            (this._bandwidth = (e.data.bandwidth + " kbps"));
            (this._latency = (e.data.latency + " ms"));
            Debug.getInstance().traceInfo((((("AkamaiConnection.bandwidthHandler: " + this._bandwidth) + " and the latency is ") + this._latency) + "."));
        }
        private function onNetstreamError(e:OvpEvent):void{
            Debug.getInstance().traceInfo(((((("AkamaiFMSConnection[" + _id) + "].onNetstreamError ") + e.data.errorNumber) + " ") + e.data.errorDescription));
            if ((((e.data.errorNumber == 9)) || ((e.data.errorNumber == 6)))){
                dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, e.data));
            };
        }
        public function get netStream():NetStream{
            return (_ns);
        }
        public function get id():String{
            return (_id);
        }
        public function get isPlaying():Boolean{
            return (this._isPlaying);
        }
        public function get isAvailable():Boolean{
            return (this._isAvailable);
        }
        public function get streamtype():String{
            return (this._streamtype);
        }
        public function get dvrAvailable():int{
            return (this._dvrAvailable);
        }
        public function get startPosition():Number{
            return (this._startPosition);
        }
        public function get recycledConnection():Boolean{
            return (_recycledConnection);
        }
        public function set recycledConnection(value:Boolean):void{
            (_recycledConnection = value);
        }
        public function startConvivaMonitorSession(streamInfo:StreamObject):void{
            super.startMonitor(streamInfo);
        }
        public function stopConvivaMonitorSession():void{
            super.stopMonitor();
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import com.akamai.rss.*;
    import org.openvideoplayer.events.*;
    import com.ibm.AS3util.*;
    import org.openvideoplayer.net.*;
    import flash.events.*;

    public class AkamaiBOSS extends EventDispatcher {

        private var _id:String;
        private var _bossMetafile:AkamaiBOSSParser;
        private var _bossLink:String;

        public function AkamaiBOSS(id:String):void{
            super();
            this._id = id;
            this._bossMetafile = new AkamaiBOSSParser();
            this._bossMetafile.addEventListener(OvpEvent.PARSED, this.bossParsedHandler);
            this._bossMetafile.addEventListener(OvpEvent.LOADED, this.bossLoadHandler);
            this._bossMetafile.addEventListener(OvpEvent.ERROR, this.errorHandler);
        }
        public function loadBoss(file:String):void{
            this._bossLink = file;
            this._bossMetafile.load(this._bossLink);
        }
        private function bossLoadHandler(e:OvpEvent):void{
            Debug.getInstance().traceDebug("AkamaiBOSS.bossLoadHandler");
        }
        private function bossParsedHandler(e:OvpEvent):void{
            Debug.getInstance().traceDebug(("AkamaiBOSS.bossParsedHandler: " + this._bossMetafile.versionOfMetafile));
            switch (this._bossMetafile.versionOfMetafile){
                case this._bossMetafile.METAFILE_VERSION_I:
                    break;
                case this._bossMetafile.METAFILE_VERSION_II:
                    break;
                case this._bossMetafile.METAFILE_VERSION_IV:
                    break;
            };
            var bossObject:Object = new Object();
            bossObject.hostName = this._bossMetafile.hostName;
            bossObject.streamName = this._bossMetafile.streamName;
            bossObject.isLive = this._bossMetafile.isLive;
            if (this._bossMetafile.connectAuthParams.length > 0){
                bossObject.connectionAuth = this._bossMetafile.connectAuthParams;
            } else {
                bossObject.connectionAuth = null;
            };
            if (this._bossMetafile.playAuthParams.length > 0){
                bossObject.playAuth = this._bossMetafile.playAuthParams;
            } else {
                bossObject.playAuth = null;
            };
            dispatchEvent(new ConnectionEvent(ConnectionEvent.BOSS_DATA, bossObject));
        }
        private function errorHandler(e:OvpEvent):void{
            Debug.getInstance().traceError(((((("AkamaiBOSS.bossParsedHandler Error #" + e.data.errorNumber) + " ") + e.data.errorDescription) + " ") + e.currentTarget));
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import org.openvideoplayer.net.*;
    import org.openvideoplayer.events.*;
    import flash.events.*;
    import flash.utils.*;
    import com.ibm.AS3util.*;
    import flash.net.*;

    public class FMSConnection extends ConvivaMediaConnection implements IMediaServerConnection {

        public const INIT_BUFFER:int = 3;
        public const INIT_LIVE_TIMEOUT:int = 3600;
        public const CDN:String = "Akamai";
        public const LIVE:String = "live";
        public const ONDEMAND:String = "ondemand";

        private var _bytesLoaded:Number;
        private var _currentVolume:Number;
        private var _bitrate:Number;
        private var _startPosition:Number;
        private var _initialSeek:Boolean;
        private var _isPlaying:Boolean;
        private var _isAvailable:Boolean;
        private var _bandwidth:String;
        private var _latency:String;
        private var _fpsTimer:Timer;
        private var _bandwidthTimer:Timer;
        private var _checkMetrics:Boolean;
        private var _videoStats:VideoStats;
        private var _timeRemaining:uint;
        private var _checkBandwidth:Boolean;
        private var _checkFPS:Boolean;
        private var _buffer:int;
        private var _liveTimeout:int;
        private var _hostname:String;
        private var _streamname:String;
        private var _streamtype:String;
        private var _dvrAvailable:int;

        public function FMSConnection(id:String, streamInfo:StreamObject):void{
            super(id, streamInfo);
            this._isPlaying = false;
            this._isAvailable = true;
            this._checkBandwidth = false;
            this._checkFPS = false;
            _nc = new OvpConnection();
            _nc.addEventListener(OvpEvent.ERROR, this.onError);
            _nc.addEventListener(NetStatusEvent.NET_STATUS, this.netStatusHandler);
            _nc.addEventListener(IOErrorEvent.IO_ERROR, this.ioErrorHandler);
            _nc.addEventListener(OvpEvent.BANDWIDTH, this.bandwidthHandler);
            this._fpsTimer = new Timer(1000);
            this._fpsTimer.addEventListener(TimerEvent.TIMER, this.updateFPS);
            this._bandwidthTimer = new Timer(10000);
            this._bandwidthTimer.addEventListener(TimerEvent.TIMER, this.updateBandwidth);
        }
        public function startPlayback(url:String, streamType:String, seekPos:Number, dvrTime:int=0, buffer:int=3, liveTimeout:int=3600, bitrate:Number=0):void{
            var temp:Array;
            var streamURL:Array = String(url).split("?");
            var secure:Boolean = (((streamURL[1] > 0)) ? true : false);
            this._bitrate = bitrate;
            this._startPosition = ((seekPos)==-1) ? -2 : seekPos;
            this._buffer = buffer;
            this._liveTimeout = liveTimeout;
            this._initialSeek = true;
            this._isPlaying = true;
            this._isAvailable = false;
            var hostname:String = "";
            var streamname:String = "";
            this._streamtype = streamType;
            temp = streamURL[0].split("/");
            if (temp[0].indexOf("rtmp") == 0){
                temp.splice(0, 2);
            };
            if (temp[(temp.length - 1)].lastIndexOf(".flv") > -1){
                temp[(temp.length - 1)] = temp[(temp.length - 1)].substring(0, (temp[(temp.length - 1)].length - 4));
            };
            var nameIndex:int = String(streamURL[0]).lastIndexOf("/");
            hostname = String(streamURL[0]).substring(0, nameIndex);
            if (hostname.indexOf("rtmp://") == 0){
                hostname = hostname.substring(7, hostname.length);
            };
            this._streamname = String(streamURL[0]).substring((nameIndex + 1), String(streamURL[0]).length);
            Debug.getInstance().traceInfo(((((("FMSConnection[" + _id) + "].startPlayback: ") + _ns) + " | ") + secure));
            if (((((!((this._hostname == hostname))) || (!((_ns is OvpNetStream))))) || (secure))){
                if ((_nc.netConnection is NetConnection)){
                    _nc.close();
                };
                this._hostname = hostname;
                super.connectNetConnection(OvpConnection, this._hostname);
            } else {
                _ns.maxBufferLength = this._buffer;
                _ns.play(this._streamname);
            };
        }
        public function stopPlayback():void{
            Debug.getInstance().traceInfo((("FMSConnection[" + _id) + "].stopPlayback: "));
            if (_ns){
                Debug.getInstance().traceError((("FMSConnection[" + _id) + "].stopPlayback _ns.close()"));
                _ns.close();
            };
            this._isPlaying = false;
            this._isAvailable = true;
            this._fpsTimer.stop();
            this._bandwidthTimer.stop();
        }
        public function pause():void{
            _ns.pause();
        }
        public function resume():void{
            _ns.resume();
        }
        public function seek(position:Number):void{
            _ns.seek(position);
        }
        public function goLive():void{
        }
        public function updateBuffer(value:int):void{
            _ns.maxBufferLength = value;
        }
        public function setVolume(value:Number):void{
            this._currentVolume = value;
            if (_ns){
                _ns.volume = this._currentVolume;
            };
        }
        public function getVolume():Number{
            return (this._currentVolume);
        }
        public function setMaxBitrate(value:int):void{
        }
        public function close():void{
        }
        public function setVideoStats(videoStats:VideoStats):void{
            this._videoStats = videoStats;
            if (this._videoStats){
                this._videoStats.removeEventListener(Event.CHANGE, this.onMetrics);
                this._videoStats.addEventListener(Event.CHANGE, this.onMetrics);
                this.onMetrics(new Event(Event.CHANGE));
            };
            Debug.getInstance().traceDebug(((("AkamaiFMSConnection[" + _id) + "].setVideoStats: ") + this._checkMetrics));
        }
        public function setMediaAnalytics(value:Boolean):void{
        }
        private function onMetrics(e:Event):void{
            this._checkMetrics = this._videoStats.showMetrics;
            this._checkBandwidth = this._checkMetrics;
            this._checkFPS = this._checkMetrics;
            Debug.getInstance().traceDebug(((((("AkamaiConnection[" + _id) + "].getMetrics: ") + this._checkBandwidth) + " ") + this._checkFPS));
            if (((this._checkBandwidth) && (!(this._bandwidthTimer.running)))){
                this._bandwidthTimer.start();
            };
            if (((this._checkFPS) && (!(this._fpsTimer.running)))){
                this._fpsTimer.start();
            };
            if (!(this._checkBandwidth)){
                this._bandwidthTimer.stop();
            };
            if (!(this._checkFPS)){
                this._fpsTimer.stop();
            };
        }
        private function updateFPS(e:TimerEvent):void{
            var statusObj:Object = new Object();
            if (_ns){
                Debug.getInstance().traceDebug((("FMSConnection[" + _id) + "].updateFPS: "));
                statusObj.FPS = Math.round(_ns.currentFPS);
                statusObj.Buffer = _ns.bufferLength;
                statusObj.Server = ((_nc.serverIPaddress + ":") + _nc.actualPort);
                statusObj.Bandwidth = this._bandwidth;
                statusObj.Latency = this._latency;
                dispatchEvent(new ConnectionEvent(ConnectionEvent.STATUS_MESSAGE, statusObj));
            };
        }
        private function updateBandwidth(e:TimerEvent):void{
            if (this._checkBandwidth){
                Debug.getInstance().traceDebug((("FMSConnection[" + _id) + "].updateBandwidth: "));
                _nc.detectBandwidth();
            };
        }
        private function connectedHandler():void{
            Debug.getInstance().traceDebug(((((("FMSConnection[" + _id) + "].connectedHandler: Successfully connected using ") + _nc.actualProtocol) + " on port ") + _nc.actualPort));
            Debug.getInstance().traceDebug(((("FMSConnection[" + _id) + "].connectedHandler: LiveTimout - ") + this._liveTimeout));
            super.attachLivePassStreamer(OvpNetStream);
            _ns.streamTimeout = this._liveTimeout;
            _ns.client = this;
            if (this._streamtype == this.ONDEMAND){
            };
            _ns.addEventListener(NetStatusEvent.NET_STATUS, this.netStreamStatusHandler);
            _ns.addEventListener(OvpEvent.COMPLETE, this.completeHandler);
            _ns.addEventListener(OvpEvent.NETSTREAM_METADATA, this.metadataHandler);
            _ns.addEventListener(OvpEvent.STREAM_LENGTH, this.streamLengthHandler);
            _ns.addEventListener(OvpEvent.PROGRESS, this.progressHandler);
            _ns.addEventListener(OvpEvent.ERROR, this.onNetstreamError);
            _ns.maxBufferLength = this._buffer;
            _ns.play(this._streamname);
            this.setVolume(this._currentVolume);
        }
        private function netStatusHandler(e:NetStatusEvent):void{
            Debug.getInstance().traceInfo(((("FMSConnection[" + _id) + "].netStatusHandler ") + e.info.code));
            switch (e.info.code){
                case "NetConnection.Connect.Rejected":
                    Debug.getInstance().traceInfo(((("FMSConnection[" + _id) + "].netStatusHandler Rejected by server. Reason is ") + e.info.description));
                    super.reportNetStatusEvent(e);
                    break;
                case "NetConnection.Connect.Success":
                    this.connectedHandler();
                    break;
                case "NetConnection.Connect.Closed":
                    this._hostname = "";
                    super.reportNetStatusEvent(e);
                    break;
                default:
                    super.reportNetStatusEvent(e);
            };
        }
        private function ioErrorHandler(e:IOErrorEvent):void{
            Debug.getInstance().traceInfo(((("FMSConnection[" + _id) + "].ioErrorHandler ") + e.toString()));
        }
        private function netStreamStatusHandler(e:NetStatusEvent):void{
            Debug.getInstance().traceInfo(((("FMSConnection[" + _id) + "].netStreamStatusHandler ") + e.info.code));
            switch (e.info.code){
                case "NetStream.Play.Start":
                    this._isPlaying = true;
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STARTED, this));
                    Debug.getInstance().traceInfo(((("FMSConnection[" + _id) + "].netStreamStatusHandler ") + _ns.streamTimeout));
                    break;
                case "NetStream.Play.Stop":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_STOPPED, this));
                    break;
                case "NetStream.Buffer.Full":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.BUFFER_FULL, this));
                    break;
                case "NetStream.Play.InsufficientBW":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.BANDWIDTH_WARNING, this));
                    break;
                case "NetStream.Failed":
                    dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, this));
                    break;
            };
        }
        private function progressHandler(e:OvpEvent):void{
            var videoTime:Object = new Object();
            videoTime.timeAsTimeCode = _ns.timeAsTimeCode;
            videoTime.streamLengthAsTimeCode = _nc.streamLengthAsTimeCode(_ns.streamLength);
            videoTime.time = _ns.time;
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_PROGRESS, videoTime));
        }
        private function completeHandler(e:OvpEvent):void{
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_COMPLETE, ""));
        }
        private function streamLengthHandler(e:OvpEvent):void{
            Debug.getInstance().traceInfo(((("FMSConnection[" + _id) + "].streamLengthHandler: ") + _nc.streamLengthAsTimeCode(_ns.streamLength)));
        }
        private function onError(e:OvpEvent):void{
            Debug.getInstance().traceInfo(((((("FMSConnection[" + _id) + "].onError ") + e.data.errorNumber) + " ") + e.data.errorDescription));
            dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, e.data.errorDescription));
        }
        private function metadataHandler(e:OvpEvent):void{
            var propName:String;
            for (propName in e.data) {
                Debug.getInstance().traceDebug(((((("FMSConnection[" + _id) + "].metadataHandler: ") + propName) + " = ") + e.data[propName]));
            };
            dispatchEvent(new ConnectionEvent(ConnectionEvent.META_DATA, e.data));
        }
        private function bandwidthHandler(e:OvpEvent):void{
            if (e.data.bandwidth < this._bitrate){
            };
            this._bandwidth = (e.data.bandwidth + " kbps");
            this._latency = (e.data.latency + " ms");
        }
        private function onNetstreamError(e:OvpEvent):void{
            Debug.getInstance().traceInfo(((((("FMSConnection[" + _id) + "].onNetstreamError ") + e.data.errorNumber) + " ") + e.data.errorDescription));
            if ((((e.data.errorNumber == 9)) || ((e.data.errorNumber == 6)))){
                dispatchEvent(new ConnectionEvent(ConnectionEvent.PLAYBACK_ERROR, e.data));
            };
        }
        public function get netStream():NetStream{
            return (_ns);
        }
        public function get id():String{
            return (_id);
        }
        public function get isPlaying():Boolean{
            return (this._isPlaying);
        }
        public function get isAvailable():Boolean{
            return (this._isAvailable);
        }
        public function get streamtype():String{
            return (this._streamtype);
        }
        public function get dvrAvailable():int{
            return (this._dvrAvailable);
        }
        public function get startPosition():Number{
            return (this._startPosition);
        }
        public function get recycledConnection():Boolean{
            return (_recycledConnection);
        }
        public function set recycledConnection(value:Boolean):void{
            _recycledConnection = value;
        }
        public function startConvivaMonitorSession(streamInfo:StreamObject):void{
            super.startMonitor(streamInfo);
        }
        public function stopConvivaMonitorSession():void{
            super.stopMonitor();
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import flash.events.*;

    public class VideoControlEvent extends Event {

        public static const SEEK:String = "seek";
        public static const VOLUME:String = "volume";
        public static const PAUSE:String = "pause";
        public static const PLAY:String = "play";
        public static const LIVE:String = "live";
        public static const REACHED_LIVE:String = "reached_live";
        public static const FULLSCREEN:String = "fullscreen";
        public static const SCRUB:String = "scrub";
        public static const TIME_UPDATE:String = "time_update";
        public static const SCRUB_ERROR:String = "scrub_error";

        public var info:Object;

        public function VideoControlEvent(type:String, info:Object){
            super(type);
            this.info = info;
        }
        override public function clone():Event{
            return (new VideoControlEvent(type, this.info));
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import org.openvideoplayer.net.dynamicstream.*;
    import com.ibm.AS3util.*;
    import flash.events.*;

    public class BandwidthRuleEvents extends EventDispatcher implements ISwitchingRule {

        private const BANDWIDTH_SAFETY_MULTIPLE:Number = 1.15;

        private var _metrics:INetStreamMetrics;
        private var _panicMode:Boolean;
        private var _reason:String;
        private var _maxBitrate:int;

        public function BandwidthRuleEvents(metrics:INetStreamMetrics, maxBitrate:int):void{
            super(null);
            this._metrics = metrics;
            this._maxBitrate = maxBitrate;
        }
        public function getNewIndex():int{
            var i:int;
            var newIndex:int = -1;
            if (this._metrics.averageMaxBandwidth != 0){
                i = (this._metrics.dynamicStreamItem.streamCount - 1);
                while (i >= 0) {
                    Debug.getInstance().traceDebug(((((("FMSBandwidthRuleEvents.getnewIndex: " + Math.round(this._metrics.averageMaxBandwidth)) + " ") + Math.round((this._metrics.dynamicStreamItem.getRateAt(i) * this.BANDWIDTH_SAFETY_MULTIPLE))) + " ") + (this._metrics.averageMaxBandwidth > (this._metrics.dynamicStreamItem.getRateAt(i) * this.BANDWIDTH_SAFETY_MULTIPLE))));
                    if ((((this._metrics.averageMaxBandwidth > (this._metrics.dynamicStreamItem.getRateAt(i) * this.BANDWIDTH_SAFETY_MULTIPLE))) && ((this._metrics.dynamicStreamItem.getRateAt(i) <= this._maxBitrate)))){
                        newIndex = i;
                        this._reason = (((((((((("BandwidthRuleEvents - new:" + newIndex) + " cur:") + this._metrics.currentIndex) + " ") + Math.round(this._metrics.averageMaxBandwidth)) + " average > ") + this.BANDWIDTH_SAFETY_MULTIPLE) + " * rb (") + this._metrics.dynamicStreamItem.getRateAt(i)) + ")");
                        this._reason = (this._reason + (((" and rb (" + this._metrics.dynamicStreamItem.getRateAt(i)) + ") < ") + this._maxBitrate));
                        break;
                    };
                    i--;
                };
                if (newIndex > this._metrics.currentIndex){
                    if ((((this._metrics.droppedFPS < 2)) && ((this._metrics.bufferLength > this._metrics.targetBufferTime)))){
                        this._reason = (this._reason + " and FPS and Buffer OK");
                    } else {
                        newIndex = -1;
                        this._reason = (this._reason + " and FPS and Buffer not OK, newIndex: -1");
                    };
                };
            };
            return (newIndex);
        }
        public function get reason():String{
            return (this._reason);
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import com.conviva.*;
    import com.ibm.AS3util.*;
    import flash.events.*;

    public class ConvivaMediaConnection extends EventDispatcher {

        private var _livePassSession:ConvivaLightSession;
        private var _convivaSessionAttached:Boolean = false;
        protected var _streamInfo:StreamObject;
        protected var _id:String;
        protected var _nc;
        protected var _ns;
        protected var _recycledConnection:Boolean = false;

        public function ConvivaMediaConnection(id:String, streamInfo:StreamObject):void{
            super();
            this._id = id;
            this._streamInfo = streamInfo;
            if (this._streamInfo.videoLocation == StreamObject.VIDEO_MAIN){
                this._livePassSession = LivePass.createMonitoringSession(null, streamInfo.channelName, streamInfo.convivaTags, streamInfo.convivaOptions);
            };
        }
        protected function reportNetStatusEvent(e:NetStatusEvent):void{
            var e:* = e;
            try {
                if (!(this._convivaSessionAttached)){
                    this._livePassSession.reportNetStatusEvent(e);
                };
            } catch(error:Error) {
                Debug.getInstance().traceError(((("ConvivaMediaConnection.reportNetStatusEvent: " + error.errorID) + ": ") + error.message));
            };
        }
        protected function connectNetConnection(netConnectionClass:Class, connectURL:String):void{
            var netConnectionClass:* = netConnectionClass;
            var connectURL:* = connectURL;
            try {
                (this._nc as netConnectionClass).connect(connectURL);
            } catch(e:Error) {
                Debug.getInstance().traceError(((("ConvivaMediaConnection.connectNetConnection: " + e.errorID) + ": ") + e.message));
                if (_streamInfo.videoLocation == StreamObject.VIDEO_MAIN){
                    _livePassSession.reportError(ConvivaLightSession.ERROR_CONNECTION_FAILURE);
                };
            };
        }
        protected function attachLivePassStreamer(StreamClass:Class):void{
            var StreamClass:* = StreamClass;
            try {
                this._ns = new StreamClass(this._nc);
                if (this._streamInfo.videoLocation == StreamObject.VIDEO_MAIN){
                    this._livePassSession.attachStreamer(this._ns);
                    this._convivaSessionAttached = true;
                };
            } catch(e:Error) {
                Debug.getInstance().traceError(((("ConvivaMediaConnection.attachLivePassStreamer: " + e.errorID) + ": ") + e.message));
                if (_streamInfo.videoLocation == StreamObject.VIDEO_MAIN){
                    _livePassSession.reportError(ConvivaLightSession.ERROR_STREAMING_FAILURE);
                };
            };
        }
        protected function setCurrentBitrate(newRenderingIndex:uint):void{
            var newRenderingIndex:* = newRenderingIndex;
            try {
                this._livePassSession.setCurrentBitrate((this._streamInfo.convivaBitrates[newRenderingIndex] as uint));
            } catch(e:Error) {
                Debug.getInstance().traceError(((("ConvivaMediaConnection.setCurrentBitrate: " + e.errorID) + ": ") + e.message));
                Debug.getInstance().traceError(("Unable to determine new bitrate from index of " + newRenderingIndex));
            };
        }
        protected function stopMonitor():void{
            this._convivaSessionAttached = false;
            this._livePassSession.stopMonitor();
        }
        protected function startMonitor(streamInfo:StreamObject):void{
            var streamInfo:* = streamInfo;
            if (this._streamInfo.videoLocation == StreamObject.VIDEO_MAIN){
                this._streamInfo = streamInfo;
                this._livePassSession = LivePass.createMonitoringSession(null, this._streamInfo.channelName, this._streamInfo.convivaTags, this._streamInfo.convivaOptions);
                try {
                    this._livePassSession.attachStreamer(this._ns);
                    this._convivaSessionAttached = true;
                } catch(e) {
                    Debug.getInstance().traceError(((("ConvivaMediaConnection.startMonitor: " + e.errorID) + ": ") + e.message));
                    _livePassSession.reportError(ConvivaLightSession.ERROR_STREAMING_FAILURE);
                };
            };
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import flash.events.*;

    public class ConnectionEvent extends Event {

        public static const PLAYBACK_STOPPED:String = "playback_stopped";
        public static const PLAYBACK_STARTED:String = "playback_started";
        public static const PLAYBACK_ERROR:String = "playback_error";
        public static const PLAYBACK_COMPLETE:String = "playback_complete";
        public static const PLAYBACK_PROGRESS:String = "playback_progress";
        public static const BUFFER_FULL:String = "buffer_full";
        public static const RENDITION_SWITCH:String = "rendition_switch";
        public static const STOP_MAIN:String = "stop_main";
        public static const STREAM_ERROR:String = "stream_error";
        public static const BANDWIDTH_WARNING:String = "bandwidth_warning";
        public static const STATUS_MESSAGE:String = "status_message";
        public static const BOSS_DATA:String = "boss_data";
        public static const META_DATA:String = "meta_data";
        public static const TIME_UPDATE:String = "time_update";
        public static const OCTOSHAPE_ASK:String = "octoshape_ask";
        public static const OCTOSHAPE_INSTALLED:String = "octoshape_installed";
        public static const OCTOSHAPE_REJECTED:String = "octoshape_rejected";
        public static const TOKEN_EXPIRED:String = "token_expired";

        public var info:Object;

        public function ConnectionEvent(type:String, info:Object){
            super(type);
            this.info = info;
        }
        override public function clone():Event{
            return (new ConnectionEvent(type, this.info));
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import com.ibm.AS3util.*;
    import flash.display.*;
    import flash.events.*;
    import flash.media.*;
    import flash.net.*;
    import gs.*;
    import flash.geom.*;
    import flash.text.*;
    import flash.utils.*;

    public class VideoControlBar extends Sprite {

        public static var TYPE_LIVE:String = "live";
        public static var TYPE_ON_DEMAND:String = "ondemand";
        public static var TYPE_PROGRESSIVE:String = "progressive";

        private const INIT_VIEW_TIME:Number = 2000;

        private var _stage:MovieClip;
        private var _video:Video;
        private var _measureClickAction:Function;
        private var _netStream:NetStream;
        private var _bar:MovieClip;
        private var _xMin:Number;
        private var _xMax:Number;
        private var _vol_xMin:Number;
        private var _vol_xMax:Number;
        private var _volPercent:Number;
        private var _lastVolume:Number;
        private var _initVolume:Boolean;
        private var _contentType:String;
        private var _mouseOver:Boolean;
        private var _isLive:Boolean = true;
        private var _boolProgressScrub:Boolean;
        private var _boolVolumeScrub:Boolean;
        private var _updateTimer:Timer;
        private var _scrubWidth:Number;
        private var _volScrubWidth:Number;
        private var _onDemandDuration:Number;
        private var _dvrTimeBar:MovieClip;
        private var _DVREvents:Array;
        private var _minDVRtime:Number;
        private var _maxDVRtime:Number;
        private var _curDVRtime:Number;
        private var _startTime:Number;
        private var _paused:Boolean;
        private var _volumeControls:MovieClip;
        private var _fullscreenControls:MovieClip;
        private var _fullScreenMode:Boolean = false;
        private var _marker;
        private var _twoPartTimeline:Boolean;
        private var _descriptionEnabled:Boolean;
        private var _descriptionField:TextField;
        private var _descriptionText:String = "";

        public function VideoControlBar(display:MovieClip, video:Video, bar:MovieClip, measureFunction:Function=null, twoPartTimeline:Boolean=false, descriptionEnabled:Boolean=false){
            var display:* = display;
            var video:* = video;
            var bar:* = bar;
            var measureFunction = measureFunction;
            var twoPartTimeline:Boolean = twoPartTimeline;
            var descriptionEnabled:Boolean = descriptionEnabled;
            this._fullscreenControls = new MovieClip();
            super();
            Debug.getInstance().traceDebug(("VideoControlBar.constructor: " + display));
            this._stage = display;
            this._video = video;
            this._measureClickAction = measureFunction;
            this._bar = bar;
            this._boolProgressScrub = false;
            this._boolVolumeScrub = false;
            this._mouseOver = false;
            this._DVREvents = new Array();
            this._paused = false;
            this._twoPartTimeline = twoPartTimeline;
            this._descriptionEnabled = descriptionEnabled;
            this.addChild(this._bar);
            this._bar.alpha = 0;
            this._bar.onDemandControls.y = 0;
            this._bar.onDemandControls.playButton.buttonMode = true;
            this._bar.onDemandControls.playButton.addEventListener(MouseEvent.CLICK, this.onPlayClick);
            this._bar.onDemandControls.pauseButton.buttonMode = true;
            this._bar.onDemandControls.pauseButton.addEventListener(MouseEvent.CLICK, this.onPauseClick);
            this._bar.onDemandControls.fullscreen.buttonMode = true;
            this._bar.onDemandControls.fullscreen.addEventListener(MouseEvent.CLICK, this.onFullscreenClick);
            this._bar.onDemandControls.scrubber.buttonMode = true;
            this._bar.onDemandControls.scrubber.addEventListener(MouseEvent.MOUSE_DOWN, this.progressScrubberClicked);
            this._bar.onDemandControls.scrubber.addEventListener(MouseEvent.MOUSE_UP, this.progressScrubberReleased);
            this._bar.onDemandControls.markerHolder.addEventListener(MouseEvent.CLICK, this.onTimeshiftClick);
            if (this._descriptionEnabled){
                this._bar.onDemandControls.description.text = "";
            };
            this._bar.onDemandControls.volumeControl.volumeScrubber.alpha = 0;
            this._bar.onDemandControls.volumeControl.volumeScrubber.visible = false;
            this._bar.onDemandControls.volumeControl.buttonMode = true;
            this._bar.onDemandControls.volumeControl.speakerButton.addEventListener(MouseEvent.CLICK, this.mute);
            this._bar.onDemandControls.volumeControl.speakerButton.addEventListener(MouseEvent.MOUSE_OVER, this.rollOnSpeaker);
            this._bar.onDemandControls.volumeControl.speakerButton.addEventListener(MouseEvent.MOUSE_OUT, this.rollOffSpeaker);
            this._bar.onDemandControls.volumeControl.volumeScrubber.slider.buttonMode = true;
            this._bar.onDemandControls.volumeControl.volumeScrubber.slider.addEventListener(MouseEvent.MOUSE_DOWN, this.volumeScrubberClicked);
            this._bar.onDemandControls.playButton.visible = false;
            this._bar.onDemandControls.pauseButton.visible = true;
            this._dvrTimeBar = this._bar.dvrControls;
            this._dvrTimeBar.scrubber.x = (this._dvrTimeBar.timeline.x + this._dvrTimeBar.timeline.hitfield.width);
            this._dvrTimeBar.scrubber.addEventListener(MouseEvent.MOUSE_DOWN, this.onTimeshiftChange);
            this._dvrTimeBar.timeline.hitfield.addEventListener(MouseEvent.CLICK, this.onTimeshiftClick);
            if (this._twoPartTimeline){
                try {
                    this._dvrTimeBar.timeline.pastBar.visible = false;
                    (this._dvrTimeBar.timeline.pastBar as MovieClip).mouseEnabled = false;
                    (this._dvrTimeBar.timeline.pastBar as MovieClip).mouseChildren = false;
                } catch(e:Error) {
                    Debug.getInstance().traceError(e.message);
                };
            };
            this._bar.dvrControls.inactiveOverlay.visible = false;
            this._bar.dvrControls.y = 0;
            this._bar.dvrControls.dvrReplay.buttonMode = true;
            this._bar.dvrControls.dvrLive.buttonMode = true;
            this._bar.dvrControls.dvrPause.buttonMode = true;
            this._bar.dvrControls.dvrPlay.buttonMode = true;
            this._bar.dvrControls.dvrPlay.visible = false;
            this._bar.dvrControls.fullscreen.buttonMode = true;
            this._bar.dvrControls.fullscreen.addEventListener(MouseEvent.CLICK, this.onFullscreenClick);
            this._bar.dvrControls.dvrReplay.addEventListener(MouseEvent.CLICK, this.onReplayClick);
            this._bar.dvrControls.dvrLive.addEventListener(MouseEvent.CLICK, this.onLiveClick);
            this._bar.dvrControls.dvrPause.addEventListener(MouseEvent.CLICK, this.onPauseClick);
            this._bar.dvrControls.dvrPlay.addEventListener(MouseEvent.CLICK, this.onPlayClick);
            this._bar.dvrControls.volumeControl.volumeScrubber.alpha = 0;
            this._bar.dvrControls.volumeControl.volumeScrubber.visible = false;
            this._bar.dvrControls.volumeControl.buttonMode = true;
            this._bar.dvrControls.volumeControl.speakerButton.addEventListener(MouseEvent.CLICK, this.mute);
            this._bar.dvrControls.volumeControl.speakerButton.addEventListener(MouseEvent.MOUSE_OVER, this.rollOnSpeaker);
            this._bar.dvrControls.volumeControl.speakerButton.addEventListener(MouseEvent.MOUSE_OUT, this.rollOffSpeaker);
            this._bar.dvrControls.volumeControl.volumeScrubber.slider.buttonMode = true;
            this._bar.dvrControls.volumeControl.volumeScrubber.slider.addEventListener(MouseEvent.MOUSE_DOWN, this.volumeScrubberClicked);
            this._volScrubWidth = this._bar.dvrControls.volumeControl.volumeScrubber.volumeTrack.width;
            this._bar.dvrControls.fullscreen.closeState.visible = this._fullScreenMode;
            this._bar.onDemandControls.fullscreen.closeState.visible = this._fullScreenMode;
            this.addEventListener(MouseEvent.ROLL_OVER, this.onRollOver);
            this.addEventListener(MouseEvent.ROLL_OUT, this.onRollOut);
            this.visible = false;
        }
        private static function getDisplayDate(num=null):String{
            if (num){
                return (PhpDate.format("m-d-y H:i:s", Math.round((num / 1000))));
            };
            return ("N/A");
        }
        private static function getDisplayTimeMin(num=null):String{
            if (num){
                return (PhpDate.format("i:s", Math.round((num / 1000))));
            };
            return ("N/A");
        }
        private static function getDisplayTime(num=null):String{
            if (num){
                return (PhpDate.format("H:i:s", Math.round((num / 1000))));
            };
            return ("N/A");
        }

        private function setDVRTimebarWidth():void{
            if (this._twoPartTimeline){
                this._dvrTimeBar.timeline.pastBar.width = (this._dvrTimeBar.scrubber.x - this._dvrTimeBar.timeline.x);
                this._dvrTimeBar.timeline.pastBar.visible = true;
            };
        }
        public function setDescription(descriptionText:String):void{
            var descriptionText:* = descriptionText;
            try {
                this._descriptionField.text = descriptionText;
            } catch(e:Error) {
                Debug.getInstance().traceError(("VideoControlBar.setDescription() Error: " + e.message));
            };
            this._descriptionText = descriptionText;
        }
        public function setContentType(which:String, netStream:NetStream, parentWidth:int, dvr:int=0, startTime:Number=0):void{
            Debug.getInstance().traceDebug(((((("VideoControlBar.contentType: " + which) + " ") + dvr) + " ") + this._stage));
            this._contentType = which;
            this._startTime = startTime;
            this._netStream = netStream;
            this.clearVideoControlEvents();
            if (this._contentType == TYPE_LIVE){
                this._bar.onDemandControls.visible = false;
                this._volumeControls = this._bar.dvrControls.volumeControl;
                this._fullscreenControls = this._bar.dvrControls.fullscreen;
                this.setDVRbar((((dvr > 0)) ? true : false));
            } else {
                if (this._contentType == TYPE_ON_DEMAND){
                    this._volumeControls = this._bar.onDemandControls.volumeControl;
                    this._fullscreenControls = this._bar.onDemandControls.fullscreen;
                    this._bar.onDemandControls.visible = true;
                    this._bar.onDemandControls.scrubberProgressLoaded.visible = false;
                    this._bar.dvrControls.visible = false;
                    this._bar.onDemandControls.playButton.visible = false;
                    this._bar.onDemandControls.pauseButton.visible = true;
                    if (this._descriptionEnabled){
                        this._descriptionField = this._bar.onDemandControls.description;
                        this._descriptionField.text = this._descriptionText;
                    };
                } else {
                    if (this._contentType == TYPE_PROGRESSIVE){
                        Debug.getInstance().traceDebug("VideoControlBar.contentType: progressive");
                        this._volumeControls = this._bar.onDemandControls.volumeControl;
                        this._fullscreenControls = this._bar.onDemandControls.fullscreen;
                        this._bar.onDemandControls.visible = true;
                        this._bar.onDemandControls.scrubberProgressLoaded.visible = true;
                        this._bar.dvrControls.visible = false;
                        this._bar.onDemandControls.playButton.visible = false;
                        this._bar.onDemandControls.pauseButton.visible = true;
                    } else {
                        this._bar.onDemandControls.visible = false;
                        this._bar.dvrControls.visible = false;
                    };
                };
            };
            this._scrubWidth = this._bar.onDemandControls.scrubberBackground.width;
            this._bar.onDemandControls.scrubberProgressPlay.width = 1;
            this._bar.onDemandControls.scrubberProgressLoaded.width = 1;
            this._dvrTimeBar.scrubber.x = (this._dvrTimeBar.timeline.x + this._dvrTimeBar.timeline.hitfield.width);
            this.setDVRTimebarWidth();
            this.movedToLive();
            if (this._startTime > 0){
                this.movedToDVR();
            };
            if (this._lastVolume > 0){
                this._volumeControls.speakerButton.speaker.gotoAndStop(1);
                this._volumeControls.volumeScrubber.slider.x = (this._volScrubWidth * this._lastVolume);
            } else {
                this._volumeControls.speakerButton.speaker.gotoAndStop(2);
                this._volumeControls.volumeScrubber.slider.x = 0;
            };
            this.visible = true;
        }
        public function setDVRbar(active:Boolean):void{
            if (active){
                this._bar.dvrControls.inactiveOverlay.visible = false;
            } else {
                this._bar.dvrControls.inactiveOverlay.visible = true;
            };
        }
        public function setOnDemandBar(duration:Number):void{
            var duration:* = duration;
            this._onDemandDuration = duration;
            try {
                this._bar.onDemandControls.timeCode.text = getDisplayTimeMin((duration * 1000));
            } catch(e:Error) {
                Debug.getInstance().traceError(("VideoControlBar.setOnDemandBar: " + e.toString()));
            };
        }
        public function setVolumeControl(setVolume:Number):void{
            this._lastVolume = setVolume;
            Debug.getInstance().traceDebug(("VideoControlBar.setVolumeControl: " + this._lastVolume));
        }
        public function showBar():void{
            if (this._bar.alpha < 1){
                TweenLite.to(this._bar, 0.7, {alpha:1});
            };
        }
        public function hideBar():void{
            if (!(this._mouseOver)){
                TweenLite.to(this._bar, 0.7, {alpha:0});
            };
        }
        public function stopUpdates():void{
            this._updateTimer.stop();
        }
        public function updateDisplay():void{
            try {
                if (!(this._boolProgressScrub)){
                    this._bar.onDemandControls.scrubber.x = (this._bar.onDemandControls.scrubberBackground.x + Math.round((this._scrubWidth * (this._netStream.time / this._onDemandDuration))));
                };
                this._bar.onDemandControls.scrubberProgressPlay.width = (this._bar.onDemandControls.scrubber.x - this._bar.onDemandControls.scrubberBackground.x);
                this._bar.onDemandControls.scrubberProgressLoaded.width = ((this._netStream.bytesLoaded * this._scrubWidth) / this._netStream.bytesTotal);
                if (this._boolVolumeScrub){
                    this.setVolume((this._volumeControls.volumeScrubber.slider.x / this._volScrubWidth));
                };
            } catch(e:Error) {
            };
        }
        public function updateFullscreen(fullscreen:Boolean):void{
            this._fullScreenMode = fullscreen;
            this._fullscreenControls.openState.visible = !(this._fullScreenMode);
            this._fullscreenControls.closeState.visible = this._fullScreenMode;
        }
        public function playbackContinued():void{
            Debug.getInstance().traceDebug(("VideoControlBar.playbackContinued: " + this._netStream.time));
            this._boolProgressScrub = false;
        }
        private function progressScrubberClicked(e:MouseEvent):void{
            this._boolProgressScrub = true;
            (this._bar.onDemandControls.scrubber as MovieClip).startDrag(false, new Rectangle(this._bar.onDemandControls.scrubberBackground.x, 0, this._scrubWidth, 0));
            this._stage.addEventListener(MouseEvent.MOUSE_UP, this.progressScrubberReleased);
        }
        private function progressScrubberReleased(e:MouseEvent):void{
            var scrubPos:int;
            var seekPos:int;
            this._stage.removeEventListener(MouseEvent.MOUSE_UP, this.progressScrubberReleased);
            this._bar.onDemandControls.scrubber.stopDrag();
            if (this._boolProgressScrub){
                scrubPos = (this._bar.onDemandControls.scrubber.x - this._bar.onDemandControls.scrubberBackground.x);
                seekPos = Math.round(((scrubPos * this._onDemandDuration) / this._scrubWidth));
                Debug.getInstance().traceDebug(("VideoControlBar.progressScrubberReleased: " + seekPos));
                dispatchEvent(new VideoControlEvent(VideoControlEvent.SCRUB, seekPos));
                this._bar.onDemandControls.scrubberProgressPlay.width = (this._bar.onDemandControls.scrubber.x - this._bar.onDemandControls.scrubberBackground.x);
            };
        }
        private function volumeScrubberReleased(e:MouseEvent):void{
            this._stage.removeEventListener(MouseEvent.MOUSE_UP, this.volumeScrubberReleased);
            this._volumeControls.volumeScrubber.stopDrag();
            if (this._boolVolumeScrub){
                this._boolVolumeScrub = false;
                this.setVolume((this._volumeControls.volumeScrubber.slider.x / this._volScrubWidth));
            };
        }
        private function volumeScrubberClicked(e:MouseEvent):void{
            this._stage.addEventListener(MouseEvent.MOUSE_UP, this.volumeScrubberReleased);
            this._boolVolumeScrub = true;
            this._volumeControls.volumeScrubber.slider.startDrag(false, new Rectangle(0, 0, this._volScrubWidth, 0));
        }
        private function onRollOver(e:MouseEvent):void{
            this._mouseOver = true;
        }
        private function onRollOut(e:MouseEvent):void{
            this._mouseOver = false;
        }
        private function setVolume(newVolume:Number=0):void{
            if (newVolume > 0){
                this._volumeControls.speakerButton.speaker.gotoAndStop(1);
                this._volumeControls.volumeScrubber.slider.x = (this._volScrubWidth * newVolume);
                this._lastVolume = newVolume;
            } else {
                this._volumeControls.speakerButton.speaker.gotoAndStop(2);
                this._volumeControls.volumeScrubber.slider.x = 0;
            };
            dispatchEvent(new VideoControlEvent(VideoControlEvent.VOLUME, newVolume));
        }
        private function mute(e:MouseEvent):void{
            Debug.getInstance().traceDebug(("VideoControlBar.mute: " + this._lastVolume));
            if (this._volumeControls.speakerButton.speaker.currentFrame == 1){
                this.setVolume(0);
            } else {
                this.setVolume(this._lastVolume);
            };
        }
        private function rollOnSpeaker(e:MouseEvent):void{
            this._volumeControls.volumeScrubber.addEventListener(MouseEvent.ROLL_OVER, this.rollOnVolumeScrubber);
            this._volumeControls.volumeScrubber.visible = true;
            TweenLite.to(this._volumeControls.volumeScrubber, 0.3, {alpha:1});
        }
        private function rollOffSpeaker(e:MouseEvent):void{
            TweenLite.to(this._volumeControls.volumeScrubber, 0.3, {
                alpha:0,
                onComplete:this.hideVolumeScrubber
            });
        }
        private function rollOnVolumeScrubber(e:MouseEvent):void{
            Debug.getInstance().traceDebug("VideoControlBar.rollOnVolumeScrubber:");
            this._volumeControls.volumeScrubber.addEventListener(MouseEvent.ROLL_OUT, this.rollOffVolumeScrubber);
            this._volumeControls.volumeScrubber.removeEventListener(MouseEvent.ROLL_OVER, this.rollOnVolumeScrubber);
            TweenLite.killTweensOf(this._volumeControls.volumeScrubber, false);
            this._volumeControls.volumeScrubber.visible = true;
            this._volumeControls.volumeScrubber.alpha = 1;
        }
        private function rollOffVolumeScrubber(e:MouseEvent):void{
            Debug.getInstance().traceDebug("VideoControlBar.rollOffVolumeScrubber:");
            this._volumeControls.volumeScrubber.addEventListener(MouseEvent.ROLL_OUT, this.rollOffVolumeScrubber);
            TweenLite.to(this._volumeControls.volumeScrubber, 0.3, {
                alpha:0,
                onComplete:this.hideVolumeScrubber
            });
        }
        private function hideVolumeScrubber():void{
            this._volumeControls.volumeScrubber.visible = false;
        }
        private function onPlayClick(e:MouseEvent):void{
            this._paused = false;
            if (this._contentType == TYPE_LIVE){
                this._bar.dvrControls.dvrPlay.visible = false;
                this._bar.dvrControls.dvrPause.visible = true;
                dispatchEvent(new VideoControlEvent(VideoControlEvent.PLAY, ""));
            } else {
                if ((((this._contentType == TYPE_ON_DEMAND)) || ((this._contentType == TYPE_PROGRESSIVE)))){
                    this._bar.onDemandControls.playButton.visible = false;
                    this._bar.onDemandControls.pauseButton.visible = true;
                    dispatchEvent(new VideoControlEvent(VideoControlEvent.PLAY, ""));
                };
            };
        }
        private function onPauseClick(e:MouseEvent):void{
            this._paused = true;
            if (this._contentType == TYPE_LIVE){
                this._bar.dvrControls.dvrPlay.visible = true;
                this._bar.dvrControls.dvrPause.visible = false;
                dispatchEvent(new VideoControlEvent(VideoControlEvent.PAUSE, ""));
            } else {
                if ((((this._contentType == TYPE_ON_DEMAND)) || ((this._contentType == TYPE_PROGRESSIVE)))){
                    this._bar.onDemandControls.playButton.visible = true;
                    this._bar.onDemandControls.pauseButton.visible = false;
                    dispatchEvent(new VideoControlEvent(VideoControlEvent.PAUSE, ""));
                };
            };
        }
        private function onFullscreenClick(e:MouseEvent):void{
            dispatchEvent(e);
        }
        private function onReplayClick(e:MouseEvent):void{
            var timeRatio:Number;
            var newX:Number;
            var replayEvent:MouseEvent = new MouseEvent(MouseEvent.CLICK);
            var totalTime:Number = (this._maxDVRtime - this._minDVRtime);
            var newTargetTime:Number = (this._curDVRtime - 30000);
            Debug.getInstance().traceDebug(((((("VideoControlBar.onReplayClick: " + getDisplayTime(this._curDVRtime)) + " ") + getDisplayTime(newTargetTime)) + " ") + getDisplayTime(this._minDVRtime)));
            if (newTargetTime > this._minDVRtime){
                dispatchEvent(new VideoControlEvent(VideoControlEvent.SCRUB, newTargetTime));
                if (this._measureClickAction != null){
                    this._measureClickAction.call(null, "Player Controls Replay");
                };
            };
        }
        private function onLiveClick(e:MouseEvent):void{
            dispatchEvent(new VideoControlEvent(VideoControlEvent.LIVE, ""));
            if (this._measureClickAction != null){
                this._measureClickAction.call(null, "Player Controls Live");
            };
        }
        private function onTimeshiftClick(e:MouseEvent, measure:Boolean=true):void{
            var point:Number = e.localX;
            if (this._contentType == TYPE_LIVE){
                this._dvrTimeBar.scrubber.x = (point + this._dvrTimeBar.timeline.x);
                this.setDVRTimebarWidth();
                this.onTimeshiftSet(null, false);
                Debug.getInstance().traceDebug(("VideoControlBar.onTimeshiftClick: " + this._dvrTimeBar.scrubber.x));
            } else {
                this._boolProgressScrub = true;
                this._bar.onDemandControls.scrubber.x = (point + this._bar.onDemandControls.scrubberBackground.x);
                this.progressScrubberReleased(null);
                Debug.getInstance().traceDebug(((("VideoControlBar.onTimeshiftClick: " + point) + " ") + this._bar.onDemandControls.scrubber.x));
            };
            if (((!((this._measureClickAction == null))) && (measure))){
                this._measureClickAction.call(null, "Player Controls Timeline");
            };
        }
        private function onTimeshiftChange(e:MouseEvent):void{
            this._boolProgressScrub = true;
            this._dvrTimeBar.scrubber.startDrag(true, new Rectangle(this._dvrTimeBar.timeline.x, this._dvrTimeBar.scrubber.y, this._dvrTimeBar.timeline.hitfield.width, 0));
            this._dvrTimeBar.scrubber.addEventListener(Event.ENTER_FRAME, this.onTimeshiftUpdate);
            this._stage.addEventListener(MouseEvent.MOUSE_UP, this.onTimeshiftSet);
        }
        private function onTimeshiftUpdate(e:Event):void{
        }
        private function onTimeshiftSet(e:MouseEvent, measure:Boolean=true):void{
            this._boolProgressScrub = false;
            var perTimeline:Number = 100;
            var newTargetTime:Number = 0;
            this._paused = false;
            this._bar.dvrControls.dvrPlay.visible = false;
            this._bar.dvrControls.dvrPause.visible = true;
            this._dvrTimeBar.scrubber.stopDrag();
            this._dvrTimeBar.scrubber.removeEventListener(Event.ENTER_FRAME, this.onTimeshiftUpdate);
            this._stage.removeEventListener(MouseEvent.MOUSE_UP, this.onTimeshiftSet);
            perTimeline = (1 - ((this._dvrTimeBar.scrubber.x - this._dvrTimeBar.timeline.x) / this._dvrTimeBar.timeline.hitfield.width));
            if (((this._dvrTimeBar.scrubber.x - this._dvrTimeBar.timeline.x) + 0.5) >= this._dvrTimeBar.timeline.hitfield.width){
                Debug.getInstance().traceDebug("VideoControlBar.onTimeshiftSet: Live ");
                dispatchEvent(new VideoControlEvent(VideoControlEvent.LIVE, newTargetTime));
                this._isLive = true;
            } else {
                newTargetTime = (this._maxDVRtime - Math.round(((this._maxDVRtime - this._minDVRtime) * perTimeline)));
                Debug.getInstance().traceDebug(((((((((((("VideoControlBar.onTimeshiftSet: AAA " + (int((perTimeline * 100)) / 100)) + " min:") + getDisplayTime(this._minDVRtime)) + " cur:") + getDisplayTime(this._curDVRtime)) + " max:") + getDisplayTime(this._maxDVRtime)) + " new:") + getDisplayTime(newTargetTime)) + " ") + newTargetTime));
                dispatchEvent(new VideoControlEvent(VideoControlEvent.SCRUB, newTargetTime));
                this._isLive = false;
            };
            if (((!((this._measureClickAction == null))) && (measure))){
                this._measureClickAction.call(null, "Player Controls Timeline");
            };
        }
        public function dvrTimeUpdate(minTime:Number, maxTime:Number, scrubberTime:Number):void{
            var perLocation:Number;
            var holderWidth:int;
            var timeRatio:Number;
            var newX:Number;
            var totalTime:Number;
            var timeToLive:Number;
            this._minDVRtime = minTime;
            this._maxDVRtime = maxTime;
            this._curDVRtime = scrubberTime;
            if (this._contentType == TYPE_LIVE){
                holderWidth = this._dvrTimeBar.timeline.hitfield.width;
            } else {
                holderWidth = this._bar.onDemandControls.markerHolder.width;
            };
            var x:int = (this._DVREvents.length - 1);
            while (x >= 0) {
                perLocation = ((this._DVREvents[x].time - this._minDVRtime) / (this._maxDVRtime - this._minDVRtime));
                this._DVREvents[x].x = (holderWidth * perLocation);
                if (this._DVREvents[x].x > holderWidth){
                    this._DVREvents[x].visible = false;
                } else {
                    this._DVREvents[x].visible = true;
                };
                if (this._DVREvents[x].x < ((this._DVREvents[x].indicator.width / 2) * -1)){
                    this._dvrTimeBar.timeline.removeChild(this._DVREvents[x]);
                    this._DVREvents.splice(x, 1);
                };
                x--;
            };
            if ((((scrubberTime > -1)) && (!(this._boolProgressScrub)))){
                totalTime = (this._maxDVRtime - this._minDVRtime);
                timeToLive = (this._maxDVRtime - this._curDVRtime);
                if ((((totalTime > 0)) && ((((scrubberTime >= this._minDVRtime)) && ((scrubberTime <= this._maxDVRtime)))))){
                    timeRatio = (this._dvrTimeBar.timeline.hitfield.width / totalTime);
                    newX = ((this._dvrTimeBar.timeline.hitfield.width - (timeToLive * timeRatio)) + this._dvrTimeBar.timeline.x);
                    this._dvrTimeBar.scrubber.x = newX;
                    this.setDVRTimebarWidth();
                };
            };
            if (this._curDVRtime >= this._maxDVRtime){
                dispatchEvent(new VideoControlEvent(VideoControlEvent.REACHED_LIVE, ""));
            };
        }
        public function scrubToTime(time:Number):void{
            var timeRatio:Number;
            var newX:Number;
            var replayEvent:MouseEvent = new MouseEvent(MouseEvent.CLICK);
            var totalTime:Number = (this._maxDVRtime - this._minDVRtime);
            var timeToLive:Number = (this._maxDVRtime - time);
            Debug.getInstance().traceDebug(((("VideoControlBar.scrubToTime: " + timeToLive) + " ") + this._dvrTimeBar.scrubber.x));
            if ((((totalTime > 0)) && ((((time > this._minDVRtime)) && ((time < this._maxDVRtime)))))){
                timeRatio = (this._dvrTimeBar.timeline.hitfield.width / totalTime);
                newX = (this._dvrTimeBar.timeline.hitfield.width - (timeToLive * timeRatio));
                replayEvent.localX = newX;
                this.onTimeshiftClick(replayEvent, false);
            };
        }
        public function movedToLive():void{
            this._dvrTimeBar.scrubber.x = (this._dvrTimeBar.timeline.x + this._dvrTimeBar.timeline.hitfield.width);
            this.setDVRTimebarWidth();
            this._bar.dvrControls.dvrLive.visible = false;
            this._isLive = true;
        }
        public function movedToDVR():void{
            this._bar.dvrControls.dvrLive.visible = true;
            this._isLive = false;
        }
        public function setDVREvent(name:String, time:Number, thumb:String, format:TextFormat):void{
            var found:Boolean;
            var x:int;
            if (((this._minDVRtime) && (this._maxDVRtime))){
                found = false;
                x = 0;
                while (x < this._DVREvents.length) {
                    if (this._DVREvents[x].eventName == name){
                        found = true;
                    };
                    x++;
                };
                if (((((!(found)) && ((time > this._minDVRtime)))) && ((time < this._maxDVRtime)))){
                    this._DVREvents.push(new TimelineMarker(name, thumb, format, time, new TimelineMarkerDVR_MC()));
                    this._DVREvents[(this._DVREvents.length - 1)].visible = false;
                    this._DVREvents[(this._DVREvents.length - 1)].y = 8;
                    this._DVREvents[(this._DVREvents.length - 1)].addEventListener(MouseEvent.CLICK, this.handleEventClick);
                    if (this._contentType == TYPE_LIVE){
                        this._dvrTimeBar.timeline.addChild(this._DVREvents[(this._DVREvents.length - 1)]);
                    } else {
                        this._bar.onDemandControls.markerHolder.addChild(this._DVREvents[(this._DVREvents.length - 1)]);
                    };
                    this.dvrTimeUpdate(this._minDVRtime, this._maxDVRtime, this._curDVRtime);
                    Debug.getInstance().traceDebug(((("VideoControlBar.setVideoControlEvent: " + name) + " ") + getDisplayDate(time)));
                };
            };
        }
        public function clearVideoControlEvents():void{
            var x:int = (this._DVREvents.length - 1);
            while (x >= 0) {
                if (this._contentType == TYPE_LIVE){
                    this._dvrTimeBar.timeline.removeChild(this._DVREvents[x]);
                } else {
                    this._bar.onDemandControls.markerHolder.removeChild(this._DVREvents[x]);
                };
                x--;
            };
            this._DVREvents = new Array();
        }
        private function handleEventClick(e:MouseEvent):void{
            var VideoControlEventClick:MouseEvent = new MouseEvent(MouseEvent.CLICK);
            VideoControlEventClick.localX = e.localX;
            Debug.getInstance().traceDebug(((((("VideoControlBar.handleEventClick: " + e.localX) + " ") + e.currentTarget.time) + " ") + VideoControlEventClick.localX));
            if (this._contentType == TYPE_LIVE){
                this.scrubToTime(e.currentTarget.time);
            } else {
                e.localX = e.currentTarget.x;
                this.onTimeshiftClick(e, false);
            };
            if (this._measureClickAction != null){
                this._measureClickAction.call(null, "Player Controls Key Moment");
            };
        }
        public function showFullScreenButton(v:Boolean):void{
            this._bar.onDemandControls.fullscreen.visible = v;
        }
        public function get volumeControl():MovieClip{
            return (this._volumeControls);
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import flash.display.*;
    import flash.media.*;
    import flash.events.*;
    import flash.utils.*;
    import com.ibm.AS3util.*;
    import flash.net.*;
    import com.conviva.*;
    import com.akamai.playeranalytics.*;
    import com.gomez.*;

    public class VideoDisplay extends MovieClip {

        private const CONTROL_DISPLAY_TIMEOUT:int = 3000;

        private var _location:String;
        private var _name:String;
        private var _bg:Sprite;
        private var _video:Video;
        private var _streamObject:StreamObject;
        private var _lastStream:StreamObject;
        private var _channelName:String;
        private var _resetSize:Boolean;
        private var _sourceVideoWidth:int;
        private var _sourceVideoHeight:int;
        private var _currentPlayTime:Number;
        private var _currentRendition:int;
        private var _currentCDN:String;
        private var _infoObj:Object;
        private var _connected:Boolean;
        private var _isPlaying:Boolean;
        private var _isSeeking:Boolean;
        private var _isLive:Boolean;
        private var _playbackDispatched:Boolean;
        private var _volume:Number;
        private var _videoScaled:Boolean;
        private var _measureID:int;
        private var _gzMeasure:Boolean = false;
        private var _gzMonTag:GZMon;
        private var _gzMonName:String;
        private var _mediaAnalytics:Boolean = false;
        private var _mediaAnalyticsInit:Boolean = false;
        private var _dvrURL:String = "";
        private var _dvrCDN:String = "";
        private var _dvrStartTime:Number;
        private var _dvrMinTime:Number;
        private var _dvrMaxTime:Number;
        private var _dvrCurrentTime:Number;
        private var _bandwidth:String;
        private var _latency:String;
        private var _checkBW:Boolean;
        private var _checkFPS:Boolean;
        private var _connectionManager:ConnectionManager;
        private var _connection:IMediaServerConnection;
        private var _videoStats:VideoStats;
        private var _videoControlBar:VideoControlBar;
        private var _videoControlVisible:Boolean;
        private var _controlTimer:Timer;
        private var _bufferTime:int = 5;
        private var _liveStreamTimeout:int = 15;
        private var _bgColor:uint = 0;
        private var _bgAlpha:Number = 0;
        private var _letterbox:Boolean = false;
        private var _origWidth:int;
        private var _origHeight:int;
        private var _useStreamTime:Boolean = true;
        private var _maxBitrate:int = -1;
        private var _dvrAvailable:Boolean = true;
        private var _endLivePlaybackDelay:Boolean = false;
        private var _livepassEnabled:Boolean = false;
        private var _controlBarXoffset:int = 0;
        private var _controlBarYoffset:int = 0;
        private var _mediaAnalyticsInfo:Object;
        private var _livePassTags:Array;

        public function VideoDisplay(location:String, name:String, width:int, height:int, controlBar:MovieClip=null, measureFunction:Function=null, controlBarXoffset:int=0, livePassTags:Array=null, controlBarFixedSize:Boolean=false, controlBarDescriptionEnabled:Boolean=false, controlBarYoffset:int=0):void{
            var newScale:Number;
            super();
            this._name = name;
            this._connected = false;
            this._isPlaying = false;
            this._videoScaled = false;
            this._isSeeking = false;
            this._isLive = true;
            this._volume = 0.5;
            this._location = location;
            this._livePassTags = livePassTags;
            this._infoObj = new Object();
            this._bandwidth = "";
            this._latency = "";
            this._checkBW = false;
            this._checkFPS = false;
            this._measureID = 10;
            this._bg = new Sprite();
            this.addChild(this._bg);
            this.setBackground(this._bgColor, this._bgAlpha);
            this._video = new Video(width, height);
            this._video.smoothing = false;
            this._video.deblocking = 0;
            this._video.width = width;
            this._video.height = height;
            this.addChild(this._video);
            this._origWidth = width;
            this._origHeight = height;
            this._streamObject = null;
            this._connectionManager = ConnectionManager.getInstance();
            if (controlBar != null){
                this._videoControlBar = new VideoControlBar(this, this._video, controlBar, measureFunction, ((controlBar.dvrControls.timeline.pastBar) ? true : false), controlBarDescriptionEnabled);
                if (controlBar.onDemandControls.width > width){
                    newScale = (1 / ((controlBar.onDemandControls.width / width) + 0.05));
                    this._videoControlBar.scaleX = newScale;
                    this._videoControlBar.scaleY = newScale;
                };
                if (controlBarFixedSize){
                    addEventListener(Event.ADDED_TO_STAGE, this.handleAddedToStage);
                };
                this._controlBarXoffset = controlBarXoffset;
                this._controlBarYoffset = controlBarYoffset;
                this._videoControlBar.x = (controlBarXoffset + (Math.round((width - this._videoControlBar.width)) / 2));
                this._videoControlBar.y = ((controlBarYoffset + height) - 65);
                this._videoControlBar.addEventListener(VideoControlEvent.VOLUME, this.handleChangeVolume);
                this._videoControlBar.addEventListener(VideoControlEvent.PAUSE, this.handleVideoPause);
                this._videoControlBar.addEventListener(VideoControlEvent.PLAY, this.handleVideoPlay);
                this._videoControlBar.addEventListener(VideoControlEvent.SCRUB, this.handleVideoScrub);
                this._videoControlBar.addEventListener(VideoControlEvent.LIVE, this.handleGoLive);
                this._videoControlBar.addEventListener(VideoControlEvent.REACHED_LIVE, this.handleReachedLive);
                this._videoControlBar.addEventListener(MouseEvent.CLICK, this.handleFullScreen);
                this.addChild(this._videoControlBar);
                this.addEventListener(MouseEvent.MOUSE_OVER, this.showControlBar);
                this.addEventListener(MouseEvent.MOUSE_OUT, this.hideControlBar);
                this.addEventListener(MouseEvent.MOUSE_MOVE, this.showControlBar);
                this._controlTimer = new Timer(this.CONTROL_DISPLAY_TIMEOUT, 1);
                this._controlTimer.addEventListener(TimerEvent.TIMER, this.controlDisplayTimeout);
                this._videoControlBar.setVolumeControl(this._volume);
            };
            Debug.getInstance().traceDebug(((((("VideoDisplay[" + this._name) + "].constructor: ") + this._bg.x) + " ") + this._video.x));
        }
        private function handleAddedToStage(e:Event):void{
            removeEventListener(Event.ADDED_TO_STAGE, this.handleAddedToStage);
            var scaleAmt:Number = (this.stage.stageWidth / 640);
            this._videoControlBar.scaleX = (1 / scaleAmt);
            this._videoControlBar.scaleY = this._videoControlBar.scaleX;
            this.stage.addEventListener(Event.RESIZE, this.handleResizeStage);
        }
        private function handleResizeStage(e:Event):void{
            var scaleAmt:Number = (this.stage.stageWidth / 960);
            this._videoControlBar.scaleX = (1 / scaleAmt);
            this._videoControlBar.scaleY = this._videoControlBar.scaleX;
        }
        public function startPlayback(streamURI:String, streamtype:String, streamwidth:int, streamheight:int, cdn:String, dvrAvailable:int, seekPos:Number=-1):void{
            this._infoObj.name = this._name;
            this._infoObj.channel = this._channelName;
            this._sourceVideoWidth = streamwidth;
            this._sourceVideoHeight = streamheight;
            this._video.width = this._sourceVideoWidth;
            this._video.height = this._sourceVideoHeight;
            this._video.x = 0;
            this._video.y = 0;
            this._videoScaled = false;
            if (this._videoControlBar){
                this._videoControlBar.x = (this._controlBarXoffset + (Math.round((this._video.width - this._videoControlBar.width)) / 2));
                this._videoControlBar.y = ((this._controlBarYoffset + height) - 65);
            };
            this._playbackDispatched = false;
            this.hideVideo();
            this._streamObject = new StreamObject();
            this._streamObject.stream = streamURI;
            this._streamObject.bitrate = 0;
            this._streamObject.cdn = cdn;
            this._streamObject.attemptMax = 1;
            this._streamObject.dvrAvailable = dvrAvailable;
            this._streamObject.seekPos = seekPos;
            this._streamObject.bufferTime = this._bufferTime;
            this._streamObject.liveStreamTimeout = this._liveStreamTimeout;
            this._streamObject.dvrURL = this._dvrURL;
            this._streamObject.dvrCDN = this._dvrCDN;
            switch (streamtype){
                case "live":
                    this._streamObject.type = VideoControlBar.TYPE_LIVE;
                    break;
                case "ondemand":
                    this._streamObject.type = VideoControlBar.TYPE_ON_DEMAND;
                    break;
                case "progressive":
                    this._streamObject.type = VideoControlBar.TYPE_PROGRESSIVE;
                    break;
                default:
                    this._streamObject.type = "ondemand";
            };
            this._lastStream = this._streamObject;
            this.setDVR("", "");
            Debug.getInstance().traceDebug(((((("VideoDisplay[" + this._name) + "].startPlayback: ") + this._isPlaying) + " ") + this._streamObject.type));
            Debug.getInstance().traceDebug(((((((((("VideoDisplay[" + this._name) + "].startPlayback: loc:") + this._location) + " cdn:") + this._streamObject.cdn) + " dvr:") + dvrAvailable) + " buf:") + this._streamObject.bufferTime));
            if (!(this._isPlaying)){
                this._connection = this._connectionManager.getConnection(this._location, this._streamObject.cdn, this._streamObject);
                this.setMediaAnalytics(this._streamObject.cdn);
                this._connection.setMaxBitrate(this._maxBitrate);
                this._connection.startPlayback(this._streamObject.stream, this._streamObject.type, this._streamObject.seekPos, this._streamObject.dvrAvailable, this._streamObject.bufferTime);
                this._connection.setVideoStats(this._videoStats);
                this._currentCDN = this._streamObject.cdn;
                this._streamObject = null;
            };
            this.addListeners(this._connection);
            Debug.getInstance().traceDebug(((((("VideoDisplay[" + this._name) + "].startPlayback: ") + this._video.x) + " ") + this._video.width));
        }
        public function setDVR(url:String, cdn:String):void{
            this._dvrURL = url;
            this._dvrCDN = cdn;
            Debug.getInstance().traceDebug(((((((("VideoDisplay[" + this._name) + "].setDVR: ") + this._dvrURL) + " ") + this._dvrCDN) + " ") + url));
        }
        public function updateDVRTime(start:Number, min:Number, max:Number):void{
            this._dvrStartTime = start;
            this._dvrMinTime = min;
            this._dvrMaxTime = max;
            if (this._isLive){
                this._dvrCurrentTime = this._dvrMaxTime;
            };
            if (((this._videoControlBar) && (!(this._useStreamTime)))){
                this._videoControlBar.dvrTimeUpdate(this._dvrMinTime, this._dvrMaxTime, this._dvrCurrentTime);
            };
        }
        public function setMaxBitrate(max:int):void{
            this._maxBitrate = max;
            if (this._connection){
                this._connection.setMaxBitrate(this._maxBitrate);
            };
        }
        public function setDVRAvailable(available:Boolean):void{
            this._dvrAvailable = available;
            if (this._videoControlBar){
                this._videoControlBar.setDVRbar(this._dvrAvailable);
            };
            if (!(this._isLive)){
                this.handleGoLive(new VideoControlEvent(VideoControlEvent.LIVE, null));
            };
        }
        public function endLivePlayback():void{
            if (this._isLive){
                this.stopPlayback();
                this.hideVideo();
                dispatchEvent(new VideoEvent(VideoEvent.PLAYBACK_ENDED, this._infoObj));
            } else {
                this._endLivePlaybackDelay = true;
            };
        }
        public function setBackground(bgColor:uint, bgAlpha:Number):void{
            this._bg.graphics.beginFill(bgColor, bgAlpha);
            this._bg.graphics.drawRect(0, 0, this.width, this.height);
            this._bg.graphics.endFill();
        }
        public function addStatsDisplay(stats:VideoStats):void{
            this._videoStats = stats;
        }
        public function hideVideo():void{
            Debug.getInstance().traceDebug((("VideoDisplay[" + this._name) + "].hideVideo: "));
            this._video.visible = false;
            if (this._videoControlBar){
                this._videoControlBar.visible = false;
            };
        }
        public function showVideo():void{
            Debug.getInstance().traceDebug((("VideoDisplay[" + this._name) + "].showVideo: "));
            this._video.visible = true;
        }
        public function changeVideoSize(width:int, height:int):void{
            Debug.getInstance().traceDebug(((("VideoDisplay.changeVideoSize:  w=" + width) + "|h=") + height));
            this._video.width = width;
            this._video.height = height;
            if (((!((this._video.width == this._sourceVideoWidth))) || (!((this._video.height == this._sourceVideoHeight))))){
                this._video.smoothing = true;
            } else {
                this._video.smoothing = false;
            };
        }
        public function stopPlayback():void{
            var netstr:NetStream;
            Debug.getInstance().traceDebug(((("VideoDisplay[" + this._name) + "].stopPlayback: ") + this._connection));
            if (this._connection){
                netstr = this._connectionManager.getNetstream(this._connection);
                if (this._livepassEnabled){
                    Debug.getInstance().traceDebug(("VideoDisplay.stopPlayback livepass netstr=" + netstr));
                    LivePass.cleanupMonitoringSession(netstr);
                };
                this._connection.stopPlayback();
            };
            this.hideVideo();
            this._channelName = "";
            Debug.getInstance().traceDebug(((("VideoDisplay[" + this._name) + "].stopPlayback: ") + this._isPlaying));
        }
        public function mute(on:Boolean):void{
            try {
                if (on){
                    this._connection.setVolume(0);
                } else {
                    this._connection.setVolume(this._volume);
                };
            } catch(e:Error) {
            };
        }
        public function setVolume(value:Number):void{
            if (value > 1){
                this._volume = (value / 100);
            } else {
                this._volume = value;
            };
            if (this._connection){
                this._connection.setVolume(this._volume);
            };
        }
        public function pauseVideo():void{
            this.handleVideoPause(new VideoControlEvent(VideoControlEvent.PAUSE, null));
        }
        public function playVideo():void{
            this.handleVideoPlay(new VideoControlEvent(VideoControlEvent.PLAY, null));
        }
        public function seekVideo(time:Number):void{
            this.handleVideoScrub(new VideoControlEvent(VideoControlEvent.SCRUB, time));
        }
        public function clearVideo():void{
            this._video.clear();
        }
        public function getImage():BitmapData{
            Debug.getInstance().traceInfo(((((("VideoDisplay[" + this._name) + "].getImage: ") + this._sourceVideoWidth) + " ") + this._sourceVideoHeight));
            var cap:BitmapData = new BitmapData(this._video.width, this._video.height, true, 0xCCCCCCCC);
            cap.draw(this._video);
            return (cap);
        }
        public function enableMediaAnalytics():void{
            this._mediaAnalytics = true;
        }
        public function enableLivePass():void{
            Debug.getInstance().traceInfo("LivePass Enabled");
            this._livepassEnabled = true;
        }
        private function initMediaAnalytics():void{
            if (!(this._mediaAnalyticsInfo)){
                this._mediaAnalyticsInfo = {};
                this._mediaAnalyticsInfo.pluginSwf = "http://79423.analytics.edgesuite.net/csma/plugin/csma.swf";
                this._mediaAnalyticsInfo.configFilePath = "http://csma93857-analytics.edgesuite.net/config/beacon-446.xml";
            };
            try {
                AnalyticsPluginLoader.loadPlugin(this._mediaAnalyticsInfo.pluginSwf, this._mediaAnalyticsInfo.configFilePath);
                this._mediaAnalyticsInit = true;
            } catch(e:Error) {
                Debug.getInstance().traceError(((("VideoDisplay[" + _name) + "].enableMediaAnalytics: ") + e.toString()));
            };
        }
        private function addListeners(connection:IMediaServerConnection):void{
            connection.addEventListener(ConnectionEvent.PLAYBACK_STARTED, this.handlePlaybackStarted);
            connection.addEventListener(ConnectionEvent.PLAYBACK_ERROR, this.handlePlaybackError);
            connection.addEventListener(ConnectionEvent.PLAYBACK_COMPLETE, this.handlePlaybackComplete);
            connection.addEventListener(ConnectionEvent.PLAYBACK_PROGRESS, this.handlePlaybackProgress);
            connection.addEventListener(ConnectionEvent.STATUS_MESSAGE, this.handleStatusMessage);
            connection.addEventListener(ConnectionEvent.BUFFER_FULL, this.handleBufferFull);
            connection.addEventListener(ConnectionEvent.BANDWIDTH_WARNING, this.handleBandwidthWarning);
            connection.addEventListener(ConnectionEvent.PLAYBACK_STOPPED, this.handlePlaybackStopped);
            connection.addEventListener(ConnectionEvent.META_DATA, this.handleMetaData);
            connection.addEventListener(ConnectionEvent.RENDITION_SWITCH, this.handleRenditionSwitch);
            connection.addEventListener(ConnectionEvent.TIME_UPDATE, this.handleTimeUpdate);
        }
        private function removeListeners(connection:IMediaServerConnection):void{
            connection.removeEventListener(ConnectionEvent.PLAYBACK_STARTED, this.handlePlaybackStarted);
            connection.removeEventListener(ConnectionEvent.PLAYBACK_ERROR, this.handlePlaybackError);
            connection.removeEventListener(ConnectionEvent.PLAYBACK_COMPLETE, this.handlePlaybackComplete);
            connection.removeEventListener(ConnectionEvent.PLAYBACK_PROGRESS, this.handlePlaybackProgress);
            connection.removeEventListener(ConnectionEvent.STATUS_MESSAGE, this.handleStatusMessage);
            connection.removeEventListener(ConnectionEvent.BUFFER_FULL, this.handleBufferFull);
            connection.removeEventListener(ConnectionEvent.BANDWIDTH_WARNING, this.handleBandwidthWarning);
            connection.removeEventListener(ConnectionEvent.PLAYBACK_STOPPED, this.handlePlaybackStopped);
            connection.removeEventListener(ConnectionEvent.META_DATA, this.handleMetaData);
            connection.removeEventListener(ConnectionEvent.RENDITION_SWITCH, this.handleRenditionSwitch);
            connection.removeEventListener(ConnectionEvent.TIME_UPDATE, this.handleTimeUpdate);
        }
        private function handleStatusMessage(e:ConnectionEvent):void{
        }
        private function handlePlaybackStarted(e:ConnectionEvent):void{
            var channelName:String;
            var netstr:NetStream;
            var tagObj:Object;
            var obj:Object;
            var videoIndex:int = 1;
            var connection:IMediaServerConnection = (e.target as IMediaServerConnection);
            Debug.getInstance().traceDebug((("VideoDisplay[" + this._name) + "].handlePlaybackStarted: "));
            Debug.getInstance().traceDebug(((((("VideoDisplay[" + this._name) + "].handlePlaybackStarted: ") + (connection == this._connection)) + " _channelName=") + this._channelName));
            if (connection == this._connection){
                channelName = this._channelName.replace(" & ", "");
                if (((this._gzMeasure) && (!(this._isPlaying)))){
                    Debug.getInstance().traceDebug(((("VideoDisplay[" + this._name) + "].handlePlaybackStarted: ") + this._gzMonTag));
                    netstr = this._connectionManager.getNetstream(connection);
                    this._gzMonName = channelName;
                };
                if (((this._mediaAnalytics) && (!(this._isPlaying)))){
                    if ((((this._lastStream.cdn == ConnectionManager.CDN_AKAMAI_HD_CORE)) || ((this._lastStream.cdn == ConnectionManager.CDN_AKAMAI_MBR)))){
                        AnalyticsPluginLoader.setData("Channel", channelName);
                        Debug.getInstance().traceDebug(((("VideoDisplay[" + this._name) + "].handlePlaybackStarted MA: ") + channelName));
                    };
                };
                if (((this._livepassEnabled) && (!(this._isPlaying)))){
                    netstr = this._connectionManager.getNetstream(connection);
                    tagObj = {};
                    tagObj.channelName = this._channelName;
                    for each (obj in this._livePassTags) {
                        tagObj[obj.key] = obj.value;
                    };
                    if (this._livepassEnabled){
                        LivePass.createMonitoringSession(netstr, channelName, tagObj, {bitrateKbps:564});
                        Debug.getInstance().traceDebug(((((("VideoDisplay[" + this._name) + "].handlePlaybackStarted LivePass: ") + channelName) + ", tagObj.flashVer=") + tagObj.flashVer));
                    };
                };
                this._isPlaying = true;
                if (((this._videoStats) && (this._currentCDN))){
                    this._videoStats.updateCDN(this._currentCDN);
                    this._videoStats.updateSize(0, 0);
                    this._videoStats.updateSmoothing(false);
                };
                this._video.attachNetStream(this._connectionManager.getNetstream(connection));
                this.setVolume(this._volume);
            };
        }
        private function handleBufferFull(e:ConnectionEvent):void{
            Debug.getInstance().traceDebug(((("VideoDisplay[" + this._name) + "].handleBufferFull: ") + this._playbackDispatched));
            var connection:IMediaServerConnection = (e.target as IMediaServerConnection);
            if (!(this._playbackDispatched)){
                dispatchEvent(new VideoEvent(VideoEvent.PLAYBACK_STARTED, this._infoObj));
                this._playbackDispatched = true;
                if (this._videoControlBar){
                    this._videoControlBar.setContentType(connection.streamtype, connection.netStream, this.width, connection.dvrAvailable, connection.startPosition);
                    this.setDVRAvailable(this._dvrAvailable);
                };
            } else {
                this._isPlaying = true;
                dispatchEvent(new VideoEvent(VideoEvent.PLAYBACK_CONTINUED, this._infoObj));
                if (((this._isSeeking) && (this._videoControlBar))){
                    this._isSeeking = false;
                    this._videoControlBar.playbackContinued();
                };
            };
            this.showVideo();
        }
        private function handlePlaybackStopped(e:ConnectionEvent):void{
            var connection:IMediaServerConnection = (e.target as IMediaServerConnection);
            Debug.getInstance().traceDebug(((((("VideoDisplay[" + this._name) + "].handlePlaybackStopped: ") + connection.netStream) + " | ") + this._gzMeasure));
            if (((connection.netStream) && (this._gzMeasure))){
                Debug.getInstance().traceDebug(((("VideoDisplay[" + this._name) + "].handlePlaybackStopped gzMon: ") + this._measureID));
                this._gzMonTag.MarkClose(connection.netStream, this._measureID);
                this._measureID++;
            };
            if (this._streamObject != null){
                this._connection = this._connectionManager.getConnection(this._location, this._streamObject.cdn, this._streamObject);
                this.setMediaAnalytics(this._streamObject.cdn);
                this._currentCDN = this._streamObject.cdn;
                this._connection.setMaxBitrate(this._maxBitrate);
                this._connection.setVideoStats(this._videoStats);
                this.removeListeners(this._connection);
                this.addListeners(this._connection);
                this._connection.startPlayback(this._streamObject.stream, this._streamObject.type, this._streamObject.seekPos, this._streamObject.dvrAvailable, this._streamObject.bufferTime);
                this._streamObject = null;
            };
            this._isPlaying = false;
        }
        private function handlePlaybackError(e:ConnectionEvent):void{
            Debug.getInstance().traceDebug((("VideoDisplay[" + this._name) + "].handlePlaybackError: "));
            if (((((((e.info as String) == "octoshape_plugin")) || (((e.info as String) == "octoshape_link_error")))) || (((e.info as String) == "octoshape_rejected")))){
                this._infoObj.error = (e.info as String);
            };
            dispatchEvent(new VideoEvent(VideoEvent.STREAM_ERROR, this._infoObj));
            this._isPlaying = false;
        }
        private function handlePlaybackComplete(e:ConnectionEvent):void{
            var connection:IMediaServerConnection = (e.info as IMediaServerConnection);
            Debug.getInstance().traceDebug((("VideoDisplay[" + this._name) + "].handlePlaybackComplete: "));
            dispatchEvent(new VideoEvent(VideoEvent.PLAYBACK_COMPLETE, ""));
        }
        private function handlePlaybackProgress(e:ConnectionEvent):void{
            var connection:IMediaServerConnection = (e.info as IMediaServerConnection);
            this._currentPlayTime = e.info.time;
            if (this._videoControlBar){
                this._videoControlBar.updateDisplay();
            };
            dispatchEvent(new VideoEvent(VideoEvent.PLAYBACK_PROGRESS, this._infoObj));
        }
        private function handleBandwidthWarning(e:ConnectionEvent):void{
        }
        private function handleMetaData(e:ConnectionEvent):void{
            var propName:String;
            for (propName in e.info) {
                if ((((propName == "duration")) && (this._videoControlBar))){
                    this._videoControlBar.setOnDemandBar(e.info[propName]);
                };
                if (propName == "width"){
                    this._sourceVideoWidth = parseInt(e.info[propName]);
                };
                if (propName == "height"){
                    this._sourceVideoHeight = parseInt(e.info[propName]);
                };
            };
            if (this._videoStats){
                this._videoStats.updateSize(this._sourceVideoWidth, this._sourceVideoHeight);
            };
            if (!(this._videoScaled)){
                this._videoScaled = true;
                if (((!((this._sourceVideoWidth == this._video.width))) || (!((this._sourceVideoHeight == this._video.height))))){
                    if (this._letterbox){
                        this.adjustVideoSize(this._sourceVideoWidth, this._sourceVideoHeight);
                        this._video.smoothing = false;
                    } else {
                        this._video.smoothing = true;
                    };
                } else {
                    this._video.smoothing = false;
                };
            };
            if (((!((this._sourceVideoWidth == this._video.width))) || (!((this._sourceVideoHeight == this._video.height))))){
                this._video.smoothing = true;
            } else {
                this._video.smoothing = false;
            };
            if (this._videoStats){
                this._videoStats.updateSmoothing(this._video.smoothing);
            };
            Debug.getInstance().traceDebug(((((((((("VideoDisplay[" + this._name) + "].handleMetaData: ") + this._sourceVideoWidth) + " ") + this._video.width) + " ") + this._sourceVideoHeight) + " ") + this._video.height));
            Debug.getInstance().traceDebug(((((((("VideoDisplay[" + this._name) + "].handleMetaData: ") + this._letterbox) + " ") + this._video.width) + " ") + this._video.smoothing));
        }
        private function handleRenditionSwitch(e:ConnectionEvent):void{
            this._currentRendition = (e.info as Number);
            Debug.getInstance().traceDebug(((("VideoDisplay[" + this._name) + "].handleRenditionSwitch: ") + this._currentRendition));
        }
        private function handleTimeUpdate(e:ConnectionEvent):void{
            this._dvrCurrentTime = parseInt(e.info.currentTime);
            if (((this._videoControlBar) && (this._useStreamTime))){
                this._dvrMinTime = parseInt(e.info.minTime);
                this._dvrMaxTime = parseInt(e.info.maxTime);
                this._videoControlBar.dvrTimeUpdate(this._dvrMinTime, this._dvrMaxTime, this._dvrCurrentTime);
            } else {
                if (this._useStreamTime){
                    this._dvrMinTime = parseInt(e.info.minTime);
                    this._dvrMaxTime = parseInt(e.info.maxTime);
                };
            };
            dispatchEvent(new VideoEvent(VideoEvent.TIME_UPDATE, {
                max:this._dvrMaxTime,
                min:this._dvrMinTime,
                cur:this._dvrCurrentTime
            }));
        }
        private function adjustVideoSize(pWidth:int, pHeight:int):void{
            var baseWidth:Number = this._origWidth;
            var baseHeight:Number = this._origHeight;
            Debug.getInstance().traceDebug(((((((((("VideoDisplay[" + this._name) + "].adjustVideoSize ") + pWidth) + " ") + pHeight) + " ") + baseWidth) + " ") + baseHeight));
            var baseRatio:Number = (baseWidth / baseHeight);
            var ratio:Number = (pWidth / pHeight);
            var adjusted:Boolean;
            if ((((ratio > baseRatio)) && ((((pWidth < baseWidth)) || ((pWidth > baseWidth)))))){
                this._video.height = (pHeight * (baseWidth / pWidth));
                this._video.width = baseWidth;
            };
            if ((((ratio < baseRatio)) && ((((pHeight < baseHeight)) || ((pHeight > baseHeight)))))){
                this._video.width = (pWidth * (baseHeight / pHeight));
                this._video.height = baseHeight;
            };
            if (ratio == baseRatio){
                if (pWidth < baseWidth){
                    this._video.width = pWidth;
                    this._video.height = pHeight;
                } else {
                    this._video.width = baseWidth;
                    this._video.height = baseHeight;
                };
            };
            this.adjustVideoPosition(this._video.width, this._video.height, baseWidth, baseHeight);
        }
        private function adjustVideoPosition(pWidth:Number, pHeight:Number, maxWidth:Number, maxHeight:Number):void{
            if (pWidth < maxWidth){
                this._video.x = Math.round(((maxWidth - pWidth) / 2));
            } else {
                this._video.x = 0;
            };
            if (pHeight < maxHeight){
                this._video.y = Math.round(((maxHeight - pHeight) / 2));
            } else {
                this._video.y = 0;
            };
        }
        private function showControlBar(e:MouseEvent):void{
            this._videoControlBar.showBar();
            if (!(this._controlTimer.running)){
                this._controlTimer.start();
            };
        }
        private function hideControlBar(e:MouseEvent):void{
            this._videoControlBar.hideBar();
        }
        private function controlDisplayTimeout(e:TimerEvent):void{
            this.hideControlBar(new MouseEvent(MouseEvent.MOUSE_OUT));
        }
        private function handleChangeVolume(e:VideoControlEvent):void{
            this.setVolume((e.info as Number));
        }
        private function handleVideoPause(e:VideoControlEvent):void{
            this._connection.pause();
        }
        private function handleVideoPlay(e:VideoControlEvent):void{
            Debug.getInstance().traceDebug(((("VideoDisplay[" + this._name) + "].handleVideoPlay: ") + e.info));
            this._connection.resume();
        }
        private function handleVideoScrub(e:VideoControlEvent):void{
            Debug.getInstance().traceDebug(((((((("VideoDisplay[" + this._name) + "].handleVideoScrub: AAA ") + PhpDate.format("H:i:s", ((e.info as Number) / 1000))) + " ") + ((e.info as Number) / 1000)) + " ") + this._dvrStartTime));
            Debug.getInstance().traceDebug(((("VideoDisplay[" + this._name) + "].handleVideoScrub: ") + this._lastStream.dvrURL));
            if (this._lastStream.dvrURL != ""){
                this._connection.stopPlayback();
                this._connection = this._connectionManager.getConnection(this._location, this._lastStream.dvrCDN, this._lastStream);
                this.setMediaAnalytics(this._lastStream.dvrCDN);
                this._currentCDN = this._lastStream.dvrCDN;
                this._connection.startPlayback(this._lastStream.dvrURL, this._lastStream.type, (((e.info as Number) - this._dvrStartTime) / 1000), this._lastStream.dvrAvailable, this._lastStream.bufferTime);
                this._connection.setVideoStats(this._videoStats);
                this.addListeners(this._connection);
            } else {
                this._isSeeking = true;
                this._connection.seek((e.info as Number));
            };
            if (this._videoControlBar){
                this._videoControlBar.movedToDVR();
            };
            this._isLive = false;
        }
        private function handleGoLive(e:VideoControlEvent):void{
            Debug.getInstance().traceDebug(((("VideoDisplay[" + this._name) + "].handleGoLive: ") + e.info));
            if (this._lastStream.dvrURL != ""){
                this._connection.stopPlayback();
                this._connection = this._connectionManager.getConnection(this._location, this._lastStream.cdn, this._lastStream);
                this.setMediaAnalytics(this._lastStream.cdn);
                this._currentCDN = this._lastStream.cdn;
                this._connection.startPlayback(this._lastStream.stream, this._lastStream.type, -2, this._lastStream.dvrAvailable, this._lastStream.bufferTime);
                this._connection.setVideoStats(this._videoStats);
                this.addListeners(this._connection);
            } else {
                this._isSeeking = false;
                this._connection.goLive();
            };
            if (this._videoControlBar){
                this._videoControlBar.movedToLive();
            };
            this._isLive = true;
            if (this._endLivePlaybackDelay){
                this.endLivePlayback();
                this._endLivePlaybackDelay = false;
            };
        }
        private function handleReachedLive(e:VideoControlEvent):void{
            if (this._endLivePlaybackDelay){
                this._isLive = true;
                this.endLivePlayback();
                this._endLivePlaybackDelay = false;
            };
        }
        private function handleFullScreen(e:MouseEvent):void{
            dispatchEvent(e);
        }
        private function setMediaAnalytics(cdn:String):void{
            if ((((((cdn == ConnectionManager.CDN_AKAMAI_HD_CORE)) || ((cdn == ConnectionManager.CDN_AKAMAI_MBR)))) && (this._mediaAnalytics))){
                if (!(this._mediaAnalyticsInit)){
                    this.initMediaAnalytics();
                };
                this._connection.setMediaAnalytics(this._mediaAnalytics);
            };
        }
        public function set channelName(value:String):void{
            this._channelName = value;
        }
        public function set bufferTime(value:int):void{
            this._bufferTime = value;
        }
        public function set letterbox(value:Boolean):void{
            this._letterbox = value;
        }
        public function get bufferTime():int{
            return (this._bufferTime);
        }
        public function get channelName():String{
            return (this._channelName);
        }
        public function get isPlaying():Boolean{
            return (this._isPlaying);
        }
        public function get video():Video{
            return (this._video);
        }
        public function get currentPlayTime():Number{
            return (this._currentPlayTime);
        }
        public function get videoControlBar():VideoControlBar{
            return (this._videoControlBar);
        }
        public function set useStreamTime(value:Boolean):void{
            this._useStreamTime = value;
        }
        public function get useStreamTime():Boolean{
            return (this._useStreamTime);
        }
        public function set gzMeasure(value:Boolean):void{
            this._gzMeasure = value;
        }
        public function set gzMonTag(value:GZMon):void{
            this._gzMonTag = value;
        }
        public function get dvrAvailable():Boolean{
            return (this._dvrAvailable);
        }
        public function set dvrAvailable(value:Boolean):void{
            this._dvrAvailable = value;
        }
        public function get endLivePlaybackDelay():Boolean{
            return (this._endLivePlaybackDelay);
        }
        public function set mediaAnalyticsInfo(value:Object):void{
            this._mediaAnalyticsInfo = value;
        }

    }
}//package com.ibm.media 
﻿package com.ibm.media {
    import flash.external.*;

    public class StreamObject {

        public static const VIDEO_THUMB:String = "THUMB_";
        public static const VIDEO_MAIN:String = "MAIN";
        public static const VIDEO_PIP:String = "PIP";

        private var _stream:String;
        private var _bitrate:Number;
        private var _cdn:String;
        private var _attemptMax:Number;
        private var _dvrAvailable:int;
        private var _seekPos:Number;
        private var _bufferTime:Number;
        private var _liveStreamTimeout:Number;
        private var _dvrURL:String;
        private var _dvrCDN:String;
        private var _type:String;
        private var _channelName:String;
        private var _videoLocation:String;
        private var _syndicator:String;

        public function StreamObject(){
            super();
        }
        public function get convivaBitrates():Array{
            return (new Array(564000, 1064000, 1564000, 2200000, 3000000));
        }
        public function get convivaOptions():Object{
            var obj:Object = new Object();
            obj.bitrateKbps = 2200;
            return (obj);
        }
        public function get convivaTags():Object{
            var obj:Object = new Object();
            obj.pageUrl = ExternalInterface.call("window.location.href.toString");
            obj.serverName = this.cdn;
            obj.contentType = "live";
            obj.playerType = "flashLive";
            obj.playerVersion = "flashLive 1.0";
            obj.platform = "flash";
            obj.view = VIDEO_MAIN;
            obj.syndicator = this.syndicator.toUpperCase();
            return (obj);
        }
        public function get videoLocation():String{
            return (this._videoLocation);
        }
        public function set videoLocation(value:String):void{
            this._videoLocation = value;
        }
        public function get channelName():String{
            return (this._channelName);
        }
        public function set channelName(value:String):void{
            this._channelName = value;
        }
        public function get stream():String{
            return (this._stream);
        }
        public function set stream(value:String):void{
            this._stream = value;
        }
        public function get bitrate():Number{
            return (this._bitrate);
        }
        public function set bitrate(value:Number):void{
            this._bitrate = value;
        }
        public function get cdn():String{
            return (this._cdn);
        }
        public function set cdn(value:String):void{
            this._cdn = value;
        }
        public function get attemptMax():Number{
            return (this._attemptMax);
        }
        public function set attemptMax(value:Number):void{
            this._attemptMax = value;
        }
        public function get dvrAvailable():int{
            return (this._dvrAvailable);
        }
        public function set dvrAvailable(value:int):void{
            this._dvrAvailable = value;
        }
        public function get seekPos():Number{
            return (this._seekPos);
        }
        public function set seekPos(value:Number):void{
            this._seekPos = value;
        }
        public function get bufferTime():Number{
            return (this._bufferTime);
        }
        public function set bufferTime(value:Number):void{
            this._bufferTime = value;
        }
        public function get liveStreamTimeout():Number{
            return (this._liveStreamTimeout);
        }
        public function set liveStreamTimeout(value:Number):void{
            this._liveStreamTimeout = value;
        }
        public function get dvrURL():String{
            return (this._dvrURL);
        }
        public function set dvrURL(value:String):void{
            this._dvrURL = value;
        }
        public function get dvrCDN():String{
            return (this._dvrCDN);
        }
        public function set dvrCDN(value:String):void{
            this._dvrCDN = value;
        }
        public function get type():String{
            return (this._type);
        }
        public function set type(value:String):void{
            this._type = value;
        }
        public function get syndicator():String{
            return (this._syndicator);
        }
        public function set syndicator(value:String):void{
            this._syndicator = value;
        }

    }
}//package com.ibm.media 
﻿package com.conviva.network {
    import flash.utils.*;
    import com.conviva.utils.*;

    public class DataLoadable {

        private var _arr:ByteArray = null;

        public function DataLoadable(){
            super();
        }
        public static function FromString(str:String):DataLoadable{
            if (str == null){
                return (null);
            };
            var arr:ByteArray = new ByteArray();
            arr.writeUTFBytes(str);
            arr.position = 0;
            return (FromRepr(arr));
        }
        public static function FromByteArray(ba:Object):DataLoadable{
            var realBa:ByteArray;
            var i:int;
            if ((ba is ByteArray)){
                return (FromRepr((ba as ByteArray)));
            };
            realBa = new ByteArray();
            while (i < ba.Length) {
                realBa.writeByte(ba.GetValue(i));
                i++;
            };
            realBa.position = 0;
            return (FromRepr(realBa));
        }
        public static function FromRepr(arr:ByteArray):DataLoadable{
            if (arr == null){
                return (null);
            };
            var res:DataLoadable = new (DataLoadable)();
            res._arr = arr;
            return (res);
        }

        public function ToRepr():ByteArray{
            return (_arr);
        }
        public function ToStr():String{
            if (_arr == null){
                return (null);
            };
            return (_arr.readUTFBytes(_arr.length));
        }
        public function ToXml():XML{
            var msg:* = null;
            if (_arr == null){
                return (null);
            };
            return (new XML(_arr));
            var _slot1:* = e;
            msg = "GenericLoader.xml ";
            if ((Utils.NextRandom32() % 100) == 0){
                try {
                    msg = (msg + (" data error IGNORE = " + _arr.toString()));
                } catch(e:Error) {
                };
            };
            msg = (msg + (" error IGNORE : " + _slot1));
            Ping.Send(msg);
            Trace.Error("DataLoadable", msg);
            return (null);
        }
        public function ToByteArray():ArrayCS{
            var a:Array = new Array();
            var i:int;
            while (i < _arr.length) {
                a.push(_arr[i]);
                i++;
            };
            return (ArrayCS.FromRepr(a));
        }

    }
}//package com.conviva.network 
﻿package com.conviva.network {
    import com.conviva.utils.*;
    import flash.net.*;
    import flash.utils.*;

    public class DataLoader extends GenericLoader {

        public function DataLoader(dataUrl:String, callback:Function, toSend:DataLoadable, options:Object=null){
            super(GenericLoader.DATA_LOADER, callback);
            if (((options) && (options.hasOwnProperty("ToObject")))){
                options = options.ToObject();
            };
            if (((options) && (options.hasOwnProperty("timeoutMs")))){
                _timeoutMs = int(options["timeoutMs"]);
            };
            if (((((options) && (options.hasOwnProperty("dataFormat")))) && ((options["dataFormat"] == "BINARY")))){
                dataFormat = URLLoaderDataFormat.BINARY;
            } else {
                dataFormat = URLLoaderDataFormat.TEXT;
            };
            var request:URLRequest = new URLRequest(dataUrl);
            if (!(((((options) && (options.hasOwnProperty("noHeaders")))) && ((options["noHeaders"] == true))))){
                request.requestHeaders.push(new URLRequestHeader("pragma", "no-cache"));
            };
            if (toSend != null){
                request.method = URLRequestMethod.POST;
                request.data = toSend.ToRepr();
                dataFormat = URLLoaderDataFormat.BINARY;
                if (request.data.length == 0){
                    request.data.length = 1;
                };
            };
            load(request);
        }
        public function get Response():DataLoadable{
            if (!(_loaded)){
                return (null);
            };
            var d:Object = data;
            if (dataFormat == URLLoaderDataFormat.TEXT){
                return (DataLoadable.FromString(String(d)));
            };
            return (DataLoadable.FromRepr(ByteArray(data)));
        }

    }
}//package com.conviva.network 
﻿package com.conviva.network {
    import com.conviva.utils.*;
    import flash.display.*;
    import flash.events.*;
    import flash.net.*;
    import flash.system.*;

    public class GenericLoader {

        public static const DATA_LOADER:int = 222;
        public static const CLASS_LOADER:int = 111;

        private var _callback:Function;
        private var _timeoutDelayAction:uint = 0;
        private var _type:int;
        protected var _loaded:Boolean;
        protected var _timeoutMs:uint;
        private var _loadedUrl:String;
        private var _loader:Object;
        private var _loading:Boolean;

        public function GenericLoader(type:int, callback:Function){
            var type:* = type;
            var callback:* = callback;
            super();
            Utils.Assert((((type == GenericLoader.CLASS_LOADER)) || ((type == GenericLoader.DATA_LOADER))), "GenericLoader constructor");
            _type = type;
            _callback = callback;
            try {
                if (_type == CLASS_LOADER){
                    _loader = new Loader();
                    _loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler);
                    _loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
                    _loader.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandler);
                } else {
                    _loader = new URLLoader();
                    _loader.addEventListener(Event.COMPLETE, completeHandler);
                    _loader.addEventListener(IOErrorEvent.IO_ERROR, errorHandler);
                    _loader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, errorHandler);
                };
            } catch(e:Error) {
                Ping.Send(("GenericLoader error " + e));
            };
            _loaded = false;
            _loadedUrl = "";
            _loading = false;
            _timeoutMs = 0;
            _timeoutDelayAction = 0;
        }
        public function get dataFormat():String{
            return (_loader.dataFormat);
        }
        public function set dataFormat(df:String):void{
            Utils.Assert((_type == GenericLoader.DATA_LOADER), "GenericLoader.dataFormat");
            _loader.dataFormat = df;
        }
        public function Cleanup():void{
            if (!(_loader)){
                return;
            };
            try {
                if (_type == CLASS_LOADER){
                    _loader.contentLoaderInfo.removeEventListener(Event.COMPLETE, completeHandler);
                    _loader.unload();
                    _loader.close();
                } else {
                    _loader.removeEventListener(Event.COMPLETE, completeHandler);
                    _loader.close();
                };
            } catch(e) {
            };
            cleanupTimer();
            _loader = null;
            _loaded = false;
            _loadedUrl = "";
            _loading = false;
            _callback = null;
        }
        public function get loaded():Boolean{
            return (_loaded);
        }
        public function get available():Boolean{
            return (((!((_loader == null))) && (!(_loading))));
        }
        public function set timeoutMs(ms:uint):void{
            _timeoutMs = ms;
        }
        private function completeHandler(e:Event):void{
            var l:* = null;
            var e:* = e;
            l = this;
            Utils.ResetBreadCrumbs();
            Utils.RunProtected(function (){
                if (_loading){
                    _loaded = true;
                    _loading = false;
                    cleanupTimer();
                    if (_callback != null){
                        _callback(null, l);
                    };
                };
            }, ("GenericLoader.complete : " + _loadedUrl));
        }
        public function get xml():XML{
            var msg:* = null;
            Utils.Assert((_type == GenericLoader.DATA_LOADER), "GenericLoader.xml");
            var retval:* = null;
            try {
                retval = new XML(data);
            } catch(e:TypeError) {
                msg = "GenericLoader.xml ";
                if ((Utils.NextRandom32() % 100) == 0){
                    try {
                        msg = (msg + (" data error IGNORE = " + data.toString()));
                    } catch(e:Error) {
                    };
                };
                msg = (msg + (((" error IGNORE for " + _loadedUrl) + " : ") + e));
                Ping.Send(msg);
            };
            return (retval);
        }
        public function GetType(className:String):Class{
            var className:* = className;
            Utils.Assert((_type == GenericLoader.CLASS_LOADER), "GenericLoader.getClass");
            if (_loading){
                return (null);
            };
            var retval:* = null;
            try {
                retval = (_loader.contentLoaderInfo.applicationDomain.getDefinition(className) as Class);
            } catch(e:Error) {
                Ping.Send(((((("GenericLoader.getClass error for " + className) + " : ") + e) + " in ") + _loadedUrl));
            };
            return (retval);
        }
        private function errorHandler(ev:Event=null):void{
            var l:* = null;
            var ev = ev;
            l = this;
            Utils.ResetBreadCrumbs();
            Utils.RunProtected(function (){
                var err:Error;
                if (_loading){
                    _loaded = false;
                    _loading = false;
                    cleanupTimer();
                    if (ev == null){
                        err = new Error("timeout");
                    } else {
                        if (ev.type == IOErrorEvent.IO_ERROR){
                            err = new Error(("IO: " + ev.toString()));
                        } else {
                            if (ev.type == SecurityErrorEvent.SECURITY_ERROR){
                                err = new Error(("Security: " + ev.toString()));
                            } else {
                                err = new Error("error");
                            };
                        };
                    };
                    if (_callback != null){
                        _callback(err, l);
                    };
                };
            }, ("GenericLoader.error " + _loadedUrl));
        }
        private function cleanupTimer():void{
            if (_timeoutDelayAction){
                ProtectedTimer.CancelDelayedAction(_timeoutDelayAction);
                _timeoutDelayAction = 0;
            };
        }
        public function get Loaded():Boolean{
            return (_loaded);
        }
        public function load(request:URLRequest):void{
            var context:* = null;
            var request:* = request;
            Utils.Assert(available, "GenericLoader.load");
            _loading = true;
            _loaded = false;
            _loadedUrl = request.url;
            try {
                if (_timeoutMs > 0){
                    _timeoutDelayAction = ProtectedTimer.DelayAction(errorHandler, _timeoutMs, "GenericLoader.timeout");
                } else {
                    _timeoutDelayAction = 0;
                };
                if (_type == CLASS_LOADER){
                    context = new LoaderContext();
                    context.applicationDomain = new ApplicationDomain();
                    context.securityDomain = SecurityDomain.currentDomain;
                    _loader.load(request, context);
                } else {
                    _loader.load(request);
                };
            } catch(e:Error) {
                errorHandler(new Event("error"));
            };
        }
        public function get data():Object{
            Utils.Assert((_type == GenericLoader.DATA_LOADER), "GenericLoader.data");
            var retval:* = null;
            try {
                retval = _loader.data;
            } catch(e:TypeError) {
                Ping.Send(((("GenericLoader.data error IGNORE for " + _loadedUrl) + ": ") + e));
            };
            return (retval);
        }

    }
}//package com.conviva.network 
﻿package com.conviva.network {
    import flash.net.*;

    public class ClassLoader extends GenericLoader {

        private var _swfUrl:String;

        public function ClassLoader(swfUrl:String, callback:Function, timeoutMs:uint=0){
            super(GenericLoader.CLASS_LOADER, callback);
            _timeoutMs = timeoutMs;
            _swfUrl = swfUrl;
            var request:URLRequest = new URLRequest(_swfUrl);
            load(request);
        }
        public function get ModuleUrl():String{
            return (_swfUrl);
        }

    }
}//package com.conviva.network 
﻿package com.conviva {
    import com.conviva.utils.*;

    public class ConvivaGenericSession {

        protected static var _nextSessionId:int = 0;

        var _metrics:MetricsProxy = null;
        protected var _apiId:int;

        public function ConvivaGenericSession(){
            super();
            _apiId = _nextSessionId++;
            _metrics = new MetricsProxy(_apiId);
        }
        public function cleanup():void{
            _metrics = null;
            Utils.RunProtected(function (){
                LivePassInit.InvokeWhenReady("Cleanup", function (){
                    var module:Object = LivePassInit.Module;
                    if (module == null){
                        return;
                    };
                    Reflection.InvokeMethod("cleanupSession", module, _apiId);
                });
            }, ("ConvivaGenericSession.cleanup." + _apiId));
        }
        public function get metrics():ICustomMetrics{
            return (_metrics);
        }
        public function get id():int{
            return (this._apiId);
        }

    }
}//package com.conviva 
﻿package com.conviva {
    import com.conviva.utils.*;
    import flash.utils.*;
    import com.conviva.stream.*;
    import flash.events.*;

    public class ConvivaLightSession extends ConvivaGenericSession {

        public static const ERROR_CONNECTION_FAILURE:String = "ERROR_CONNECTION_FAILURE";
        public static const ERROR_STREAMING_FAILURE:String = "ERROR_STREAMING_FAILURE";

        private var _contentInfo:ConvivaContentInfo;

        public function ConvivaLightSession(contentInfo:ConvivaContentInfo){
            var contentInfo:* = contentInfo;
            super();
            Utils.RunProtected(function (){
                _contentInfo = contentInfo;
                LivePassInit.InvokeWhenReady("ConvivaLightSession", function (){
                    var module:Object = LivePassInit.Module;
                    Utils.Assert(!((module == null)), "new ConvivaLightSession and LivePass not ready");
                    Reflection.InvokeMethod("newLightSession", module, _apiId, _contentInfo);
                });
            }, ("ConvivaLightSession.ctor." + _apiId));
        }
        static function SetJoinStartTime(options:Object):Object{
            var joinStartTime:* = NaN;
            var options:* = options;
            var dictOptions:* = Lang.DictionaryFromRepr(options);
            if (dictOptions == null){
                dictOptions = new DictionaryCS();
            };
            if (!(dictOptions.ContainsKey("joinStartTime"))){
                dictOptions.SetValue("joinStartTime", Utils.GetEpochMilliseconds().toString());
            } else {
                try {
                    joinStartTime = Number(dictOptions.GetValue("joinStartTime"));
                    if (joinStartTime < (Utils.GetEpochMilliseconds() - (3600 * 1000))){
                        joinStartTime = (joinStartTime + (Utils.GetEpochMilliseconds() - getTimer()));
                        dictOptions.SetValue("joinStartTime", joinStartTime.toString());
                    };
                } catch(e) {
                };
            };
            return (dictOptions);
        }

        public function attachStreamer(streamer:Object):void{
            var streamer:* = streamer;
            LivePassInit.InvokeWhenReady("attachStreamer", function (){
                var module:Object = LivePassInit.Module;
                Utils.Assert(!((module == null)), "attachStreamer called before the LivePass is ready");
                var resource:String;
                Reflection.InvokeMethod("startMonitor", module, _apiId, _contentInfo, streamer, resource, null);
            });
        }
        public function reportError(errorName:String):void{
            var errorName:* = errorName;
            LivePassInit.InvokeWhenReady("reportError", function (){
                var module:Object = LivePassInit.Module;
                Utils.Assert(!((module == null)), "LivePass not ready");
                Reflection.InvokeMethod("reportSessionError", module, _apiId, errorName);
            });
        }
        public function setCurrentBitrate(bitrateKbps:uint):void{
            var bitrateKbps:* = bitrateKbps;
            Utils.RunProtected(function (){
                LivePassInit.InvokeWhenReady("setCurrentBitrate", function (){
                    var module:Object = LivePassInit.Module;
                    Utils.Assert(!((module == null)), "setCurrentBitrate called when LivePass not ready");
                    Reflection.InvokeMethod("setCurrentBitrate", module, _apiId, bitrateKbps);
                });
            }, ("ConvivaLightSession.setCurrentBitrate." + _apiId));
        }
        public function startMonitor(streamer:Object, resource:String, optionsDeprecated:Object=null):void{
            var optDict:* = null;
            var p:* = null;
            var streamer:* = streamer;
            var resource:* = resource;
            var optionsDeprecated = optionsDeprecated;
            optDict = null;
            if (optionsDeprecated != null){
                optDict = new DictionaryCS();
                for (p in optionsDeprecated) {
                    optDict.Add(p, optionsDeprecated[p]);
                };
            };
            _contentInfo.monitoringOptions = ConvivaLightSession.SetJoinStartTime(_contentInfo.monitoringOptions);
            Utils.RunProtected(function (){
                LivePassInit.InvokeWhenReady("startMonitor", function (){
                    var module:Object = LivePassInit.Module;
                    Utils.Assert(!((module == null)), "startMonitor called before the LivePass is ready");
                    Reflection.InvokeMethod("startMonitor", module, _apiId, _contentInfo, streamer, resource, optDict);
                });
            }, ("ConvivaLightSession.startMonitor." + _apiId));
        }
        public function stopMonitor():void{
            Utils.RunProtected(function (){
                LivePassInit.InvokeWhenReady("stopMonitor", function (){
                    var module:Object = LivePassInit.Module;
                    Utils.Assert(!((module == null)), "stopMonitor called when LivePass not ready");
                    Reflection.InvokeMethod("stopMonitor", module, _apiId);
                });
            }, ("ConvivaLightSession.stopMonitor." + _apiId));
        }
        public function pauseMonitor():void{
            Utils.RunProtected(function (){
                LivePassInit.InvokeWhenReady("pauseMonitor", function (){
                    var module:Object = LivePassInit.Module;
                    Utils.Assert(!((module == null)), "pauseMonitor called when LivePass not ready");
                    Reflection.InvokeMethod("pauseMonitor", module, _apiId);
                });
            }, ("ConvivaLightSession.pauseMonitor." + _apiId));
        }
        public function reportNetStatusEvent(event:NetStatusEvent):void{
            var event:* = event;
            LivePassInit.InvokeWhenReady("reportError", function (){
                var module:Object = LivePassInit.Module;
                Utils.Assert(!((module == null)), "LivePass not ready");
                Reflection.InvokeMethod("reportSessionNetStatusEvent", module, _apiId, event);
            });
        }

    }
}//package com.conviva 
﻿package com.conviva {
    import com.conviva.utils.*;

    public class ConvivaMetricsSession extends ConvivaGenericSession {

        public function ConvivaMetricsSession(objectId:String){
            var objectId:* = objectId;
            super();
            Utils.RunProtected(function (){
                LivePassInit.InvokeWhenReady("ConvivaMetricsSession", function (){
                    var module:Object = LivePassInit.Module;
                    Utils.Assert(!((module == null)), "new ConvivaMetricsSession and LivePass not ready");
                    Reflection.InvokeMethod("newMetricsSession", module, _apiId, objectId);
                });
            }, ("ConvivaMetricsSession.ctor." + _apiId));
        }
    }
}//package com.conviva 
﻿package com.conviva.stream {
    import com.conviva.utils.*;

    public class ConvivaContentInfo {

        public static const _allowableMonitoringOptions:Array = ["joinStartTime", "bitrateKbps", "bitrateEstimators", "playFailedAfterNSecondsBuffering", "playFailedAfterNSecondsJoining", "contentDuration"];
        public static const MAX_PARAMETER_LENGTH:int = 128;

        private var _isLive:Boolean = false;
        private var _objectId:String = "noobj";
        private var _bitrate:Number = 0;
        private var _monitoringOptions:Object;
        private var _tags:Object;

        public function ConvivaContentInfo(objectId:String, candidateResources:Object, tags:Object){
            _tags = {};
            _monitoringOptions = {};
            super();
            _objectId = objectId;
            _tags = tags;
            _isLive = false;
        }
        public function sanitizeData():void{
            var tag1:Object;
            var tag:Object;
            var newTag:String;
            var newTagValue:String;
            _objectId = sanitizeString(_objectId, "Null title", true, "objectId");
            if (_tags == null){
                _tags = new Object();
            };
            var checkTags:Object = _tags;
            if (_tags.hasOwnProperty("ToObject")){
                checkTags = _tags.ToObject();
            };
            var tagKeys:Array = new Array();
            for (tag1 in checkTags) {
                tagKeys.push(tag1);
            };
            for each (tag in tagKeys) {
                newTag = sanitizeString(tag, "null", false, "tag name");
                newTagValue = sanitizeString(checkTags[tag], "null", false, "tag value");
                if (newTag != tag){
                    delete checkTags[tag];
                    checkTags[newTag] = newTagValue;
                };
                if (newTagValue != checkTags[newTag]){
                    checkTags[newTag] = newTagValue;
                };
            };
            _tags = checkTags;
        }
        public function get initFromHttpService():Boolean{
            return (false);
        }
        public function get tags():Object{
            return (_tags);
        }
        private function sanitizeString(s:Object, defaultValue:String, allowC3GlobalObjectId:Boolean, name:String):String{
            var strs:String;
            if (!(s)){
                Utils.ReportErrorContinue((("ConvivaContentInfo: " + name) + " is null"), false);
                s = defaultValue;
            };
            if ((s is String)){
                strs = (s as String);
            } else {
                strs = s.toString();
            };
            strs = Lang.StringTrim(strs);
            if (((allowC3GlobalObjectId) && ((strs == Utils.GLOBAL_SESSION_OBJECT_ID)))){
            } else {
                if ((((strs.length >= 3)) && ((strs.substr(0, 3) == "c3.")))){
                    Utils.ReportErrorContinue(((("ConvivaContentInfo: " + name) + " is reserved IGNORE:") + objectId), false);
                    strs = ("_" + strs);
                };
            };
            if (strs.length > MAX_PARAMETER_LENGTH){
                Utils.ReportErrorContinue(((("ConvivaContentInfo: " + name) + " is too long IGNORE:") + objectId), false);
                strs = strs.substr(0, MAX_PARAMETER_LENGTH);
            };
            return (strs);
        }
        public function set bitrate(arg:Number):void{
            _bitrate = arg;
        }
        public function cleanup():void{
            _isLive = false;
        }
        public function set isLive(b:Boolean):void{
            _isLive = b;
        }
        public function get bitrate():Number{
            return (_bitrate);
        }
        TESTAPI function set objectId(value:String):void{
            _objectId = value;
        }
        public function get monitoringOptions():Object{
            return (_monitoringOptions);
        }
        public function set tags(arg:Object):void{
            _tags = arg;
        }
        public function get objectId():String{
            return (_objectId);
        }
        public function set monitoringOptions(options:Object):void{
            _monitoringOptions = options;
        }
        public function get isLive():Boolean{
            return (_isLive);
        }

    }
}//package com.conviva.stream 
﻿package com.conviva.internal_access {

    public namespace TESTAPI = "http://livepass.conviva.com/2.1/TESTAPI";
}//package com.conviva.internal_access 
﻿package com.conviva {

    public interface ICustomMetrics {

        function sendEvent2(_arg1:String, _arg2:Object, _arg3:Object, _arg4:Object):void;
        function sendEvent(_arg1:String, _arg2:Object):void;
        function sendMeasurement(_arg1:String, _arg2:Object, _arg3:Number):void;
        function setState(_arg1:Object):void;

    }
}//package com.conviva 
﻿package com.conviva {
    import com.conviva.utils.*;
    import flash.events.*;
    import com.conviva.stream.*;

    public class LivePass {

        private static const STATE_INIT_PENDING:int = -2;
        private static const STATE_NOT_INITIALIZED:int = -1;
        private static const STATE_ERROR:int = -3;
        private static const STATE_READY:int = 0;

        private static var _statsTimer:ProtectedTimer;
        private static var _sess:DictionaryCS = new DictionaryCS();
        private static var _initHandler:Function;
        private static var _currentState:int = STATE_NOT_INITIALIZED;

        public function LivePass(){
            super();
        }
        public static function get metrics():ICustomMetrics{
            return (LivePassInit.GetGlobalMetrics());
        }
        private static function addStreamer(streamer:Object, ls:ConvivaLightSession):void{
            var key:Object = getStreamerKey(streamer, true, ls.id);
            _sess.SetValue(key, ls);
        }
        public static function init(serviceUrl:String, customerId:String, callback:Function, optionsObsolete:Object=null):void{
            var serviceUrl:* = serviceUrl;
            var customerId:* = customerId;
            var callback:* = callback;
            var optionsObsolete = optionsObsolete;
            Utils.RunProtected(function (){
                if ((((_currentState == STATE_INIT_PENDING)) || ((_currentState == STATE_READY)))){
                    return;
                };
                Trace.senderName = "LivePass";
                _initHandler = callback;
                _currentState = STATE_INIT_PENDING;
                _statsTimer = null;
                LivePassInit.Init(serviceUrl, customerId, ourInitHandler);
            }, "LivePass.init");
        }
        private static function removeStreamer(streamer:Object):void{
            var key:Object = getStreamerKey(streamer, false, 0);
            _sess.Remove(key);
        }
        public static function createMonitoringSession(streamer:Object, contentName:String, tags:Object, options:Object):ConvivaLightSession{
            var streamer:* = streamer;
            var contentName:* = contentName;
            var tags:* = tags;
            var options:* = options;
            return (Utils.RunProtectedResult(function (){
                var dictTags:*;
                if (((!((streamer == null))) && (!((getMonitoringSession(streamer) == null))))){
                    Trace.Error("LivePass", "createMonitoringSession called twice for the same streamer");
                    return (null);
                };
                options = ConvivaLightSession.SetJoinStartTime(options);
                var candidateResources:* = new ListCS();
                var serverName:* = null;
                if (tags != null){
                    dictTags = Lang.DictionaryFromRepr(tags);
                    if (dictTags.ContainsKey("serverName")){
                        serverName = dictTags.GetValue("serverName");
                    };
                };
                if (serverName == null){
                    serverName = "unknown";
                } else {
                    candidateResources.Add(serverName);
                };
                var cci:* = new ConvivaContentInfo(contentName, candidateResources, tags);
                cci.monitoringOptions = options;
                var lsess:* = new ConvivaLightSession(cci);
                if (streamer != null){
                    addStreamer(streamer, lsess);
                };
                lsess.startMonitor(streamer, serverName);
                return (lsess);
            }, "LivePass.createMonitoringSession", null));
        }
        public static function get pending():Boolean{
            return ((_currentState == STATE_INIT_PENDING));
        }
        public static function get stats():Object{
            var stats:DictionaryCS = new DictionaryCS();
            stats.SetValue("LivePass.version", LivePassVersion.versionStr);
            LivePassInit.GatherStats(stats);
            return (Lang.StringDictionaryToRepr(stats));
        }
        static function setReady():void{
            _currentState = STATE_READY;
        }
        public static function get ready():Boolean{
            return ((_currentState == STATE_READY));
        }
        public static function cleanup():void{
            Utils.RunProtected(function (){
                var streamer:Object;
                for each (streamer in _sess.Keys) {
                    cleanupMonitoringSession(streamer);
                };
                _sess.Clear();
                if (_statsTimer != null){
                    _statsTimer.Cleanup();
                    _statsTimer = null;
                };
                _initHandler = null;
                LivePassInit.Cleanup();
                _currentState = STATE_NOT_INITIALIZED;
            }, "LivePass.cleanup");
        }
        public static function get version():String{
            return (LivePassVersion.versionStr);
        }
        public static function cleanupMonitoringSession(streamer:Object):void{
            var streamer:* = streamer;
            Utils.RunProtected(function (){
                if ((((streamer == null)) || ((_sess == null)))){
                    Trace.Error("LivePass", "cleanupMonitoringSession called before createMonitoringSession");
                    return;
                };
                var lsess:ConvivaLightSession = getMonitoringSession(streamer);
                if (lsess != null){
                    lsess.stopMonitor();
                    lsess.cleanup();
                    removeStreamer(streamer);
                };
            }, "LivePass.cleanupMonitoringSession");
        }
        public static function getMonitoringSession(streamer:Object):ConvivaLightSession{
            var key:Object = getStreamerKey(streamer, false, 0);
            if (_sess.ContainsKey(key)){
                return (_sess.GetValue(key));
            };
            return (null);
        }
        private static function getStreamerKey(streamer:Object, create:Boolean, defaultId:int):Object{
            return (streamer);
        }
        private static function ourInitHandler(note:ConvivaNotification):void{
            var note:* = note;
            if (note.code == ConvivaNotification.SUCCESS_LIVEPASS_READY){
                _currentState = STATE_READY;
                _statsTimer = new ProtectedTimer(1000, function (){
                    Trace.Stats(stats);
                }, "LP.Stats");
            } else {
                if ((((note.code == ConvivaNotification.ERROR_LOAD_CONFIGURATION)) || ((note.code == ConvivaNotification.ERROR_LOAD_MODULE)))){
                    _currentState = STATE_ERROR;
                };
            };
            if (_initHandler != null){
                Utils.RunProtected(function (){
                    _initHandler(note);
                }, "LivePass notifier");
            };
        }

    }
}//package com.conviva 
﻿package com.conviva {
    import com.conviva.utils.*;
    import com.conviva.network.*;
    import flash.utils.*;
    import com.conviva.internal_access.*;

    public class LivePassInit {

        private static const LAST_USED_MODULES:String = "lastSwfUrls";

        private static var _moduleInstance:Object;
        private static var _globalMetricsSession:ConvivaMetricsSession;
        private static var _configLoader:LivePassConfigLoader = null;
        private static var _serviceUrl:String = null;
        private static var _initDoneCbk:Function = null;
        private static var _debugStats:DictionaryCS;
        private static var _lastModuleURL:String = null;
        private static var _currentConfig:String = null;
        private static var _customerId:String;
        private static var _livePassReadyActions:ListCS;
        private static var _moduleLoader:ClassLoader = null;

        public function LivePassInit(){
            super();
            Utils.ReportError("LivePassInit: is a static class");
        }
        static function GetGlobalMetrics():ICustomMetrics{
            if (_globalMetricsSession != null){
                return (_globalMetricsSession.metrics);
            };
            _globalMetricsSession = new ConvivaMetricsSession(Utils.GLOBAL_SESSION_OBJECT_ID);
            return (_globalMetricsSession.metrics);
        }
        public static function Cleanup():void{
            Ping.Cleanup();
            if (_globalMetricsSession != null){
                _globalMetricsSession.cleanup();
                _globalMetricsSession = null;
            };
            if (_moduleInstance != null){
                Reflection.InvokeMethod("cleanup", _moduleInstance);
                _moduleInstance = null;
            };
            if (_moduleLoader != null){
                _moduleLoader.Cleanup();
                _moduleLoader = null;
            };
            if (_configLoader != null){
                _configLoader.Cleanup();
                _configLoader = null;
            };
            _initDoneCbk = null;
            _serviceUrl = null;
            _currentConfig = null;
            _moduleInstance = null;
            _livePassReadyActions = null;
            _lastModuleURL = null;
            if (_moduleInstance != null){
                Reflection.InvokeMethod("cleanup", _moduleInstance);
            };
        }
        public static function get Module():Object{
            return (_moduleInstance);
        }
        public static function InvokeWhenReadyTimeout(what:String, callback:Function, timeoutMs:int):void{
            var what:* = what;
            var callback:* = callback;
            var timeoutMs:* = timeoutMs;
            if (!(LivePass.pending)){
                callback();
                return;
            };
            _livePassReadyActions.Add(callback);
            if (timeoutMs > 0){
                ProtectedTimer.DelayAction(function (){
                    CheckNotifierTimeout(callback);
                }, timeoutMs, "LPInit.invokeWhenReady");
            };
        }
        public static function InvokeWhenReady(what:String, func:Function):void{
            if (LivePass.ready){
                Utils.RunProtected(func, ("InvokeWhenReady." + what));
            } else {
                if (_livePassReadyActions != null){
                    _livePassReadyActions.Add(func);
                };
            };
        }
        private static function LivePassConfigLoaded():void{
            _currentConfig = _configLoader.CurrentConfig;
            if (_moduleLoader != null){
                if (CheckModuleUrl(_moduleLoader.ModuleUrl)){
                    CheckInitDone();
                    return;
                };
                _moduleLoader.Cleanup();
                _moduleLoader = null;
            };
            StartLoadingModule(PickModuleUrl());
        }
        TESTAPI static function GetLastModuleURL():String{
            return (_lastModuleURL);
        }
        private static function CheckNotifierTimeout(callback:Function):void{
            if (_livePassReadyActions == null){
                return;
            };
            var idx:int = _livePassReadyActions.IndexOf(callback);
            if (idx >= 0){
                _livePassReadyActions.RemoveAt(idx);
                callback();
            };
        }
        static function NotifyLivePassReady():void{
            var actions:ListCS;
            var act:Function;
            LivePass.setReady();
            if (((!((_livePassReadyActions == null))) && ((_livePassReadyActions.Count > 0)))){
                actions = _livePassReadyActions;
                _livePassReadyActions = new ListCS();
                for each (act in actions.Values) {
                    Utils.RunProtected(act, "LivePassInit.NotifyLivePassReady");
                };
            };
            if (_initDoneCbk != null){
                _initDoneCbk(new ConvivaNotification(ConvivaNotification.SUCCESS_LIVEPASS_READY, "Conviva LivePass is ready", null));
            };
        }
        private static function ModuleLoadFinished(err:Error, loader:Object):void{
            var lastModuleUrls:DictionaryCS;
            if (err == null){
                lastModuleUrls = (PersistentConfig.SafeGetPropElse(LAST_USED_MODULES, null) as DictionaryCS);
                if (lastModuleUrls == null){
                    lastModuleUrls = new DictionaryCS();
                };
                lastModuleUrls.SetValue(_serviceUrl, _moduleLoader.ModuleUrl);
                PersistentConfig.SetProperty(LAST_USED_MODULES, Lang.StringDictionaryToRepr(lastModuleUrls));
                CheckInitDone();
            } else {
                if (_currentConfig == null){
                    return;
                };
                _debugStats.SetValue("LivePass.moduleLoadError", err.toString());
                Utils.ReportErrorContinue(("Error: failed to load the module " + _moduleLoader.ModuleUrl), true);
                if (_initDoneCbk != null){
                    _initDoneCbk(new ConvivaNotification(ConvivaNotification.ERROR_LOAD_MODULE, err.toString(), null));
                };
                Cleanup();
            };
        }
        TESTAPI static function GetModuleClass(className:String, slNamespace:String, as3Package:String):Class{
            if ((((((_moduleLoader == null)) || (!(_moduleLoader.Loaded)))) || ((_currentConfig == null)))){
                return (null);
            };
            if (as3Package != ""){
                className = ((as3Package + ".") + className);
            };
            return (_moduleLoader.GetType(className));
        }
        private static function StartLoadingModule(moduleUrl:String):void{
            _debugStats.SetValue("LivePass.moduleUrl", moduleUrl);
            Trace.Info("LivePassInit", ("loading module " + moduleUrl));
            _moduleLoader = new ClassLoader(moduleUrl, ModuleLoadFinished, 0);
        }
        private static function PickModuleUrl():String{
            var allUrls:ListCS = _configLoader.AllModuleUrls();
            Utils.Assert((allUrls.Count > 0), "have module url");
            return (allUrls.GetValue(0));
        }
        static function GatherStats(stats:DictionaryCS):void{
            var ostats:Object;
            var p:String;
            if (_configLoader != null){
                _configLoader.GatherStats(stats);
            };
            if (_moduleInstance != null){
                ostats = new Object();
                Reflection.InvokeMethod("gatherStats", _moduleInstance, ostats);
                for (p in ostats) {
                    stats.SetValue(p, ostats[p]);
                };
            };
        }
        private static function CheckModuleUrl(moduleUrl:String):Boolean{
            var allUrls:ListCS = _configLoader.AllModuleUrls();
            Utils.Assert((allUrls.Count > 0), "have module url");
            return ((allUrls.IndexOf(moduleUrl) >= 0));
        }
        public static function Init(serviceUrl:String, customerId:String, initDoneCbk:Function):void{
            var moduleUrl:* = null;
            var serviceUrl:* = serviceUrl;
            var customerId:* = customerId;
            var initDoneCbk:* = initDoneCbk;
            _serviceUrl = serviceUrl;
            _customerId = customerId;
            _initDoneCbk = initDoneCbk;
            _moduleInstance = null;
            _globalMetricsSession = null;
            _currentConfig = null;
            _lastModuleURL = null;
            Uuid.Init();
            var extraPingFields:* = DictionaryCS.New("cust", customerId);
            Ping.Init(serviceUrl, uint(Uuid.uuid.GetValue(0)), extraPingFields);
            _livePassReadyActions = new ListCS();
            Trace.Info("LivePassInit", ("serviceUrl=" + serviceUrl));
            _configLoader = LivePassConfigLoader.CreateOneTimeLoader(serviceUrl, customerId, LivePassConfigLoaded, function (e:Error){
                if (_initDoneCbk != null){
                    _initDoneCbk(new ConvivaNotification(ConvivaNotification.ERROR_LOAD_CONFIGURATION, ("Error loading module: " + e.toString()), null));
                };
            });
            _debugStats = new DictionaryCS();
            _configLoader.GatherStats(_debugStats);
            var lastModuleUrls:* = null;
            try {
                lastModuleUrls = Lang.DictionaryFromRepr(PersistentConfig.SafeGetPropElse(LAST_USED_MODULES, lastModuleUrls));
            } catch(e:Error) {
            };
            if (((!((lastModuleUrls == null))) && (lastModuleUrls.ContainsKey(serviceUrl)))){
                moduleUrl = lastModuleUrls.GetValue(serviceUrl);
                StartLoadingModule(moduleUrl);
                _lastModuleURL = moduleUrl;
            };
        }
        private static function CheckInitDone():void{
            if (_currentConfig == null){
                return;
            };
            if ((((_moduleLoader == null)) || (!(_moduleLoader.Loaded)))){
                return;
            };
            _moduleInstance = Reflection.CreateInstance(TESTAPI::GetModuleClass("LivePassModuleMain", "ConvivaLivePass", ""));
            var moduleOptions:DictionaryCS = new DictionaryCS();
            moduleOptions.SetValue("loaderVersionMajor", LivePassVersion.VERSION_MAJOR);
            moduleOptions.SetValue("loaderVersionMinor", LivePassVersion.VERSION_MINOR);
            moduleOptions.SetValue("loaderVersionRelease", LivePassVersion.VERSION_RELEASE);
            moduleOptions.SetValue("loaderVersionSvn", LivePassVersion.VERSION_SVN);
            moduleOptions.SetValue("traceSenderId", Trace.senderId);
            moduleOptions.SetValue("loaderNotificationCallback", ReportNotificationApi);
            Reflection.InvokeMethod("setModuleOptions", _moduleInstance, Lang.StringDictionaryToRepr(moduleOptions));
            Reflection.InvokeMethod("init", _moduleInstance, _serviceUrl, _customerId, _currentConfig);
            Trace.Info("LivePassInit", "complete");
            GetGlobalMetrics();
            NotifyLivePassReady();
        }
        static function ReportNotificationApi(note:Object):void{
            if ((((_initDoneCbk == null)) || ((note == null)))){
                return;
            };
            var clone:ConvivaNotification = (Reflection.Clone(note) as ConvivaNotification);
            if (clone == null){
                return;
            };
            if (_initDoneCbk != null){
                _initDoneCbk(clone);
            };
        }

    }
}//package com.conviva 
﻿package com.conviva.utils {

    public class ArrayCS {

        private var _array:Array;

        public function ArrayCS(nrElements:int=-1){
            super();
            if (nrElements >= 0){
                _array = new Array(nrElements);
            } else {
                _array = new Array();
            };
        }
        public static function New(... _args):ArrayCS{
            var res:ArrayCS = new (ArrayCS)();
            res._array = res._array.concat(_args);
            return (res);
        }
        public static function FromRepr(a:Array):ArrayCS{
            if (a == null){
                return (null);
            };
            var res:ArrayCS = new (ArrayCS)();
            res._array = a;
            return (res);
        }

        public function ToRepr():Array{
            return (_array);
        }
        public function get Values():Array{
            return (_array);
        }
        public function get Length():int{
            return (_array.length);
        }
        public function GetValue(index:int){
            return (_array[index]);
        }
        public function SetValue(index:int, v):void{
            _array[index] = v;
        }

    }
}//package com.conviva.utils 
﻿package com.conviva.utils {
    import flash.utils.*;

    public class DictionaryCS {

        private var _obj:Dictionary;

        public function DictionaryCS(){
            super();
            _obj = new Dictionary();
        }
        public static function New(... _args):DictionaryCS{
            var res:DictionaryCS = new (DictionaryCS)();
            var i:int;
            while ((i + 1) < _args.length) {
                res._obj[_args[i]] = _args[(i + 1)];
                i = (i + 2);
            };
            return (res);
        }
        public static function FromRepr(o:Object):DictionaryCS{
            var k:String;
            if (o == null){
                return (null);
            };
            if ((o is DictionaryCS)){
                return ((o as DictionaryCS));
            };
            if (o.hasOwnProperty("ToObject")){
                return (FromRepr(o.ToObject()));
            };
            var res:DictionaryCS = new (DictionaryCS)();
            if ((o is Dictionary)){
                res._obj = (o as Dictionary);
            } else {
                for (k in o) {
                    res._obj[k] = o[k];
                };
            };
            return (res);
        }

        public function ContainsKey(key):Boolean{
            return (!((_obj[key] == null)));
        }
        public function Add(key, val):void{
            _obj[key] = val;
        }
        public function get Values():Array{
            var p:*;
            var res:Array = new Array();
            for each (p in _obj) {
                res.push(p);
            };
            return (res);
        }
        public function Remove(key):Boolean{
            if (ContainsKey(key)){
                delete _obj[key];
                return (true);
            };
            return (false);
        }
        public function Clear():void{
            var p:*;
            for (p in _obj) {
                delete _obj[p];
            };
        }
        public function SetValue(key, v):void{
            _obj[key] = v;
        }
        public function get Keys():Array{
            var p:*;
            var res:Array = new Array();
            for (p in _obj) {
                res.push(p);
            };
            return (res);
        }
        public function CopyToObject(obj:Object):void{
            var k:String;
            for (k in _obj) {
                obj[k] = _obj[k];
            };
        }
        public function ToObject():Object{
            var o:Object = {};
            CopyToObject(o);
            return (o);
        }
        public function GetValue(key){
            return (_obj[key]);
        }
        public function get Count():int{
            var p:*;
            var res:int;
            for (p in _obj) {
                res++;
            };
            return (res);
        }
        public function Contains(key):Boolean{
            return (ContainsKey(key));
        }

    }
}//package com.conviva.utils 
﻿package com.conviva.utils {
    import flash.net.*;
    import flash.events.*;
    import flash.utils.*;

    public class TraceSender {

        private static const humanReadableTime:Boolean = false;

        private var _senderId:String = "";
        private var tracerConnection:LocalConnection;
        private var _channelName:String = "_conviva_trace_viewer";
        private var tracerEnabled:Boolean = true;
        private var lastCheckedForConnection:int = 0;

        public function TraceSender(){
            tracerConnection = new LocalConnection();
            super();
            tracerConnection.addEventListener(StatusEvent.STATUS, tracerEventHandler);
            tracerConnection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, tracerEventHandler);
            tracerConnection.addEventListener(AsyncErrorEvent.ASYNC_ERROR, tracerEventHandler);
        }
        public function set SenderId(v:String):void{
            _senderId = v;
        }
        private function tracerEventHandler(ev:Object):void{
            if (ev.level == "error"){
                tracerEnabled = false;
            };
        }
        private function AddToTrace(module:String, priority:String, ... _args):void{
            var t:* = null;
            var module:* = module;
            var priority:* = priority;
            var rest:* = _args;
            var dt:* = new Date();
            var msgBare:* = rest.toString();
            if (((!((module == null))) && ((module.length > 0)))){
                msgBare = ((module + ": ") + msgBare);
            };
            if (((!((priority == null))) && ((priority.length > 0)))){
                msgBare = ((priority + ": ") + msgBare);
            };
            var msg:* = ((("[" + ((humanReadableTime) ? CommonUtils.formatTime(dt) : (dt.time / 1000))) + "] ") + msgBare);
            if (Trace.traceToConsole){
                trace(msg);
            };
            if (Trace.extraTracers.length > 0){
                for each (t in Trace.extraTracers) {
                    try {
                        t(msgBare);
                    } catch(e) {
                    };
                };
            };
            if (Trace.traceToTraceViewer){
                sendToTracer("traceInfo", msg);
            };
        }
        public function Info(module:String, ... _args):void{
            AddToTrace(module, "", _args);
        }
        public function get SenderId():String{
            if (_senderId == ""){
                SenderName = "LivePass";
            };
            return (_senderId);
        }
        private function sendToTracer(method:String, data:Object):void{
            var now:* = 0;
            var method:* = method;
            var data:* = data;
            if (!(tracerEnabled)){
                now = getTimer();
                if (now > (lastCheckedForConnection + 2000)){
                    tracerEnabled = true;
                    lastCheckedForConnection = now;
                };
            };
            if (tracerEnabled){
                if ((data is String)){
                    data = ((("!" + SenderId) + "!") + data);
                } else {
                    data["Trace.senderId"] = SenderId;
                };
                try {
                    tracerConnection.send(_channelName, method, data);
                } catch(e) {
                    tracerEnabled = false;
                };
            };
        }
        public function Error(module:String, ... _args):void{
            AddToTrace(module, "ERROR", _args);
        }
        public function set SenderName(v:String):void{
            _senderId = ((v + "@") + (1 + int((134217726 * CommonUtils.random()))));
        }
        public function set ChannelName(value:String):void{
            _channelName = ("_conviva_trace_viewer" + value);
        }
        public function Stats(st:Object):void{
            if (Trace.traceToTraceViewer){
                sendToTracer("traceStats", st);
            };
        }

    }
}//package com.conviva.utils 
﻿package com.conviva.utils {

    public class Lang {

        public function Lang(){
            super();
        }
        public static function StringSubstring(str:String, startIndex:int, count:int=2147483647):String{
            if ((((((startIndex < 0)) || ((startIndex >= str.length)))) || (((!((count == 2147483647))) && ((((count < 0)) || (((startIndex + count) > str.length)))))))){
                throw (new Error("ArgumentOutOfRange"));
            };
            if (count == 2147483647){
                return (str.substr(startIndex));
            };
            return (str.substr(startIndex, count));
        }
        public static function XmlToString(x:XML):String{
            return (x.toXMLString());
        }
        public static function StringStartsWith(str1:String, str2:String):Boolean{
            return ((str1.indexOf(str2) == 0));
        }
        public static function ArrayToRepr(a:ArrayCS):Array{
            if (a == null){
                return (null);
            };
            return (a.ToRepr());
        }
        public static function StringToXml(str:String):XML{
            return (new XML(str));
        }
        public static function ListToRepr(l:ListCS):Array{
            if (l == null){
                return (null);
            };
            return (l.ToRepr());
        }
        public static function StringCompareTo(str1:String, str2:String):int{
            if (str1 == null){
                if (str2 == null){
                    return (0);
                };
                return (-1);
            };
            if (str2 == null){
                return (1);
            };
            if (str1 < str2){
                return (-1);
            };
            if (str1 == str2){
                return (0);
            };
            return (1);
        }
        public static function StringContains(str1:String, str2:String):Boolean{
            return ((str1.indexOf(str2) >= 0));
        }
        public static function StringTrim(str:String):String{
            var len:int = str.length;
            var i:int;
            while (i < len) {
                if (((((!((str.charAt(i) == " "))) && (!((str.charAt(i) == "\t"))))) && (!((str.charAt(i) == "\n"))))){
                    break;
                };
                i++;
            };
            if (i == len){
                return ("");
            };
            if (i > 0){
                str = str.substr(i);
                len = (len - i);
            };
            i = (len - 1);
            while (i >= 0) {
                if (((((!((str.charAt(i) == " "))) && (!((str.charAt(i) == "\t"))))) && (!((str.charAt(i) == "\n"))))){
                    break;
                };
                i--;
            };
            if (i < (len - 1)){
                return (str.substr(0, (i + 1)));
            };
            return (str);
        }
        public static function DictionaryFromRepr(repr:Object):DictionaryCS{
            return (DictionaryCS.FromRepr(repr));
        }
        public static function StringDictionaryToRepr(dict:DictionaryCS):Object{
            if (dict == null){
                return (null);
            };
            return (dict.ToObject());
        }
        public static function StringIndexOf(str:String, what:String, startIndex:int=0):int{
            return (str.indexOf(what, startIndex));
        }
        public static function StringGetChar(str1:String, idx:int):String{
            return (str1.charAt(idx));
        }
        public static function ListFromRepr(repr:Array):ListCS{
            return (ListCS.FromRepr(repr));
        }
        public static function ArrayFromRepr(repr:Array):ArrayCS{
            return (ArrayCS.FromRepr(repr));
        }

    }
}//package com.conviva.utils 
﻿package com.conviva.utils {
    import flash.utils.*;

    public class Trace {

        static var extraTracers:Array = new Array();
        public static var traceToConsole:Boolean = true;
        private static var defaultTraceSender:TraceSender = new TraceSender();
        public static var traceToTraceViewer:Boolean = true;

        public function Trace(){
            super();
        }
        public static function clearTracers():void{
            extraTracers = new Array();
        }
        public static function stats(st:Object):void{
            Stats(st);
        }
        public static function Info(module:String, ... _args):void{
            defaultTraceSender.Info(module, _args);
        }
        public static function set senderId(v:String):void{
            defaultTraceSender.SenderId = v;
        }
        public static function Error(module:String, ... _args):void{
            defaultTraceSender.Error(module, _args);
        }
        public static function addTracer(f:Function):void{
            extraTracers = extraTracers.concat(f);
        }
        public static function set senderName(v:String):void{
            defaultTraceSender.SenderName = v;
        }
        public static function get senderId():String{
            return (defaultTraceSender.SenderId);
        }
        public static function removeTracer(f:Function):void{
            var i:int;
            while (i < extraTracers.length) {
                if (f == extraTracers[i]){
                    extraTracers.splice(i, 1);
                };
                i++;
            };
        }
        public static function set channelName(value:String):void{
            defaultTraceSender.ChannelName = value;
        }
        public static function Stats(st:Object):void{
            defaultTraceSender.Stats(st);
        }

    }
}//package com.conviva.utils 
﻿package com.conviva.utils {

    public class Eventer {

        private var _handlers:ListCS;

        public function Eventer(){
            super();
            _handlers = new ListCS();
        }
        public function Cleanup():void{
            _handlers = new ListCS();
        }
        public function DispatchEvent():void{
            var h:Function;
            for each (h in _handlers.Values) {
                h();
            };
        }
        public function AddHandler(handler:Function):void{
            _handlers.Add(handler);
        }
        public function DeleteHandler(handler:Function):void{
            _handlers.Remove(handler);
        }

    }
}//package com.conviva.utils 
﻿package com.conviva.utils {
    import flash.utils.*;
    import flash.events.*;

    public class ProtectedTimer {

        private var _timer:Timer = null;
        private var _callback:Function;
        private var _debugMsg:String = null;
        private var _autoStart:Boolean = true;

        public function ProtectedTimer(delayMs:int, callback:Function, debugMsg:String, autoStart:Boolean=true){
            super();
            _timer = new Timer(delayMs, 0);
            _callback = callback;
            _autoStart = autoStart;
            _debugMsg = debugMsg;
            _timer.addEventListener(TimerEvent.TIMER, Tick);
            if (_autoStart){
                _timer.start();
            };
        }
        public static function DelayAction(callback:Function, delayMs:int, debugMsg:String):uint{
            var callback:* = callback;
            var delayMs:* = delayMs;
            var debugMsg:* = debugMsg;
            return (setTimeout(function (){
                Utils.ResetBreadCrumbs();
                Utils.RunProtected(callback, ((debugMsg) ? debugMsg : "DelayAction"));
            }, delayMs));
        }
        public static function CancelDelayedAction(id):void{
            clearTimeout(id);
        }

        public function Start():void{
            _timer.start();
        }
        public function get delay():Number{
            return (_timer.delay);
        }
        public function Cleanup():void{
            if (_timer != null){
                _timer.stop();
                _timer.reset();
                _timer.removeEventListener(TimerEvent.TIMER, Tick);
                _timer = null;
            };
            _callback = null;
        }
        public function Stop():void{
            _timer.stop();
        }
        public function Reset():void{
            _timer.reset();
            if (_autoStart){
                _timer.start();
            };
        }
        public function ChangeInterval(delayMs:int):void{
            _timer.delay = delayMs;
        }
        private function Tick(ev:Event):void{
            var ev:* = ev;
            Utils.ResetBreadCrumbs();
            Utils.RunProtected(function (){
                if (_callback != null){
                    _callback();
                };
            }, ((_debugMsg) ? _debugMsg : "ProtectedTimer.Tick"));
        }
        public function set delay(interval:Number):void{
            _timer.delay = interval;
        }
        public function get running():Boolean{
            return (_timer.running);
        }

    }
}//package com.conviva.utils 
﻿package com.conviva.utils {
    import flash.net.*;
    import flash.events.*;
    import flash.utils.*;
    import flash.system.*;
    import com.conviva.internal_access.*;

    public class Utils {

        public static const ERROR_CONNECTION_FAILURE:String = "ERROR_CONNECTION_FAILURE";
        public static const GLOBAL_SESSION_OBJECT_ID:String = "c3.global";
        public static const HTTP_HEADER_SIZE:int = 300;
        public static const MEDIA_TYPE_UNKNOWN:String = "unknown";
        public static const ERROR_STREAMING_FAILURE:String = "ERROR_STREAMING_FAILURE";
        public static const MEDIA_TYPE_HTTP_PROGRESSIVE:String = "http_progressive";
        public static const MEDIA_TYPE_HTTP_ZERI_STREAM:String = "http_zeri_stream";
        public static const MEDIA_TYPE_RTMP_STREAM:String = "rtmp_stream";

        TESTAPI static var _interceptUncaughtExceptions:Boolean = true;
        private static var _breadCrumbs:Array = new Array();
        TESTAPI static var reportError:Function = null;
        private static var _tickCountOffsetMs:Number = 0;

        public function Utils(){
            super();
        }
        public static function ResetBreadCrumbs():void{
            _breadCrumbs = new Array();
        }
        public static function UrlEncodeQuery(o:Object):String{
            if (o.hasOwnProperty("ToObject")){
                return (urlEncodeObject(o.ToObject()));
            };
            return (urlEncodeObject(o));
        }
        public static function urlEncodeObject(o:Object):String{
            var k:String;
            var saveCodePage:Boolean;
            var res:String;
            var url:URLVariables = new URLVariables();
            for (k in o) {
                url[k] = String(o[k]);
            };
            saveCodePage = System.useCodePage;
            System.useCodePage = false;
            res = url.toString();
            System.useCodePage = saveCodePage;
            return (res);
        }
        public static function RunProtected(f:Function, msg:String):void{
            RunProtectedResult(f, msg, null);
        }
        public static function PushBreadCrumb(crumb:String):void{
            _breadCrumbs.push(crumb);
        }
        public static function genericCleanup(obj){
            if (obj){
                if (obj.hasOwnProperty("cleanup")){
                    obj.cleanup();
                } else {
                    obj.Cleanup();
                };
            };
            return (null);
        }
        public static function NextRandom():Number{
            return (CommonUtils.random());
        }
        public static function runAfter(f:Function, delayMs:Number):uint{
            var f:* = f;
            var delayMs:* = delayMs;
            return (ProtectedTimer.DelayAction(function ():void{
                f();
            }, delayMs, "runAfter"));
        }
        public static function ReportError(what:String):void{
            if (ReportErrorContinue(what)){
                throw (new ConvivaStatus(what));
            };
        }
        public static function NextRandom32():uint{
            return (uint((CommonUtils.random() * uint.MAX_VALUE)));
        }
        public static function objectIsSame(src:Object, dst:Object):Boolean{
            if (((!(src)) && (!(dst)))){
                return (true);
            };
            if (((((!(src)) && (dst))) || (((src) && (!(dst)))))){
                return (false);
            };
            var p:String = "";
            for (p in src) {
                if (((!(dst.hasOwnProperty(p))) || (!((dst[p] == src[p]))))){
                    return (false);
                };
            };
            for (p in dst) {
                if (((!(src.hasOwnProperty(p))) || (!((src[p] == dst[p]))))){
                    return (false);
                };
            };
            return (true);
        }
        public static function UncaughtException(msg:String, err:Error):void{
            var toSend:String;
            var stack:String;
            if (_breadCrumbs.length > 0){
                msg = (msg + (("(crumbs: " + _breadCrumbs.toString()) + ")"));
            };
            if (((!((TESTAPI::reportError == null))) && (TESTAPI::reportError(msg, err)))){
                return;
            };
            if (!(TESTAPI::_interceptUncaughtExceptions)){
                throw (err);
            };
            if ((err is ConvivaStatus)){
                return;
            };
            toSend = ("Uncaught exception: " + msg);
            stack = err.getStackTrace();
            if (stack != null){
                toSend = (toSend + (", stack:" + stack));
            } else {
                toSend = (toSend + (", exc:" + err.toString()));
            };
            Ping.Send(toSend);
        }
        public static function ReportErrorContinue(what:String, sendPing:Boolean=true):Boolean{
            if (((!((TESTAPI::reportError == null))) && (TESTAPI::reportError(what, null)))){
                return (false);
            };
            if (sendPing){
                Ping.Send(("Error:" + what));
            } else {
                Trace.Error("ConvivaConventInfo", ("Error:" + what));
            };
            return (true);
        }
        public static function GetEpochMilliseconds():Number{
            return (getCurrentTimeMs());
        }
        public static function Assert(test, what:String):void{
            if (!(test)){
                ReportError(("Assertion failure: " + what));
            };
        }
        public static function GetTickCountMs():Number{
            return ((getTimer() + _tickCountOffsetMs));
        }
        public static function UrlDecodeQuery(q:String):DictionaryCS{
            var saveCodePage:Boolean = System.useCodePage;
            System.useCodePage = false;
            var uv:URLVariables = new URLVariables(q);
            System.useCodePage = saveCodePage;
            return (Lang.DictionaryFromRepr(uv));
        }
        public static function RunProtectedResult(f:Function, msg:String, defaultResult){
            var f:* = f;
            var msg:* = msg;
            var defaultResult:* = defaultResult;
            var initialBreadCrumbCount:* = _breadCrumbs.length;
            var result:* = defaultResult;
            try {
                try {
                    if (TESTAPI::_interceptUncaughtExceptions){
                        try {
                            result = f();
                        } catch(e) {
                            UncaughtException(((msg) ? msg : "RunProtected"), e);
                        };
                    } else {
                        result = f();
                    };
                } finally {
                };
            } finally {
                if (_breadCrumbs.length > initialBreadCrumbCount){
                    _breadCrumbs = _breadCrumbs.slice(0, initialBreadCrumbCount);
                };
            };
            return (result);
            /*not popped
            -1
            */
        }
        public static function UrlEncodeString(s:String):String{
            s = urlEncodeObject({x:s});
            return (s.substr(2));
        }
        public static function getCurrentTimeMs():Number{
            return (new Date().getTime());
        }

    }
}//package com.conviva.utils 
﻿package com.conviva.utils {
    import com.conviva.internal_access.*;

    public class Uuid {

        public static const UUID_PROPERTY_NAME:String = "uuid";

        private static var _uuid:ArrayCS = null;

        public function Uuid(){
            super();
            throw (new Error("Uuid is a static class"));
        }
        public static function Cleanup():void{
            _uuid = null;
        }
        TESTAPI static function deleteUuid():void{
            PersistentConfig.DeleteProperty(UUID_PROPERTY_NAME);
            _uuid = ArrayCS.New(0, 0, 0, 0);
        }
        TESTAPI static function isEqual(other:ArrayCS):Boolean{
            if (other.Length != _uuid.Length){
                return (false);
            };
            var i:int;
            while (i < _uuid.Length) {
                if (_uuid.GetValue(i) != other.GetValue(i)){
                    return (false);
                };
                i++;
            };
            return (true);
        }
        TESTAPI static function get uuidNoAssert():ArrayCS{
            return (_uuid);
        }
        public static function Init():void{
            var rawUuid:* = PersistentConfig.SafeGetPropElse(UUID_PROPERTY_NAME, null);
            try {
                _uuid = Lang.ArrayFromRepr((rawUuid as Array));
            } catch(e:Error) {
                _uuid = null;
            };
            if (((!((_uuid == null))) && (!((_uuid.Length == 4))))){
                _uuid = null;
            };
            if (_uuid == null){
                _uuid = ArrayCS.New(0, 0, 0, 0);
            };
        }
        TESTAPI static function X_isEqual_Repr(id:Array):Boolean{
            return (TESTAPI::isEqual(Lang.ArrayFromRepr(id)));
        }
        public static function get uuid():ArrayCS{
            Utils.Assert(!((_uuid == null)), "Uuid");
            return (_uuid);
        }
        public static function SetUuid(id:ArrayCS):void{
            Utils.Assert((id.Length == 4), "id must have 4 ints");
            _uuid = id;
            PersistentConfig.SetProperty(UUID_PROPERTY_NAME, Lang.ArrayToRepr(_uuid));
            Ping.Id = uint(_uuid.GetValue(0));
        }

    }
}//package com.conviva.utils 
﻿package com.conviva.utils {
    import flash.events.*;
    import com.conviva.network.*;

    public class Ping {

        private static const PING_MAX_IN_WINDOW:int = 3;
        private static const PING_MIN_INTERVAL_MS:int = 1000;
        private static const PING_MAX_OUTSTANDING:int = 10;
        private static const PING_WINDOW_SIZE_MS:int = 60000;
        public static const _PING_ID:String = "pingid";
        public static const PING:String = "pingPing";

        private static var _pingHistory:ListCS;
        private static var pingMaxInWindow:int = 3;
        private static var pingWindowSizeMs:int = 60000;
        private static var _extraFields:DictionaryCS;
        private static var _pingWaiter:Object;
        private static var _loader:DataLoader;
        private static var _dispatcher:PingEventDispatcher = null;
        private static var _pingId:uint = 0;
        private static var _whileSendingPing:Boolean = false;
        private static var _outstanding:ListCS;
        private static var _pingUrl:String = null;
        private static var pingMinIntervalMs:int = 1000;

        public function Ping(){
            super();
            Utils.ReportError("Ping: is an all-static class");
        }
        TESTAPI static function get MIN_PING_INTERVAL_MS():int{
            return (pingMinIntervalMs);
        }
        TESTAPI static function set MIN_PING_INTERVAL_MS(value:int):void{
            pingMinIntervalMs = value;
        }
        TESTAPI static function get MAX_IN_WINDOW():int{
            return (pingMaxInWindow);
        }
        private static function sendPing():void{
            var now:* = NaN;
            var msg:* = null;
            var toWait:* = 0;
            if ((((_outstanding == null)) || ((_pingHistory == null)))){
                return;
            };
            if (_outstanding.Count > 0){
                now = Utils.GetEpochMilliseconds();
                msg = _outstanding.GetValue(0);
                _outstanding.RemoveAt(0);
                _whileSendingPing = true;
                if (_loader){
                    _loader.Cleanup();
                };
                _loader = new DataLoader(((_pingUrl + "&") + msg), function (err:Error, dl:DataLoader){
                    if (err != null){
                        Trace.Error("Ping", ("Failed to send ping: " + err.toString()));
                    };
                }, null, null);
                _pingHistory.Add(now);
                toWait = 0;
                if (_pingHistory.Count >= pingMaxInWindow){
                    _pingHistory.RemoveRange(0, ((_pingHistory.Count - pingMaxInWindow) + 1));
                    toWait = int(((_pingHistory.GetValue(0) + pingWindowSizeMs) - now));
                };
                if (toWait <= pingMinIntervalMs){
                    toWait = pingMinIntervalMs;
                };
                _pingWaiter = ProtectedTimer.DelayAction(sendPing, toWait, "Ping.wait");
            } else {
                _pingWaiter = null;
            };
            _whileSendingPing = false;
        }
        public static function Cleanup():void{
            if (_pingWaiter != null){
                ProtectedTimer.CancelDelayedAction(_pingWaiter);
                _pingWaiter = null;
            };
            _pingUrl = null;
            _dispatcher = null;
            if (_loader){
                _loader.Cleanup();
                _loader = null;
            };
            _outstanding = null;
            _pingHistory = null;
        }
        TESTAPI static function set MAX_IN_WINDOW(value:int):void{
            pingMaxInWindow = value;
        }
        private static function queuePing(msg:String):void{
            var old:String;
            for each (old in _outstanding.Values) {
                if (old == msg){
                    return;
                };
            };
            if (_whileSendingPing){
                return;
            };
            if (_outstanding.Count < PING_MAX_OUTSTANDING){
                _outstanding.Add(msg);
            } else {
                return;
            };
            if (_pingWaiter == null){
                sendPing();
            };
        }
        public static function Send(msg:String):void{
            var defaultPingUrl:String;
            var pageBaseUrl:String;
            var ev:Event;
            if (_pingUrl == null){
                defaultPingUrl = "http://livepassdl.conviva.com";
                pageBaseUrl = "";
                if (Lang.StringContains(pageBaseUrl, "locahost:8888")){
                    defaultPingUrl = pageBaseUrl;
                };
                Init(defaultPingUrl, 0, null);
            };
            Trace.Error("Ping", msg);
            msg = ("d=" + Utils.UrlEncodeString(msg));
            queuePing(msg);
            if (_dispatcher){
                ev = new Event(PING);
                _dispatcher.data = msg;
                _dispatcher.dispatchEvent(ev);
            };
        }
        public static function Init(pingUrl:String, pingId:uint, extraFields:DictionaryCS):void{
            var pid:* = null;
            var pidstr:* = null;
            var extraKey:* = null;
            var pingUrl:* = pingUrl;
            var pingId:* = pingId;
            var extraFields:* = extraFields;
            _pingId = pingId;
            _pingUrl = pingUrl;
            _extraFields = extraFields;
            _whileSendingPing = false;
            _outstanding = new ListCS();
            _pingHistory = new ListCS();
            _dispatcher = null;
            _pingWaiter = null;
            var qidx:* = Lang.StringIndexOf(_pingUrl, "?");
            if (qidx < 0){
                _pingUrl = (_pingUrl + "/ping.ping?");
            } else {
                _pingUrl = (((Lang.StringSubstring(_pingUrl, 0, qidx) + "/ping.ping?") + Lang.StringSubstring(_pingUrl, (qidx + 1))) + "&");
            };
            if (_pingId == 0){
                try {
                    pid = PersistentConfig.SafeGetPropElse(_PING_ID, _pingId);
                    pidstr = (pid as String);
                    _pingId = uint(pidstr);
                } catch(e:Error) {
                };
            };
            if (_pingId == 0){
                _pingId = Utils.NextRandom32();
                if (_pingId == 0){
                    _pingId++;
                };
            };
            PersistentConfig.SetProperty(_PING_ID, _pingId.toString());
            _pingUrl = (_pingUrl + ("uuid=" + _pingId.toString()));
            _pingUrl = (_pingUrl + ("&ver=" + LivePassVersion.versionStr));
            if (_extraFields != null){
                for each (extraKey in _extraFields.Keys) {
                    _pingUrl = (_pingUrl + ((("&" + Utils.UrlEncodeString(extraKey)) + "=") + Utils.UrlEncodeString(_extraFields.GetValue(extraKey))));
                };
            };
        }
        TESTAPI static function set WINDOW_SIZE_MS(value:int):void{
            pingWindowSizeMs = value;
        }
        public static function get Id():uint{
            return (_pingId);
        }
        TESTAPI static function get outstandingPings():ListCS{
            return (_outstanding);
        }
        public static function removeEventListener(eventListener:Function):void{
            if (!(_dispatcher)){
                Ping.Send("Error:Ping.removeEventListener");
            } else {
                _dispatcher.removeEventListener(PING, eventListener);
            };
        }
        public static function addEventListener(eventListener:Function):void{
            if (!(_dispatcher)){
                _dispatcher = new PingEventDispatcher();
            };
            _dispatcher.addEventListener(PING, eventListener);
        }
        TESTAPI static function get WINDOW_SIZE_MS():int{
            return (pingWindowSizeMs);
        }
        public static function set Id(value:uint):void{
            var value:* = value;
            _pingId = value;
            try {
                PersistentConfig.SetProperty(_PING_ID, value.toString());
            } catch(e:Error) {
            };
        }

    }
}//package com.conviva.utils 

import flash.events.*;

class PingEventDispatcher extends EventDispatcher {

    public var data:Object;

    public function PingEventDispatcher(){
        super();
    }
}
﻿package com.conviva.utils {

    public class ListCS {

        private var _array:Array;

        public function ListCS(){
            super();
            _array = new Array();
        }
        public static function New(... _args):ListCS{
            var res:ListCS = new (ListCS)();
            res._array = res._array.concat(_args);
            return (res);
        }
        public static function FromRepr(a:Array):ListCS{
            if (a == null){
                return (null);
            };
            var res:ListCS = new (ListCS)();
            res._array = a;
            return (res);
        }

        public function RemoveRange(where:int, count:int):void{
            _array.splice(where, count);
        }
        public function Add(what):void{
            _array.push(what);
        }
        public function get Values():Array{
            return (_array);
        }
        public function Remove(what):Boolean{
            var idx:int = _array.indexOf(what);
            if (idx < 0){
                return (false);
            };
            RemoveAt(idx);
            return (true);
        }
        public function ToArray():ArrayCS{
            return (ArrayCS.FromRepr(_array));
        }
        public function IndexOf(e, startIndex:int=0):int{
            return (_array.indexOf(e, startIndex));
        }
        public function Clear():void{
            _array.length = 0;
        }
        public function get Count():int{
            return (_array.length);
        }
        public function ToRepr():Array{
            return (_array);
        }
        public function SetValue(index:int, v):void{
            _array[index] = v;
        }
        public function RemoveAt(where:int):void{
            RemoveRange(where, 1);
        }
        public function Insert(where:int, what):void{
            _array.splice(where, 0, what);
        }
        public function GetValue(index:int){
            return (_array[index]);
        }
        public function Sort(... _args):void{
            _array.sort.apply(this, _args);
        }
        public function Contains(what):Boolean{
            return ((_array.indexOf(what) >= 0));
        }

    }
}//package com.conviva.utils 
﻿package com.conviva.utils {

    public class CommonUtils {

        public function CommonUtils(){
            super();
        }
        public static function formatUint(i:uint, minLength:uint, padding:String="0"):String{
            var retval:String = i.toString();
            if ((((padding == null)) || ((padding == "")))){
                padding = "0";
            };
            while (retval.length < minLength) {
                retval = (padding + retval);
            };
            return (retval);
        }
        public static function random():Number{
            var r1:uint = uint((Math.random() * Number(0x80000000)));
            var r2:uint = uint((Math.random() * Number(0x80000000)));
            return ((Number(uint((r1 + (2 * r2)))) / Number(4294967296)));
        }
        public static function formatTime(d:Date):String{
            var retval:String = "";
            retval = (retval + (formatUint(d.hours, 2) + ":"));
            retval = (retval + (formatUint(d.minutes, 2) + ":"));
            retval = (retval + (formatUint(d.seconds, 2) + "."));
            retval = (retval + formatUint(d.milliseconds, 3));
            return (retval);
        }

    }
}//package com.conviva.utils 
﻿package com.conviva.utils {
    import com.conviva.network.*;
    import com.conviva.internal_access.*;
    import flash.events.*;

    public class LivePassConfigLoader {

        private static const BASENAME_XML:String = "livePassConfig.xml";

        private static var _attributeOverrides:DictionaryCS = null;
        private static var _basenameXml:String = "livePassConfig.xml";
        TESTAPI static var FakeUpdate:Boolean = false;

        private var _fullConfigDoc:XML;
        private var _configLoader:DataLoader;
        private var _altName:String;
        private var _configDoc:XML;
        private var _serviceUrl:String;
        private var _configUpdated:Eventer;
        private var _customerName:String;
        private var _ccsWallTimeMs:Number;
        private var _failureHandler:Function;

        public function LivePassConfigLoader(serviceUrl:String, customerName:String, updateHandler:Function, failureHandler:Function, currentConfigXml:String){
            super();
            _serviceUrl = serviceUrl;
            _customerName = customerName;
            _failureHandler = failureHandler;
            _configUpdated = new Eventer();
            if (updateHandler != null){
                _configUpdated.AddHandler(updateHandler);
            };
            _fullConfigDoc = null;
            _configDoc = null;
            _altName = null;
            if (currentConfigXml != null){
            } else {
                StartLoadConfig();
            };
        }
        TESTAPI static function AddOverride(elementName:String, value:String):void{
            if (_attributeOverrides == null){
                _attributeOverrides = new DictionaryCS();
            };
            _attributeOverrides.SetValue(elementName, value);
        }
        public static function CreateOneTimeLoader(serviceUrl:String, customerName:String, updateHandler:Function, failureHandler:Function):LivePassConfigLoader{
            return (new LivePassConfigLoader(serviceUrl, customerName, updateHandler, failureHandler, null));
        }
        TESTAPI static function set BasenameXML(value:String):void{
            _basenameXml = value;
        }
        TESTAPI static function ClearOverrides():void{
            _attributeOverrides = null;
        }
        public static function StaticCleanup():void{
            _attributeOverrides = null;
            _basenameXml = BASENAME_XML;
        }

        public function Cleanup():void{
            if (_configLoader != null){
                _configLoader.Cleanup();
                _configLoader = null;
            };
            if (_configUpdated != null){
                _configUpdated.Cleanup();
                _configUpdated = null;
            };
            _configDoc = null;
            _fullConfigDoc = null;
            _serviceUrl = null;
        }
        public function GatherStats(where:DictionaryCS):void{
            var cUrl:String = ConfigUrl();
            if (Lang.StringIndexOf(cUrl, "?") >= 0){
                cUrl = Lang.StringSubstring(cUrl, 0, Lang.StringIndexOf(cUrl, "?"));
            };
            where.SetValue("LivePass.configUrl", cUrl);
            where.SetValue("LivePass.uuid", Ping.Id.toString());
        }
        public function AllModuleUrls():ListCS{
            var elementName:String;
            var mp:XML;
            elementName = "modulePath";
            var res:ListCS = new ListCS();
            var modulePaths:XMLList = _configDoc..*[elementName];
            Utils.Assert(modulePaths, "LivePassInit.modulePaths");
            for each (mp in modulePaths) {
                res.Add(mp.toString());
            };
            return (res);
        }
        public function get CurrentConfigXml():XML{
            return (_configDoc);
        }
        private function FilterAlternatives(name:String):void{
            var child:XML;
            if (_fullConfigDoc == null){
                return;
            };
            var countRemainingAlts:int;
            var foundOtherAlternatives:String = "";
            var replacementXML:XML = _fullConfigDoc.copy();
            Utils.PushBreadCrumb("FA:0");
            replacementXML.setChildren(new XMLList());
            Utils.PushBreadCrumb("FA:1");
            for each (child in _fullConfigDoc.children()) {
                if (child.name() != "alternative"){
                    replacementXML.appendChild(child);
                } else {
                    if ((((child.@name == null)) || ((child.@name.length() == 0)))){
                    } else {
                        if (child.@name.toString() == _altName){
                            replacementXML.appendChild(child);
                        } else {
                            foundOtherAlternatives = (foundOtherAlternatives + (child.@name.toString() + ","));
                        };
                    };
                };
            };
            Utils.PushBreadCrumb("FA:10");
            countRemainingAlts = replacementXML..alternative.length();
            _configDoc = replacementXML;
            Utils.PushBreadCrumb("FA:11");
            Utils.Assert((1 == countRemainingAlts), ((((((("LivePassConfigLoader.processConfigXML: found " + countRemainingAlts) + " alternatives. alt=") + _altName) + " customer=") + _customerName) + " got= ") + foundOtherAlternatives));
        }
        public function get CcsWallTimeMs():Number{
            return (_ccsWallTimeMs);
        }
        protected function LoadConfigGeneral(success:Function, fail:Function):void{
            var success:* = success;
            var fail:* = fail;
            var url:* = ConfigUrl();
            Trace.Info("LivePassConfigLoader", ("loading " + url));
            _configLoader = new DataLoader(url, function (err:Error, dl:DataLoader){
                var newConfigDoc:* = undefined;
                var err:* = err;
                var dl:* = dl;
                if (err == null){
                    newConfigDoc = dl.Response.ToXml();
                    if (newConfigDoc != null){
                        _fullConfigDoc = newConfigDoc;
                        Utils.RunProtected(success, "LPConfigLoader.LoadConfigGeneral.1");
                    };
                } else {
                    Utils.RunProtected(function (){
                        if (fail != null){
                            fail(err);
                        };
                    }, "LPConfigLoader.LoadConfigGeneral.2");
                };
            }, null, null);
        }
        private function HandleNewConfig():void{
            if (_fullConfigDoc == null){
                return;
            };
            if (_altName == null){
                _altName = ChooseAlternative();
            };
            FilterAlternatives(_altName);
            if (_configUpdated != null){
                _configUpdated.DispatchEvent();
            };
        }
        private function ConfigUrl():String{
            var attrs:DictionaryCS = new DictionaryCS();
            attrs.SetValue("c3.customerName", _customerName);
            attrs.SetValue("c3.platform", "FL");
            var inModule:Boolean;
            if (inModule){
                attrs.SetValue("c3.dver", LivePassVersion.versionStr);
            } else {
                attrs.SetValue("c3.sver", LivePassVersion.versionStr);
            };
            if (_altName != null){
                attrs.SetValue("c3.alt", _altName);
            };
            return (((((((_serviceUrl + "/lpconfig/cfg/") + Utils.UrlEncodeQuery(attrs)) + "?random=") + Utils.NextRandom32()) + "&uuid=") + Ping.Id.toString()));
        }
        private function ChooseAlternative():String{
            var aa:* = null;
            var child:* = null;
            var totalAffinity:* = NaN;
            var alt:* = null;
            var randFraction:* = NaN;
            var alt1:* = null;
            var affinities:* = new ListCS();
            for each (child in _fullConfigDoc.children()) {
                aa = new AltAffinity();
                if (child.name() != "alternative"){
                } else {
                    try {
                        aa.Affinity = uint(child.@affinity);
                        aa.Name = String(child.@name);
                    } catch(e) {
                        Ping.Send(("LivePassConfigLoader.processConfigXML: cannot parse alternative name " + e));
                    };
                    if (aa.Affinity > 0){
                        affinities.Add(aa);
                    };
                };
            };
            totalAffinity = 0;
            for each (alt in affinities.Values) {
                totalAffinity = (totalAffinity + alt.Affinity);
            };
            randFraction = (Utils.NextRandom() * totalAffinity);
            for each (alt1 in affinities.Values) {
                randFraction = (randFraction - alt1.Affinity);
                if (randFraction <= 0){
                    return (alt1.Name);
                };
            };
            return (null);
        }
        public function get AlternativeName():String{
            return (_altName);
        }
        private function StartLoadConfig():void{
            LoadConfigGeneral(HandleNewConfig, _failureHandler);
        }
        public function get CurrentConfig():String{
            return (Lang.XmlToString(_configDoc));
        }

    }
}//package com.conviva.utils 

class AltAffinity {

    public var Affinity:int;
    public var Name:String;

    public function AltAffinity(){
        super();
    }
}
﻿package com.conviva.utils {
    import flash.events.*;
    import flash.utils.*;
    import com.conviva.internal_access.*;

    public class Reflection {

        public function Reflection(){
            super();
        }
        public static function StoreCloningData(input:DictionaryCS, output:Object):void{
            input.CopyToObject(output);
        }
        public static function GetField(propName:String, obj:Object):Object{
            return (GetProperty(propName, obj));
        }
        public static function InvokeStaticMethod(methodName:String, obj:Class, ... _args):Object{
            return (InvokeMethodWorker(obj, methodName, _args));
        }
        public static function GetProperty(propName:String, obj:Object):Object{
            var retval:Object = getField(obj, propName);
            return (retval);
        }
        public static function GetClassName(obj:Object):String{
            if (obj == null){
                return (null);
            };
            return (getQualifiedClassName(obj));
        }
        public static function HasProperty(propName:String, obj:Object):Boolean{
            var propName:* = propName;
            var obj:* = obj;
            return (!((getField(obj, propName) == null)));
            var _slot1:* = e;
            if (_slot1.errorID == 1069){
                return (false);
            };
            throw (_slot1);
        }
        public static function GetType(obj:Object):Class{
            if (obj == null){
                return (null);
            };
            var cls:Class = (getDefinitionByName(GetClassName(obj)) as Class);
            return (cls);
        }
        public static function CreateInstance(cls:Class, ... _args):Object{
            if (_args.length == 0){
                return (new (cls)());
            };
            if (_args.length == 1){
                return (new cls(_args[0]));
            };
            if (_args.length == 2){
                return (new cls(_args[0], _args[1]));
            };
            if (_args.length == 3){
                return (new cls(_args[0], _args[1], _args[2]));
            };
            if (_args.length == 4){
                return (new cls(_args[0], _args[1], _args[2], _args[3]));
            };
            if (_args.length == 5){
                return (new cls(_args[0], _args[1], _args[2], _args[3], _args[4]));
            };
            Ping.Send(("Error:CreateInstance too many args: " + (cls as Object).toString()));
            return (null);
        }
        public static function GetTypeByName(className:String):Class{
            return ((getDefinitionByName(className) as Class));
        }
        private static function getField(obj:Object, fname:String):Object{
            var retval:Object;
            var fnameStripped:String = stripTESTAPI(fname);
            if (fname != fnameStripped){
                return (objTESTAPI::[fnameStripped]);
            };
            retval = obj[fname];
            return (retval);
        }
        public static function SetProperty(propName:String, obj:Object, val:Object):void{
            var propNameStripped:String = stripTESTAPI(propName);
            if (propName != propNameStripped){
                objTESTAPI::[propNameStripped] = val;
            } else {
                obj[propName] = val;
            };
        }
        public static function SetField(propName:String, obj:Object, val:Object):void{
            SetProperty(propName, obj, val);
        }
        public static function InvokeMethod(methodName:String, obj:Object, ... _args):Object{
            return (InvokeMethodWorker(obj, methodName, _args));
        }
        public static function HasMethod(methodName:String, obj:Object):Boolean{
            return (HasProperty(methodName, obj));
        }
        public static function Clone(toClone:Object):Object{
            var res:Object = {};
            var className:String = GetClassName(toClone);
            InvokeMethod("StoreCloningData", toClone, res);
            var cloneType:Class = (getDefinitionByName(className) as Class);
            if (cloneType == null){
                return (null);
            };
            return (InvokeStaticMethod("ConstructFromCloningData", cloneType, res));
        }
        private static function InvokeMethodWorker(obj:Object, methodName:String, args:Array):Object{
            var fld:* = null;
            var e2:* = null;
            var e1:* = null;
            var strace:* = null;
            var objInfo:* = null;
            var methodInfo:* = null;
            var nrFormalParams:* = 0;
            var nrActualParams:* = 0;
            var newArgs:* = null;
            var i:* = 0;
            var obj:* = obj;
            var methodName:* = methodName;
            var args:* = args;
            fld = getField(obj, methodName);
            if ((((fld == null)) || ((!(fld) is Function)))){
                e2 = new Error(("Missing property " + methodName), 1069);
                Utils.UncaughtException(("InvokeMethod: " + methodName), e2);
                return (null);
            };
            return (fld.apply(obj, args));
            var _slot1:* = e;
            e1 = _slot1;
            strace = e1.getStackTrace();
            if (_slot1.errorID == 1069){
                Utils.UncaughtException(("InvokeMethod: " + methodName), _slot1);
                return (null);
            };
            if (_slot1.errorID == 1063){
                objInfo = describeType(obj);
                methodInfo = objInfo.method.(@name == methodName);
                if (methodInfo.length() == 1){
                    nrFormalParams = methodInfo..parameter.length();
                    nrActualParams = args.length;
                    if (nrFormalParams != nrActualParams){
                        newArgs = [];
                        i = 0;
                        while (i < nrFormalParams) {
                            if (i >= nrActualParams){
                                newArgs.push(null);
                            } else {
                                newArgs.push(args[i]);
                            };
                            i = (i + 1);
                        };
                        return (InvokeMethodWorker(obj, methodName, newArgs));
                    };
                };
            };
            Utils.UncaughtException(("InvokeMethod:" + methodName), _slot1);
            return (null);
        }
        private static function stripTESTAPI(fname:String):String{
            if ((((fname.length > 8)) && ((fname.substr(0, 8) == "TESTAPI_")))){
                return (fname.substr(8));
            };
            return (fname);
        }

    }
}//package com.conviva.utils 
﻿package com.conviva.utils {

    public class LivePassVersion {

        public static const VERSION_RELEASE:int = 0;
        public static const VERSION_MAJOR:int = 2;
        public static const VERSION_SVN:int = 40461;
        public static const VERSION_MINOR:int = 23;

        public function LivePassVersion(){
            super();
            Utils.ReportError("LivePassVersion: is an all-static class");
        }
        public static function get versionStr():String{
            return (((version3Str + ".") + VERSION_SVN));
        }
        public static function get version3Str():String{
            return (((((VERSION_MAJOR + ".") + VERSION_MINOR) + ".") + VERSION_RELEASE));
        }

    }
}//package com.conviva.utils 
﻿package com.conviva.utils {
    import flash.net.*;
    import flash.events.*;

    public class PersistentConfig {

        private static var _flushOK:Boolean = true;
        private static var _shObj:SharedObject = null;
        private static var _data:Object = null;

        public function PersistentConfig(){
            super();
            Utils.ReportError("PersistentConfig is an all-static class");
        }
        public static function DeleteProperty(vname:String):Boolean{
            var hadIt:Boolean = _data.hasOwnProperty(vname);
            delete _data[vname];
            safeFlush();
            return (hadIt);
        }
        public static function SafeGetPropElse(key:String, deflt:Object):Object{
            if (_data.hasOwnProperty(key)){
                return (_data[key]);
            };
            return (deflt);
        }
        public static function get FlushOK():Boolean{
            return (_flushOK);
        }
        public static function get size():uint{
            if (_shObj != null){
                return (_shObj.size);
            };
            return (0);
        }
        public static function GetProperty(vname:String):Object{
            return (_data[vname]);
        }
        public static function HasProperty(vname:String):Boolean{
            return (_data.hasOwnProperty(vname));
        }
        public static function SetProperty(vname:String, val:Object):void{
            _data[vname] = val;
            safeFlush();
        }
        protected static function safeFlush():Boolean{
            if (_shObj == null){
                return (true);
            };
            var res:* = null;
            try {
                res = _shObj.flush();
                _flushOK = (res == SharedObjectFlushStatus.FLUSHED);
            } catch(e:Error) {
                _flushOK = false;
            };
            return (_flushOK);
        }

        try {
            _shObj = SharedObject.getLocal("com.conviva.livePass", "/");
            _shObj.addEventListener(NetStatusEvent.NET_STATUS, function (event:NetStatusEvent):void{
                switch (event.info.code){
                    case "SharedObject.Flush.Success":
                        _flushOK = true;
                        break;
                    case "SharedObject.Flush.Failed":
                        _flushOK = false;
                        break;
                };
            });
            _data = _shObj.data;
        } catch(e:Error) {
            _shObj = null;
            _data = {};
            _flushOK = false;
        };
    }
}//package com.conviva.utils 
﻿package com.conviva.utils {

    public class ConvivaStatus extends Error {

        public static const SUCCESS:int = 0;
        public static const REFUSED_BY_POLICY:int = 4;
        public static const FAULT_COMMUNICATION_BETWEEN_CLIENT_GATEWAY:int = 32;
        public static const WARNING_NO_MATCHING_SEQUENCING_POLICY:int = 2;
        public static const REFUSED_RESOURCES_NOT_AVAILABLE:int = 5;
        public static const WARNING_UNKNOWN_RESOURCE:int = 1;
        public static const WARNING_MBR_POLICY_CONFIGURATION_ERROR:int = 4;
        public static const FAULT_COMMUNICATION_BETWEEN_GATEWAY_RCC:int = -2;
        public static const WARNING_OBSOLETE_SELECT_RESOURCE:int = 8;
        public static const WARNING_OK:int = 0;

        public function ConvivaStatus(message:String){
            super(message);
        }
    }
}//package com.conviva.utils 
﻿package com.conviva {
    import com.conviva.*;
    import com.conviva.utils.*;

    class MetricsProxy implements ICustomMetrics {

        private var _apiId:int;

        public function MetricsProxy(apiId:int){
            super();
            _apiId = apiId;
        }
        public function sendEvent2(name:String, states:Object, attributes:Object, measurements:Object):void{
            var name:* = name;
            var states:* = states;
            var attributes:* = attributes;
            var measurements:* = measurements;
            Utils.RunProtected(function (){
                LivePassInit.InvokeWhenReady("metricsSendEvent2", function (){
                    var module:Object = LivePassInit.Module;
                    Reflection.InvokeMethod("metricsSendEvent2", module, _apiId, name, states, attributes, measurements);
                });
            }, "MetricsProxy.sendEvent2");
        }
        public function numPending():int{
            var module:* = null;
            var res:* = null;
            module = LivePassInit.Module;
            Utils.Assert(!((module == null)), "NumPending and LivePass not ready");
            res = Reflection.InvokeMethod("metricsNumPending", module, _apiId);
            return (int(res));
            var _slot1:* = e;
            Utils.UncaughtException("NumPending", _slot1);
            return (0);
        }
        public function sendMeasurement(name:String, filterAttrs:Object, value:Number):void{
            var name:* = name;
            var filterAttrs:* = filterAttrs;
            var value:* = value;
            Utils.RunProtected(function (){
                LivePassInit.InvokeWhenReady("sendMeasurement", function (){
                    var module:Object = LivePassInit.Module;
                    Reflection.InvokeMethod("metricsSendMeasurement", module, _apiId, name, filterAttrs, value);
                });
            }, "MetricsProxy.sendMeasurement");
        }
        public function sendEvent(name:String, filterAttrs:Object):void{
            var name:* = name;
            var filterAttrs:* = filterAttrs;
            Utils.RunProtected(function (){
                LivePassInit.InvokeWhenReady("metricsSendEvent", function (){
                    var module:Object = LivePassInit.Module;
                    Reflection.InvokeMethod("metricsSendEvent", module, _apiId, name, filterAttrs);
                });
            }, "MetricsProxy.sendEvent");
        }
        public function setState(changes:Object):void{
            var changes:* = changes;
            Utils.RunProtected(function (){
                var module:Object = LivePassInit.Module;
                Utils.Assert(!((module == null)), "SetState and LivePass not ready");
                Reflection.InvokeMethod("metricsSetState", module, _apiId, changes);
            }, "MetricsProxy.setState");
        }

    }
}//package com.conviva 
﻿package com.conviva {
    import com.conviva.utils.*;

    public class ConvivaNotification {

        public static const ERROR_LIVEPASS_NOT_READY:int = 2;
        public static const ERROR_METRICS_QUOTA_EXCEEDED:int = 30;
        public static const ERROR_LOAD_MODULE:int = 11;
        public static const ERROR_ARGUMENT:int = 1;
        public static const ERROR_LOAD_CONFIGURATION:int = 10;
        public static const SUCCESS_LIVEPASS_READY:int = 0;

        private var _data:DictionaryCS;

        public function ConvivaNotification(code:int, message:String, objectId:String){
            super();
            _data = new DictionaryCS();
            _data.SetValue("code", code);
            _data.SetValue("message", message);
            _data.SetValue("objectId", objectId);
        }
        public static function ConstructFromCloningData(dictObj:Object):ConvivaNotification{
            var dict:DictionaryCS = Lang.DictionaryFromRepr(dictObj);
            var res:ConvivaNotification = new ConvivaNotification(0, "", "");
            res._data = Lang.DictionaryFromRepr(dict.GetValue("data"));
            return (res);
        }

        public function get message():String{
            return ((_data.GetValue("message") as String));
        }
        public function get objectId():String{
            return ((_data.GetValue("objectId") as String));
        }
        public function StoreCloningData(dictObj:Object):void{
            var dict:DictionaryCS = new DictionaryCS();
            dict.SetValue("data", _data.ToObject());
            Reflection.StoreCloningData(dict, dictObj);
        }
        public function toString():String{
            var res:String = ((("ConvivaNotification (" + code.toString()) + "): ") + message);
            if (objectId != null){
                res = (res + ((" (for objectId " + objectId) + ")"));
            };
            return (res);
        }
        public function get code():int{
            return (int(_data.GetValue("code")));
        }

    }
}//package com.conviva 
﻿package com.gomez {
    import flash.external.*;
    import com.ibm.AS3util.*;
    import flash.utils.*;
    import flash.system.*;
    import flash.net.*;
    import flash.xml.*;
    import flash.events.*;

    public class GZMon {

        private static var customerEvent_array:Array = new Array();
        private static var flvbasic:Object = new Object();
        private static var startime:Date;
        private static var hasTag:Boolean = false;
        private static var gomezCanSend:Boolean = false;
        private static var oCommonInfo:Object = new Object();
        private static var oConfig:Object = new Object();
        private static var getconfigurl:String = "";
        private static var crossdomainurl:String = "";
        private static var posturl:String = "";
        private static var iNsIndex:Number = 0;
        private static var singletonGZMon:GZMon;
        private static var rand:Number = Math.random();
        private static var getContinue:Boolean = true;
        private static var sampleRate:Number = 1;
        private static var gomezrunFlg:String;

        private var event_array:Array;
        private var ns_array:Array;
        private var mc_array:Array;
        private var seqnum:Number = 0;
        private var mc_num:Number = 0;
        private var strVisitorId:String = "";
        private var strSessionId:String = "";
        private var numSampleRate:Number = 0;
        private var strPageId:String = "";
        private var strGroupId:String = "";
        private var intervalId:Number;
        private var varId:Number;
        private var flvseq:Number = 0;
        private var nsflvseq:Number = 0;
        private var pauseflag:Boolean = true;
        private var gomezversion:String = "1.1";
        private var accoutid:String = "";
        private var identifier:String = "";
        private var nopost:Boolean = false;
        private var nounload:Boolean = false;
        private var customerNum:Number = 5;
        private var alreadySend:Boolean = false;
        private var startflag:Boolean = false;
        private var lastEvent:Object;
        private var getrumtagsamplerate:String = "";
        private var getRumSampleRateid:uint;
        private var errorobject:uint;
        private var senderrorflag:Boolean = false;
        private var error_array:Array;
        private var connectURL:String = "";
        private var sendbyself:Boolean = false;
        private var replayflag:Boolean = false;
        public var dynamicObject:Object;
        private var setnetStream:Boolean = false;
        private var customerObjcet:uint;
        private var gomezid:String;
        private var gomezmovie:String;
        private var gomezconect:String;
        private var gomezverboseneed:String;
        private var gomez_cansend:String;

        public function GZMon(){
            this.event_array = new Array();
            this.ns_array = new Array();
            this.mc_array = new Array();
            this.lastEvent = new Object();
            this.error_array = new Array();
            this.dynamicObject = new Object();
            super();
            if (!(getContinue)){
                return;
            };
        }
        public static function getSingleton():GZMon{
            if (!(singletonGZMon)){
                startime = new Date();
                singletonGZMon = new (GZMon)();
            };
            return (singletonGZMon);
        }
        private static function makeCommonObject():void{
            var o:Object;
            var h:*;
            try {
                if (hasTag){
                    o = ExternalInterface.call("gomez.getCommonInfo");
                    oCommonInfo.d = o.a;
                    oCommonInfo.e = o.b;
                    oCommonInfo.f = o.d;
                    oCommonInfo.h = o.e;
                    oCommonInfo.g = o.c;
                    oCommonInfo.o = o.i;
                    oCommonInfo.j = o.f;
                    Debug.getInstance().traceDebug(("GZMon.makeCommonObject: " + oCommonInfo.j));
                    oCommonInfo.m = o.h;
                    if (ExternalInterface.available){
                        h = ExternalInterface.call("eval", "location.href");
                        if (h != null){
                            oCommonInfo.l = replaceurl(pageurl(h.toString()));
                        };
                    };
                    flvbasic.l = "netstream";
                };
            } catch(e:Error) {
            };
        }
        private static function replaceurl(r:String):String{
            var g:Number;
            var l:Number;
            var b:Number;
            var c:Number;
            var d:Number;
            var t:String;
            var u:String = r;
            var i:Number = 0;
            while (i < 500) {
                i++;
                g = 0;
                g = u.indexOf("|");
                l = 0;
                l = u.indexOf(":");
                b = 0;
                b = u.indexOf("&");
                c = 0;
                c = u.indexOf("{");
                d = 0;
                d = u.indexOf("}");
                if (g > 0){
                    t = u.substr(0, g).concat("#$#");
                    t = t.concat(u.substr((g + 1), (u.length - g)));
                    u = t;
                } else {
                    if (l > 0){
                        t = u.substr(0, l).concat("$*$");
                        t = t.concat(u.substr((l + 1), (u.length - l)));
                        u = t;
                    } else {
                        if (b > 0){
                            t = u.substr(0, b).concat("!*!");
                            t = t.concat(u.substr((b + 1), (u.length - b)));
                            u = t;
                        } else {
                            if (c > 0){
                                t = u.substr(0, c).concat("@#@");
                                t = t.concat(u.substr((c + 1), (u.length - c)));
                                u = t;
                            } else {
                                if (d > 0){
                                    t = u.substr(0, d).concat("*@*");
                                    t = t.concat(u.substr((d + 1), (u.length - d)));
                                    u = t;
                                } else {
                                    break;
                                };
                            };
                        };
                    };
                };
            };
            return (u);
        }
        private static function pageurl(l:String):String{
            var u:String = l;
            var i:Number = 0;
            if (u.indexOf("?") > -1){
                u = u.substr(0, u.indexOf("?"));
            };
            if (u.indexOf("#") > -1){
                u = u.substr(0, u.indexOf("#"));
            };
            if (u.indexOf(";") > -1){
                u = u.substr(0, u.indexOf(";"));
            };
            return (u);
        }
        private static function getContinueFlag():void{
            var o:String;
            if (ExternalInterface.available){
                ExternalInterface.call("eval", "try{var oAr=document.getElementsByTagName('object'); if(oAr.length==0) oAr=document.getElementsByTagName('embed'); var l=oAr.length;for(var i=0;i<l;i++){var oId=oAr[i].id;if(!oId) oId=oAr[i].name;var oTransform;if(window.document[oId]){oTransform=window.document[oId];}else if(navigator.appName.indexOf('Microsoft Internet')==-1){oTransform=oAr[i];}else{oTransform=document.getElementById(oId);};oTransform.setGomezVar('gomezrunFlg',gomez.runFlg);};}catch(e){};");
                o = gomezrunFlg;
                if ((((((o == "")) || ((o == null)))) || ((o == "undefined")))){
                    if (Math.random() > sampleRate){
                        getContinue = false;
                    };
                } else {
                    if (o.toLowerCase() == "false"){
                        getContinue = false;
                    };
                };
            };
        }
        public static function create(o:Object, m:Function):Function{
            var p:* = null;
            var o:* = o;
            var m:* = m;
            var arguments:* = arguments;
            p = arguments.splice(2, (arguments.length - 2));
            var f:* = function ():void{
                m.apply(o, arguments.concat(p));
            };
            return (f);
        }

        public function AddNetStream(gns:gomezNetStream):void{
            iNsIndex++;
            gns.gomezid = iNsIndex;
            gns.gomezfirstseek = true;
            this.mc_array.push(gns);
            this.createObjectProxy(gns, gns.gomezid);
            this.nsEvent(gns, gns.gomezid);
        }
        public function EventNotify(n:gomezNetStream, s:String, o:Object):void{
            var e:Object;
            if (this.replayflag){
                this.replayflag = false;
                e = new Object();
                e.code = "gomezStart";
                this.onPlayStatus(e, n.gomezid, n);
            };
        }
        private function nsEvent(n:gomezNetStream, i:Number):void{
            n.addEventListener(GomezEvents.gomezNetStreamEvents, this.netStatusHandler);
        }
        private function BeginNSSample(n:gomezNetStream, i:Number):void{
            var o:Object = this.getObject(this.ns_array, i);
            if (o == null){
                return;
            };
            if (o.frame_interval != null){
                clearInterval(o.frame_interval);
            };
            o.frame_interval = setInterval(this.total, 1000, n, i);
        }
        private function total(n:gomezNetStream, i:Number):void{
            var o:Object = this.getObject(this.ns_array, i);
            if (o == null){
                return;
            };
            if (n.netStream.bytesLoaded == n.netStream.bytesTotal){
                clearInterval(o.frame_interval);
            } else {
                o.progresscount++;
            };
        }
        private function onNsPlay(e:Object, i:Number, n:gomezNetStream):void{
            this.EventNotify(n, "play", String(e));
        }
        private function netStatusHandler(event:GomezEvents):void{
            this.onPlayStatus(event.data.nsevent.info, event.data.gomezid, (event.data as gomezNetStream));
        }
        private function onNsClose(i:Number, n:gomezNetStream):void{
            this.EventNotify(n, "close", "");
            var o:Object = this.getObject(this.ns_array, i);
            if (o == null){
                return;
            };
            o.stopflag = true;
            this.getcurrenttime(o, n);
            if (flvbasic.h == "MSIE"){
                this.getData(n, i, "Stop", o, false);
            } else {
                this.getData(n, i, "Stop", o, false);
            };
        }
        private function onNsPause(e:Object, i:Number, n:gomezNetStream):void{
            this.EventNotify(n, "pause", String(e));
            var o:Object = this.getObject(this.ns_array, i);
            if (o == null){
                return;
            };
            this.getcurrenttime(o, n);
            if (String(e) == "false"){
                if (!(this.pauseflag)){
                    this.flashEvent("pausePlaying", o.flvindex);
                    this.netStreamPlaying(o);
                    this.pauseflag = true;
                };
            } else {
                if (String(e) == "true"){
                    this.flashEvent("paused", o.flvindex);
                    this.pauseflag = false;
                } else {
                    if (this.pauseflag){
                        this.flashEvent("paused", o.flvindex);
                        this.pauseflag = false;
                    } else {
                        this.flashEvent("pausePlaying", o.flvindex);
                        this.netStreamPlaying(o);
                        this.pauseflag = true;
                    };
                };
            };
        }
        private function netStreamPlaying(o:Object):void{
            o.bplay = new Date();
            o.flvdinfo.l++;
            if (o.firstplaytimeflag){
                o.flvdinfo.a = this.compareDate(new Date(), startime);
                o.firstplaytimeflag = false;
            };
            o.firstbuffer = false;
            o.playflag = true;
        }
        private function onPlayStatus(e:Object, i:Number, n:gomezNetStream):void{
            trace(e.code);
            this.EventNotify(n, e.code, "");
            if (e.code == "gomezStart"){
                this.createObjectProxy(n, n.gomezid);
            };
            var o:Object = this.getObject(this.ns_array, i);
            if (o == null){
                return;
            };
            if ((((((((((((((e.code == "NetStream.Buffer.Full")) || ((e.code == "NetStream.Seek.Notify")))) || ((e.code == "NetStream.Buffer.Empty")))) || ((e.code == "gomezComplete")))) || ((e.code == "NetStream.Play.Failed")))) || ((e.code == "NetStream.Failed")))) || ((e.code == "NetStream.Play.StreamNotFound")))){
                this.getcurrenttime(o, n);
            };
            if (e.code == "gomezComplete"){
                this.nsData(n, i, "Complete");
                o.completeflag = true;
            };
            if (e.code == "NetStream.Buffer.Full"){
                this.flashEvent("Playing", o.flvindex);
                o.bplay = new Date();
                o.flvdinfo.l++;
                if (o.firstplaytimeflag){
                    o.flvdinfo.a = this.compareDate(new Date(), startime);
                    o.firstplaytimeflag = false;
                };
                o.firstbuffer = false;
                o.playflag = true;
            };
            if ((((e.code == "NetStream.Play.Stop")) || ((e.code == "NetStream.Buffer.Flush")))){
                n.gomezStopReady = true;
            } else {
                if (e.code == "NetStream.Seek.Notify"){
                    this.flashEvent("Seek", o.flvindex);
                    this.EventNotify(n, "seek", e);
                };
            };
            if (e.code == "NetStream.Buffer.Empty"){
                if (!(n.gomezStopReady)){
                    this.flashEvent("Buffering", o.flvindex);
                    o.startbuffertime = new Date();
                    o.begindownloadsize = n.bytesLoaded;
                    o.bufferflag = true;
                    if (!(o.firstbuffer)){
                        o.flvdinfo.d++;
                    };
                    n.gomezStopReady = false;
                };
            };
            if (e.code == "NetStream.Play.Start"){
                this.onNsPlay(e, i, n);
            };
            if ((((((e.code == "NetStream.Play.Failed")) || ((e.code == "NetStream.Failed")))) || ((e.code == "NetStream.Play.StreamNotFound")))){
                n.errorflag = true;
                this.senderror(e, n.flvurl, n);
            };
        }
        private function senderror(e:Object, str:String, n:gomezNetStream):void{
            if (hasTag){
                makeCommonObject();
            };
            var q:Object = new Object();
            q.a = e.code;
            q.b = this.compareDate(new Date(), startime);
            var o:Object = {};
            o.error = q;
            o.errorsendflag = false;
            var c:Object = new Object();
            c.a = replaceurl(str);
            var r:String = str;
            if (r.indexOf("://") > -1){
                c.b = r.substr(0, r.indexOf("://"));
            } else {
                c.b = "-1";
            };
            c.i = this.flvseq;
            this.flvseq++;
            o.flvCommon = c;
            if (this.senderrorflag){
                this.gomezSend(o, false);
                n.errorflag = false;
            } else {
                this.error_array.push(o);
                clearInterval(this.errorobject);
                this.errorobject = setInterval(this.getSendErrorFlag, 500, o, false, n);
            };
        }
        private function getSendErrorFlag(o:Object, b:Boolean, n:gomezNetStream):void{
            if (this.senderrorflag){
                this.gomezSend(o, b);
                if (n != null){
                    n.errorflag = false;
                };
                clearInterval(this.errorobject);
            };
        }
        private function nsData(n:gomezNetStream, i:Number, t:String):void{
            var o:Object = this.getObject(this.ns_array, i);
            if (o == null){
                return;
            };
            if (flvbasic.h == "MSIE"){
                this.getData(n, i, t, o, false);
            } else {
                this.getData(n, i, t, o, false);
            };
        }
        private function getData(n:gomezNetStream, i:Number, t:String, o:Object, f:Boolean):void{
            Debug.getInstance().traceDebug(("GZMon.getData: " + n.errorflag));
            if (n.errorflag){
                return;
            };
            if (!(o.completeflag)){
                this.flashEvent(t, o.flvindex);
                o.flvdinfo.o = this.gettypeid(t);
                o.completeflag = true;
                if (o.firstplaytimeflag){
                    o.flvCommon.i = o.flvindex;
                    o.flvdinfo.a = -1;
                    o.flvdinfo.b = -1;
                    o.flvdinfo.c = -1;
                    o.flvdinfo.d = -1;
                    o.flvdinfo.e = -1;
                    o.flvdinfo.f = -1;
                    o.flvdinfo.h = -1;
                    o.flvdinfo.i = -1;
                    o.flvdinfo.j = -1;
                    o.flvdinfo.k = -1;
                    o.flvdinfo.l = -1;
                    o.flvdinfo.m = -1;
                } else {
                    o.flvdinfo.i = o.eplay;
                    o.downtime = o.progresscount;
                    o.flvdinfo.k = this.compareDate(new Date(), startime);
                    if (o.downtime == 0){
                        o.flvdinfo.f = 0;
                    } else {
                        o.flvdinfo.f = (Math.round(((0.8 * n.bytesLoaded) / o.downtime)) / 100);
                    };
                    if (n.bytesTotal == 0){
                        o.flvdinfo.j = -1;
                        o.flvdinfo.e = -1;
                        o.flvinfo.b = -1;
                        o.flvdinfo.g = -1;
                        o.flvdinfo.c = -1;
                    } else {
                        o.flvdinfo.j = (Math.round(((10000 * o.downsize) / n.bytesTotal)) / 100);
                        o.flvdinfo.e = (Math.round(((10000 * n.bytesLoaded) / n.bytesTotal)) / 100);
                        o.flvinfo.b = n.bytesTotal;
                        if (!(isNaN(Number(o.flvinfo.f)))){
                            if (o.downtime == 0){
                                o.flvdinfo.g = 0;
                            } else {
                                o.flvdinfo.g = (Math.round((((100 * o.flvinfo.f) * n.bytesLoaded) / n.bytesTotal)) / 100);
                            };
                        } else {
                            o.flvdinfo.g = -1;
                        };
                    };
                    if (o.flvdinfo.d == 0){
                        o.flvdinfo.h = 0;
                    };
                    this.satisfaction(o);
                };
                if (hasTag){
                    makeCommonObject();
                };
                Debug.getInstance().traceDebug(((("GZMon.getData: " + o) + " ") + f));
                this.gomezSend(o, f);
            };
        }
        private function createObjectProxy(n:gomezNetStream, i:Number):void{
            var o:Object = new Object();
            o.objindex = i;
            o.flvindex = this.nsflvseq;
            o.bufferflag = false;
            o.firstbuffer = true;
            o.firstplaytimeflag = true;
            o.progresscount = 0;
            o.completeflag = false;
            o.downsize = 0;
            o.eplay = 0;
            o.st_array = new Array();
            var d:Object = new Object();
            d.l = 0;
            d.d = 0;
            d.c = 0;
            d.m = 0;
            d.h = 0;
            d.p = this.compareDate(new Date(), startime);
            o.flvdinfo = d;
            var c:Object = new Object();
            c.a = replaceurl(n.flvurl);
            if (n.flvurl.indexOf("://") > -1){
                if ((((((n.flvurl.substr(0, n.flvurl.indexOf("://")) == "http")) || ((n.flvurl.substr(0, n.flvurl.indexOf("://")) == "rmtp")))) || ((n.flvurl.substr(0, n.flvurl.indexOf("://")) == "https")))){
                    c.b = n.flvurl.substr(0, n.flvurl.indexOf("://"));
                } else {
                    c.b = "http";
                };
            };
            c.i = this.nsflvseq;
            c.q = replaceurl(n.flvid);
            o.flvCommon = c;
            var s:Object = new Object();
            o.flvinfo = s;
            this.nsflvseq++;
            this.ns_array.push(o);
            this.BeginNSSample(n, i);
        }
        private function onNsMetaData(e:Object, i:Number, n:gomezNetStream):void{
            trace("metadata1");
            this.EventNotify(n, "metadataRecived", "");
            var g:Object = this.getObject(this.ns_array, i);
            if (g == null){
                this.createObjectProxy(n, n.gomezid);
            };
            var o:Object = this.getObject(this.ns_array, i);
            if (o == null){
                return;
            };
            this.flashEvent("MetaDataReceived", o.flvindex);
            if (e == null){
                return;
            };
            if (!(isNaN(Number(e["audiocodecid"])))){
                o.flvinfo.c = e["audiocodecid"];
            };
            if (!(isNaN(Number(e["audiodatarate"])))){
                o.flvinfo.d = e["audiodatarate"];
            };
            if (!(isNaN(Number(e["videocodecid"])))){
                o.flvinfo.e = e["videocodecid"];
            };
            if (!(isNaN(Number(e["framerate"])))){
                o.flvinfo.f = e["framerate"];
            };
            trace(999);
            if (!(isNaN(Number(e["videodatarate"])))){
                o.flvinfo.g = e["videodatarate"];
            };
            if (!(isNaN(Number(e["duration"])))){
                o.flvinfo.j = Math.round((e["duration"] * 1000));
            };
            if (!(isNaN(Number(e["width"])))){
                o.flvinfo.i = e["width"];
            };
            if (!(isNaN(Number(e["height"])))){
                o.flvinfo.h = e["height"];
            };
            if (((!(isNaN(Number(e["framerate"])))) && (!(isNaN(Number(e["duration"])))))){
                o.flvinfo.a = Math.round((e["framerate"] * e["duration"]));
            };
        }
        private function getcurrenttime(o:Object, n:gomezNetStream):void{
            var p:Object;
            var op:Object;
            var t:Number = 0;
            var l:Number = 0;
            if (n.bytesTotal){
                t = n.bytesTotal;
            };
            if (n.bytesLoaded){
                l = n.bytesLoaded;
            };
            if (o.playflag){
                o.eplay = (o.eplay + this.compareDate(new Date(), o.bplay));
                p = new Object();
                p.type = "play";
                p.time = this.compareDate(new Date(), o.bplay);
                o.st_array.push(p);
                o.playflag = false;
            } else {
                if (o.bufferflag){
                    if (o.firstplaytimeflag){
                        if (isNaN(Number(o.flvdinfo.b))){
                            o.flvdinfo.b = this.compareDate(new Date(), o.startbuffertime);
                        } else {
                            o.flvdinfo.b = (o.flvdinfo.b + this.compareDate(new Date(), o.startbuffertime));
                        };
                        if (isNaN(Number(o.flvdinfo.c))){
                            o.flvdinfo.c = (Math.round(((10000 * (l - o.begindownloadsize)) / t)) / 100);
                        } else {
                            o.flvdinfo.c = (o.flvdinfo.c + (Math.round(((10000 * (l - o.begindownloadsize)) / t)) / 100));
                        };
                    } else {
                        if (!(o.firstplaytimeflag)){
                            o.downsize = (o.downsize + (l - o.begindownloadsize));
                            o.flvdinfo.h = (o.flvdinfo.h + this.compareDate(new Date(), o.startbuffertime));
                        };
                    };
                    op = new Object();
                    op.type = "buffer";
                    op.time = this.compareDate(new Date(), o.startbuffertime);
                    o.st_array.push(op);
                    o.bufferflag = false;
                };
            };
        }
        private function getBrowserInfo():void{
            var o:String;
            var a:Array;
            var i:Number;
            var _local4:String;
            var _local5:String;
            var g:String;
            if (ExternalInterface.available){
                o = ExternalInterface.call("eval", "navigator.userAgent");
                if (o){
                    a = new Array("MSIE", "Firefox", "Opera", "Safari", "Chrome");
                    i = 0;
                    while (i < a.length) {
                        if (o.indexOf(a[i]) != -1){
                            flvbasic.h = a[i];
                            switch (a[i]){
                                case "MSIE":
                                    flvbasic.g = o.substring((o.indexOf(a[i]) + 5), (o.indexOf(".", o.indexOf(a[i])) + 2));
                                    break;
                                case "Firefox":
                                    _local4 = o.substring((o.indexOf(a[i]) + 8));
                                    if (_local4.indexOf(" ") > -1){
                                        _local4 = _local4.substr(0, _local4.indexOf(" "));
                                    };
                                    flvbasic.g = _local4;
                                    _local5 = flvbasic.g;
                                    _local5 = _local5.substr(0, 3);
                                    if (_local5 == "1.5"){
                                        this.nopost = true;
                                    };
                                    break;
                                case "Opera":
                                    flvbasic.g = o.substring((o.indexOf(a[i]) + 6), o.indexOf("(", o.indexOf(a[i])));
                                    break;
                                case "Safari":
                                    flvbasic.g = o.substring((o.indexOf(a[i]) + 7));
                                    this.nounload = true;
                                    break;
                                case "Chrome":
                                    flvbasic.g = o.substring((o.indexOf(a[i]) + 7), o.indexOf("Safari", o.indexOf(a[i])));
                                    break;
                            };
                        };
                        i++;
                    };
                    if (flvbasic.h == null){
                        flvbasic.h = ExternalInterface.call("eval", "navigator.vendor||navigator.appName");
                        g = ExternalInterface.call("eval", "navigator.appVersion");
                        flvbasic.g = g.substr(0, (g.indexOf("(") - 1));
                    };
                };
            };
        }
        private function getSystemInfo():void{
            if (ExternalInterface.available){
                this.getBrowserInfo();
                flvbasic.f = ExternalInterface.call("eval", "window.navigator.cpuClass");
                flvbasic.i = ExternalInterface.call("eval", "document.body.scrollWidth");
                flvbasic.j = ExternalInterface.call("eval", "document.body.scrollHeight");
            };
            if (hasTag){
                flvbasic.q = 1;
            } else {
                flvbasic.q = 2;
            };
            flvbasic.d = Math.abs(startime.getTimezoneOffset());
            flvbasic.c = Capabilities.language;
            flvbasic.k = Capabilities.version;
            flvbasic.e = Capabilities.os;
            flvbasic.a = Capabilities.screenResolutionX;
            flvbasic.b = Capabilities.screenResolutionY;
            flvbasic.l = "netstream";
        }
        private function getIdInfo():void{
            var o:String;
            var p:String;
            var d:String = this.gomezid;
            var m:String = this.gomezmovie;
            var u:String = "";
            flvbasic.p = this.gomezconect;
            if (d != null){
                try {
                    if (this.varId){
                        clearInterval(this.varId);
                    };
                    if (!(this.nounload)){
                        ExternalInterface.addCallback(("asCallFromJS" + d), create(this, this.callFromJS));
                        ExternalInterface.call("eval", (((((((((((((((("var oFl" + d) + "=window['") + d) + "'] || document['") + d) + "'];function asCallJs") + d) + "(){oFl") + d) + ".asCallFromJS") + d) + "();};if(window.addEventListener){window.addEventListener('unload', asCallJs") + d) + ",false);}else if(window.attachEvent){window.attachEvent('onunload',asCallJs") + d) + ");};"));
                    };
                    if (((((((!((m == null))) && (!((m == "null"))))) && (!((m == null))))) && (!((m == "null"))))){
                        o = ExternalInterface.call("eval", "location.href");
                        if (m.indexOf("?") > -1){
                            m = m.substr(0, m.indexOf("?"));
                        };
                        if ((((m.toLowerCase().indexOf("http://") > -1)) || ((m.toLowerCase().indexOf("https://") > -1)))){
                            u = m;
                        } else {
                            if (m.substr(0, 1) == "/"){
                                if (o != null){
                                    u = (((o.substr(0, o.indexOf(":")) + "://") + ExternalInterface.call("eval", "location.hostname")) + m);
                                };
                            } else {
                                if (o != null){
                                    p = pageurl(o.toString());
                                    u = ((p.substr(0, p.lastIndexOf("/")) + "/") + m);
                                };
                            };
                        };
                        oCommonInfo.p = replaceurl(u);
                    };
                } catch(e:Error) {
                };
            };
        }
        public function callFromJS():void{
            this.AbandonSendData("Abandon", false);
        }
        public function AbandonSendData(type:String, flag:Boolean):void{
            var a:*;
            var j:Number;
            var o:Object;
            var oerror:Object;
            if (this.mc_array == null){
                return;
            };
            if (!(this.startflag)){
                this.sendevents(false);
            };
            var i:Number = 0;
            while (i < this.mc_array.length) {
                a = this.mc_array[i];
                if (a.netStream.bufferTime != null){
                    j = 0;
                    while (j < this.ns_array.length) {
                        o = this.ns_array[j];
                        if (a.netStream.time > 1){
                            if ((((((Number(o.objindex) == a.gomezid)) && (!(o.completeflag)))) && (this.eventflag(String(o.flvindex))))){
                                this.getcurrenttime(o, a);
                                this.getData(a, a.gomezid, type, o, flag);
                            };
                        };
                        j++;
                    };
                };
                i++;
            };
            var k:Number = 0;
            while (k < this.error_array.length) {
                oerror = this.error_array[k];
                if (!(oerror.errorsendflag)){
                    this.gomezSend(oerror, false);
                };
                k++;
            };
        }
        private function eventflag(str:String):Boolean{
            var o:Object;
            if (this.event_array == null){
                return (false);
            };
            var i:Number = 0;
            while (i < this.event_array.length) {
                o = this.event_array[i];
                if (o.flvindex == str){
                    return (true);
                };
                i++;
            };
            return (false);
        }
        private function getConfig():void{
            var oSharedObject:SharedObject;
            var createdate:Number;
            var expdate:Number;
            var oXMLResult:XML;
            var request:URLRequest;
            var loader:URLLoader;
            if ((((this.strVisitorId == "")) && ((this.strSessionId == "")))){
                oSharedObject = SharedObject.getLocal("osConfig");
                this.strVisitorId = oSharedObject.data.visitorId;
                this.strSessionId = new Number((parseInt(oSharedObject.data.sessionId) + 1)).toString();
                oSharedObject.data.sessionId = this.strSessionId;
                this.numSampleRate = new Number(oSharedObject.data.sampleRate);
                createdate = new Number(oSharedObject.data.createdate);
                expdate = new Number(oSharedObject.data.expdate);
                trace(((((((this.strVisitorId + "--") + this.strSessionId) + "--") + createdate) + "--") + expdate));
                if (((((isNaN(createdate)) || (isNaN(expdate)))) || (((new Date().getTime() - createdate) > ((expdate * 24) * 3600000))))){
                    XML.prototype.ignoreWhite = true;
                    oXMLResult = new XML();
                    request = new URLRequest(((getconfigurl + this.accoutid) + "&v=1"));
                    request.contentType = "text/xml";
                    request.data = oXMLResult.toXMLString();
                    request.method = URLRequestMethod.POST;
                    loader = new URLLoader();
                    this.configureListeners(loader);
                    try {
                        loader.load(request);
                    } catch(error:Error) {
                    };
                } else {
                    oCommonInfo.f = this.strVisitorId;
                    oCommonInfo.h = this.strSessionId;
                    if (!(isNaN(this.numSampleRate))){
                        oCommonInfo.j = this.numSampleRate.toString();
                    };
                    this.senderrorflag = true;
                };
            };
        }
        private function completeHandler(event:Event):void{
            var loader:URLLoader = URLLoader(event.target);
            var res:XMLDocument = new XMLDocument();
            res.ignoreWhite = true;
            if ((((loader.data == "")) || ((loader.data == null)))){
                return;
            };
            res.parseXML(loader.data);
            var node:XMLNode = res.firstChild;
            var myRoot:Object = this;
            GZMon.oCommonInfo.f = node.attributes.a;
            GZMon.oCommonInfo.h = 1;
            GZMon.oCommonInfo.j = new Number(node.attributes.b);
            var osObject:SharedObject = SharedObject.getLocal("osConfig");
            osObject.data.visitorId = GZMon.oCommonInfo.f;
            osObject.data.sessionId = GZMon.oCommonInfo.h;
            osObject.data.sampleRate = GZMon.oCommonInfo.j;
            osObject.data.createdate = new Date().getTime();
            if (new Number(node.attributes.c)){
                osObject.data.expdate = new Number(node.attributes.c);
            } else {
                osObject.data.expdate = 5;
            };
            if (myRoot.sendcustomerflag()){
                myRoot.sendCustomerEvent();
            };
            myRoot.senderrorflag = true;
        }
        private function getSampleRate(s:Number):Boolean{
            Debug.getInstance().traceDebug(((("GZMon.getSampleRate: " + s) + " ") + rand));
            if (isNaN(Number(s))){
                return (false);
            };
            if (s == 0){
                return (false);
            };
            return ((rand <= s));
        }
        private function getSeqNoFromAS():String{
            var s:SharedObject = SharedObject.getLocal("osSeqNo");
            var q:String = "";
            q = s.data.seqNo;
            if ((((q == "")) || ((q == null)))){
                q = "1";
            };
            s.data.seqNo = new Number((parseInt(q) + 1)).toString();
            s.flush();
            s.clear();
            return (q);
        }
        private function makeCommonFromAS():void{
            var h:*;
            if (ExternalInterface.available){
                h = ExternalInterface.call("eval", "location.href");
                if (h != null){
                    oCommonInfo.l = replaceurl(pageurl(h.toString()));
                };
            };
            oCommonInfo.d = this.accoutid;
            oCommonInfo.e = this.strPageId;
            oCommonInfo.g = this.strGroupId;
            oCommonInfo.o = this.getSeqNoFromAS();
        }
        private function makeCommonString(o:Object):String{
            var i:*;
            var j:*;
            var r:String = "{n:t";
            for (i in o) {
                if (((((!((o[i] == null))) && (!((o[i] == "null"))))) && (!((o[i] == null))))){
                    r = (r + ((("|" + i) + ":") + o[i]));
                };
            };
            if (((hasTag) && ((oCommonInfo["m"] > 0)))){
                r = (r + ((("|c:" + String((startime.getTime() - oCommonInfo["m"]))) + "|m:") + String(oCommonInfo["m"])));
            } else {
                r = (r + ("|c:0|m:" + String(startime.getTime())));
            };
            oCommonInfo.g = this.strGroupId;
            for (j in oCommonInfo) {
                if (j != "m"){
                    if (((((!((oCommonInfo[j] == null))) && (!((oCommonInfo[j] == "null"))))) && (!((oCommonInfo[j] == null))))){
                        r = (r + ((("|" + j) + ":") + oCommonInfo[j]));
                    };
                };
            };
            r = (r + ("|k:" + this.gomezversion));
            r = (r + "}");
            return (r);
        }
        private function satisfaction(t:Object):void{
            var b:Object;
            var lp:*;
            var w:Object;
            var f:Object;
            var d:Object;
            if (t.st_array == null){
                return;
            };
            var y:String = "";
            var a:Array = new Array();
            var o:Object = new Object();
            var j:Number = 0;
            while (j < t.st_array.length) {
                b = t.st_array[j];
                if (y != String(b.type)){
                    if (b.type == "play"){
                        o.playtime = b.time;
                    };
                    if (b.type == "buffer"){
                        o.buffertime = b.time;
                    };
                } else {
                    lp = t.st_array[(j - 1)];
                    if (b.type == "play"){
                        o.playtime = (b.time + lp.time);
                    };
                    if (b.type == "buffer"){
                        o.buffertime = (b.time + lp.time);
                    };
                };
                y = b.type;
                if (((!((o.buffertime == null))) && (!((o.playtime == null))))){
                    if ((((o.buffertime == 0)) && ((o.playtime == 0)))){
                    } else {
                        a.push(o);
                    };
                    o = new Object();
                } else {
                    if ((j + 1) == t.st_array.length){
                        if (b.type == "play"){
                            o.playtime = b.time;
                            o.buffertime = 0;
                        };
                        if (b.type == "buffer"){
                            o.buffertime = b.time;
                            o.playtime = 0;
                        };
                        if ((((o.buffertime == 0)) && ((o.playtime == 0)))){
                        } else {
                            a.push(o);
                        };
                        o = new Object();
                    };
                };
                j++;
            };
            var c:Number = a.length;
            var p:Number = 0;
            var k:Number = 0;
            while (k < a.length) {
                w = a[k];
                p = (p + w.playtime);
                k++;
            };
            var av:Number = 0;
            var u:Number = 0;
            var s:Number = 0;
            while (s < a.length) {
                f = a[s];
                av = (av + (1 - (u / p)));
                u = (u + f.playtime);
                s++;
            };
            u = 0;
            var l:Number = 0;
            var i:Number = 0;
            while (i < a.length) {
                d = a[i];
                l = (l + ((d.playtime / ((3 * d.buffertime) + d.playtime)) * (1 - (u / p))));
                u = (u + d.playtime);
                i++;
            };
            if (c == 0){
                t.flvdinfo.m = 0;
            } else {
                t.flvdinfo.m = (l / av);
            };
            if (isNaN(Number(t.flvdinfo.m))){
                t.flvdinfo.m = -1;
            };
        }
        private function gettypeid(t:String):String{
            var i:String = "1";
            switch (t){
                case "Complete":
                    i = "1";
                    break;
                case "Abandon":
                    i = "2";
                    break;
                case "Stop":
                    i = "3";
                    break;
            };
            return (i);
        }
        private function flashEvent(n:String, i:String):void{
            var o:Object = new Object();
            o.a = n;
            o.b = this.compareDate(new Date(), startime);
            o.d = this.seqnum++;
            o.e = 1;
            o.flvindex = i;
            this.event_array.push(o);
        }
        private function trim(myString:String):String{
            if ((((myString.indexOf(" ") < 0)) && (myString.indexOf("　")))){
                return (myString);
            };
            var omyString:String = myString;
            myString = myString.replace("　", " ");
            var lblanknum:Number = 0;
            var rblanknum:Number = 0;
            var i:Number = 0;
            while (i < myString.length) {
                if (myString.charAt(i) != " "){
                    break;
                };
                lblanknum++;
                i++;
            };
            var j:Number = (myString.length - 1);
            while (j > 0) {
                if (myString.charAt(j) != " "){
                    break;
                };
                rblanknum++;
                j--;
            };
            return (omyString.substr(lblanknum, (omyString.length - rblanknum)));
        }
        private function isInvaildName(myName:String):Boolean{
            if (myName == null){
                return (true);
            };
            if (this.trim(myName).length == 0){
                return (true);
            };
            return (false);
        }
        public function nameEvent(n:String):void{
            if (this.isInvaildName(n)){
                return;
            };
            n = this.trim(n);
            var o:Object = new Object();
            o.a = replaceurl(n);
            o.b = this.compareDate(new Date(), startime);
            o.d = this.getseqNum(n);
            o.e = 1;
            customerEvent_array.push(o);
            if (this.sendcustomerflag()){
                if (flvbasic.h == "MSIE"){
                    this.sendevents(false);
                } else {
                    this.sendevents(false);
                };
            };
        }
        public function customValue(n:String, v:Number):void{
            if (this.isInvaildName(n)){
                return;
            };
            n = this.trim(n);
            if ((((((n == null)) || (!((n.indexOf(" ") == -1))))) || ((n == "")))){
                return;
            };
            var o:Object = new Object();
            o.a = replaceurl(n);
            o.b = v;
            o.d = this.getseqNum(n);
            o.e = 3;
            customerEvent_array.push(o);
            if (this.sendcustomerflag()){
                if (flvbasic.h == "MSIE"){
                    this.sendevents(false);
                } else {
                    this.sendevents(false);
                };
            };
        }
        private function getseqNum(n:String):Number{
            var o:*;
            var m:Number = 1;
            var i:Number = 0;
            while (i < customerEvent_array.length) {
                o = customerEvent_array[i];
                if (n == o.a){
                    m++;
                };
                i++;
            };
            return (m);
        }
        public function startInterval(n:String):void{
            if (this.isInvaildName(n)){
                return;
            };
            n = this.trim(n);
            var o:Object = new Object();
            o.a = replaceurl(n);
            o.b = this.compareDate(new Date(), startime);
            o.d = this.getseqNum(n);
            o.e = 2;
            customerEvent_array.push(o);
        }
        public function endInterval(n:String):void{
            var o:*;
            if (this.isInvaildName(n)){
                return;
            };
            n = this.trim(n);
            n = replaceurl(n);
            var i:Number = 0;
            while (i < customerEvent_array.length) {
                o = customerEvent_array[i];
                if ((((n == o.a)) && (isNaN(o.c)))){
                    o.c = this.compareDate(new Date(), startime);
                };
                i++;
            };
            if (this.sendcustomerflag()){
                if (flvbasic.h == "MSIE"){
                    this.sendevents(false);
                } else {
                    this.sendevents(false);
                };
            };
        }
        private function getCustomerEventStrArray(c:Number):Array{
            var o:*;
            if (customerEvent_array == null){
                return (null);
            };
            var a:Array = new Array();
            var r:String = "";
            var q:Number = 0;
            var n:Number = 0;
            var i:Number = 0;
            while (i < customerEvent_array.length) {
                o = customerEvent_array[i];
                if ((((o.e == 2)) && (isNaN(o.c)))){
                } else {
                    if (o.sendflag != 0){
                        n++;
                        r = (r + this.makestring(o, "s"));
                        if (c == n){
                            a.push(r);
                            r = "";
                            n = 0;
                        };
                        o.sendflag = 0;
                    };
                };
                i++;
            };
            if (r != ""){
                a.push(r);
            };
            return (a);
        }
        private function sendcustomerflag():Boolean{
            var o:*;
            var n:Number = 0;
            var i:Number = 0;
            while (i < customerEvent_array.length) {
                o = customerEvent_array[i];
                if ((((o.e == 2)) && (isNaN(o.c)))){
                } else {
                    if (o.sendflag != 0){
                        n++;
                    };
                };
                i++;
            };
            if (n >= this.customerNum){
                return (true);
            };
            return (false);
        }
        public function sendCustomerEvent():void{
            if (flvbasic.h == "MSIE"){
                this.sendevents(false);
            } else {
                this.sendevents(false);
            };
        }
        private function sendevents(t:Boolean):void{
            var i:Number;
            var j:Number;
            if (hasTag){
                if (this.getrumtagsamplerate.toLowerCase() != "true"){
                    return;
                };
                makeCommonObject();
            } else {
                if (!(this.getSampleRate(Number(oCommonInfo.j)))){
                    return;
                };
            };
            if (customerEvent_array == null){
                return;
            };
            var z:Array = this.getCustomerEventStrArray(35);
            if (z.length == 0){
                return;
            };
            var o:Object = new Object();
            if (!(this.startflag)){
                flvbasic.l = "SWF";
                o.a = oCommonInfo.p;
            };
            var str:String = (this.makeCommonString(o) + this.makestring(flvbasic, "x"));
            var strSource:String = "";
            if (this.alreadySend){
                strSource = str;
            } else {
                strSource = (str + "{n:z}{n:y}");
            };
            if (!(t)){
                if (z != null){
                    if (z.length == 1){
                        this.sendString((strSource + z[0]), t);
                    } else {
                        this.sendString(strSource, t);
                        i = 0;
                        while (i < z.length) {
                            strSource = (str + z[i]);
                            this.sendString(strSource, t);
                            i++;
                        };
                    };
                };
            } else {
                if (z != null){
                    j = 0;
                    while (j < z.length) {
                        strSource = (strSource + z[j]);
                        j++;
                    };
                    this.sendString(strSource, t);
                };
            };
            this.alreadySend = true;
        }
        private function getObject(a:Array, s:Number):Object{
            var o:Object;
            if (a == null){
                return (null);
            };
            var n:Object;
            var i:Number = 0;
            while (i < a.length) {
                o = a[i];
                if (((((!((o == null))) && ((Number(o.objindex) == s)))) && (!(o.completeflag)))){
                    if (n == null){
                        n = o;
                    } else {
                        if (o.flvindex > n.flvindex){
                            n = o;
                        };
                    };
                };
                i++;
            };
            return (n);
        }
        private function getEventStrArray(d:String, c:Number):Array{
            var o:*;
            if (this.event_array == null){
                return (null);
            };
            var a:Array = new Array();
            var r:String = "";
            var q:Number = 0;
            var n:Number = 0;
            var i:Number = 0;
            while (i < this.event_array.length) {
                o = this.event_array[i];
                if (o.flvindex == d){
                    var _temp1 = q;
                    q = (q + 1);
                    o.d = _temp1;
                    n++;
                    r = (r + this.makestring(o, "s"));
                    if (c == n){
                        a.push(r);
                        r = "";
                        n = 0;
                    };
                };
                i++;
            };
            if (r != ""){
                a.push(r);
            };
            return (a);
        }
        private function makestring(o:Object, t:String):String{
            var i:*;
            var m:Number = 0;
            if (((hasTag) && ((oCommonInfo["m"] > 0)))){
                m = Number((startime.getTime() - oCommonInfo["m"]));
            };
            if (o == null){
                return ("");
            };
            if (t == "z"){
                if (o.a != -1){
                    if (isNaN(o.a)){
                        o.a = m;
                    } else {
                        o.a = (o.a + m);
                    };
                    if (isNaN(o.k)){
                        o.k = m;
                    } else {
                        o.k = (o.k + m);
                    };
                };
                if (isNaN(o.p)){
                    o.p = m;
                } else {
                    o.p = (o.p + m);
                };
            } else {
                if (t == "s"){
                    if (isNaN(o.b)){
                        o.b = m;
                    } else {
                        o.b = (o.b + m);
                    };
                    if (!(isNaN(o.c))){
                        o.c = (o.c + m);
                    };
                } else {
                    if (t == "r"){
                        if (isNaN(o.b)){
                            o.b = m;
                        } else {
                            o.b = (o.b + m);
                        };
                    };
                };
            };
            var r:String = ("{n:" + t);
            for (i in o) {
                if (i != "flvindex"){
                    if (((((!((o[i] == null))) && (!((o[i] == "null"))))) && (!((o[i] == null))))){
                        r = (r + ((("|" + i) + ":") + o[i]));
                    };
                };
            };
            r = (r + "}");
            return (r);
        }
        private function spliteNum(n:Number):String{
            var r:Number;
            if ((((n < 0)) || ((n > 15)))){
                return ("0000");
            };
            var p:String = "0000";
            if (n == 0){
                return (p);
            };
            if (n == 1){
                return ("0001");
            };
            var t:Number = n;
            var q:Array = new Array();
            while (t > 1) {
                r = (t / 2);
                t = Math.floor((t / 2));
                if (t == r){
                    q.push("0");
                } else {
                    q.push("1");
                };
                if (t == 1){
                    q.push("1");
                };
            };
            var s:String = "";
            var i:Number = 3;
            while (i >= 0) {
                if (q[i] == null){
                    s = (s + "0");
                } else {
                    s = (s + q[i]);
                };
                i--;
            };
            return (s);
        }
        private function gomezSend(o:Object, t:Boolean):void{
            var a:Array;
            var i:Number;
            var j:Number;
            var k:Number;
            var m:Number;
            var c:Number;
            Debug.getInstance().traceDebug(((((((("GZMon.gomezSend: 1 - " + getContinue) + " ") + hasTag) + " ") + this.getSampleRate(Number(oCommonInfo.j))) + " ") + this.identifier.length));
            if (!(getContinue)){
                return;
            };
            if (hasTag){
                if (this.getrumtagsamplerate.toLowerCase() != "true"){
                    return;
                };
            } else {
                if (!(this.getSampleRate(Number(oCommonInfo.j)))){
                    return;
                };
            };
            if (this.identifier.length != 4){
                return;
            };
            Debug.getInstance().traceDebug("GZMon.gomezSend: 2");
            var s:String = this.identifier.substr(3, 1);
            var d:String = this.identifier.substr(2, 1);
            var e:String = this.identifier.substr(0, 1);
            var r:String = this.identifier.substr(1, 1);
            var strr:String = "";
            if (r == "1"){
                strr = this.makestring(o.error, "r");
            };
            var strSource:String = "";
            var stry:String = "";
            if (s == "1"){
                stry = this.makestring(o.flvinfo, "y");
            } else {
                stry = "{n:y}";
            };
            var strz:String = "";
            if (d == "1"){
                strz = this.makestring(o.flvdinfo, "z");
            } else {
                strz = "{n:z}";
            };
            if (e == "1"){
                a = this.getEventStrArray(o.flvindex, 35);
            };
            var str:String = (this.makeCommonString(o.flvCommon) + this.makestring(flvbasic, "x"));
            var z:Array = this.getCustomerEventStrArray(35);
            if (o.error != null){
                strSource = (((str + stry) + strz) + strr);
                if (z != null){
                    i = 0;
                    while (i < z.length) {
                        strSource = (strSource + z[i]);
                        i++;
                    };
                };
                this.sendString(strSource, t);
                o.errorsendflag = true;
                clearInterval(this.errorobject);
                return;
            };
            if (!(t)){
                strSource = ((str + stry) + strz);
                if (z != null){
                    if (z.length == 1){
                        this.sendString((strSource + z[0]), t);
                    } else {
                        this.sendString(strSource, t);
                        j = 0;
                        while (j < z.length) {
                            strSource = (str + z[j]);
                            this.sendString(strSource, t);
                            j++;
                        };
                    };
                } else {
                    this.sendString(strSource, t);
                };
                if (a != null){
                    k = 0;
                    while (k < a.length) {
                        strSource = (str + a[k]);
                        this.sendString(strSource, t);
                        k++;
                    };
                };
            } else {
                strSource = ((str + stry) + strz);
                if (z != null){
                    m = 0;
                    while (m < z.length) {
                        strSource = (strSource + z[m]);
                        m++;
                    };
                };
                if (a != null){
                    c = 0;
                    while (c < a.length) {
                        strSource = (strSource + a[c]);
                        c++;
                    };
                };
                this.sendString(strSource, t);
            };
            this.deleteArray(o.flvindex);
            clearInterval(this.errorobject);
        }
        private function sendString(r:String, t:Boolean):void{
            trace(r);
            Debug.getInstance().traceDebug(((((("GZMon.sendString: " + oCommonInfo.l) + " | ") + t) + " ") + r));
            if ((((oCommonInfo.l == null)) || ((oCommonInfo.l == "")))){
                return;
            };
            var request:URLRequest = new URLRequest(posturl);
            request.contentType = "text/xml";
            request.data = ("info=" + r);
            request.method = URLRequestMethod.POST;
            var loader:URLLoader = new URLLoader();
            this.configureListeners(loader);
            if (t){
                try {
                    loader.load(request);
                } catch(e:Error) {
                };
            } else {
                if (ExternalInterface.available){
                    r = encodeURIComponent(r);
                    ExternalInterface.call("eval", (((("var o=new Image();o.src='" + posturl) + "?info=") + r) + "';o.onload=function(){return;};"));
                } else {
                    try {
                        loader.load(request);
                    } catch(e:Error) {
                    };
                };
            };
        }
        private function configureListeners(dispatcher:IEventDispatcher):void{
            dispatcher.addEventListener(Event.COMPLETE, this.completeHandler);
            dispatcher.addEventListener(Event.OPEN, this.openHandler);
            dispatcher.addEventListener(ProgressEvent.PROGRESS, this.progressHandler);
            dispatcher.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.securityErrorHandler);
            dispatcher.addEventListener(HTTPStatusEvent.HTTP_STATUS, this.httpStatusHandler);
            dispatcher.addEventListener(IOErrorEvent.IO_ERROR, this.ioErrorHandler);
        }
        private function openHandler(event:Event):void{
        }
        private function progressHandler(event:ProgressEvent):void{
        }
        private function securityErrorHandler(event:SecurityErrorEvent):void{
        }
        private function httpStatusHandler(event:HTTPStatusEvent):void{
        }
        private function ioErrorHandler(event:IOErrorEvent):void{
        }
        private function deleteArray(d:String):void{
            var o:Object;
            var l:Number = this.event_array.length;
            var i:Number = 0;
            while (i < l) {
                o = this.event_array[i];
                if (o != null){
                    if (o.flvindex == d){
                        this.event_array.splice(i, 1);
                        i = 0;
                    };
                };
                i++;
            };
        }
        public function MarkCompleted():void{
            if (flvbasic.h == "MSIE"){
                this.AbandonSendData("Complete", false);
            } else {
                this.AbandonSendData("Complete", false);
            };
            this.replayflag = true;
        }
        public function MarkPause(n:NetStream):void{
            var ns:*;
            var i:Number = 0;
            while (i < this.mc_array.length) {
                ns = this.mc_array[i];
                if (ns.netStream == n){
                    this.onNsPause(true, ns.gomezid, ns);
                    break;
                };
                i++;
            };
        }
        public function MarkResume(n:NetStream):void{
            var ns:*;
            var i:Number = 0;
            while (i < this.mc_array.length) {
                ns = this.mc_array[i];
                if (ns.netStream == n){
                    this.onNsPause(false, ns.gomezid, ns);
                    break;
                };
                i++;
            };
        }
        public function MarkClose(n:NetStream, ibmID:int):void{
            var ns:*;
            var i:Number = 0;
            while (i < this.mc_array.length) {
                ns = this.mc_array[i];
                if (ns.ibmID == ibmID){
                    Debug.getInstance().traceDebug(("GZMon.MarkClose: " + ibmID));
                    this.onNsClose(ns.gomezid, ns);
                    break;
                };
                i++;
            };
        }
        public function setParameter(u:String, i:Number, n:Number, b:Boolean=false):void{
            var h:*;
            var o:*;
            if (ExternalInterface.available){
                ExternalInterface.addCallback("setGomezVar", create(this, this.setVarFromjs));
                getContinueFlag();
            };
            this.accoutid = String(u);
            this.identifier = this.spliteNum(i);
            this.sendbyself = b;
            if (n > 0){
                this.customerNum = n;
            } else {
                this.customerNum = 1;
            };
            var accounturl:String = (("http://" + this.accoutid) + ".r.axf8.net");
            if (ExternalInterface.available){
                h = ExternalInterface.call("eval", "location.protocol");
                if (h != undefined){
                    accounturl = (((h + "//") + this.accoutid) + ".r.axf8.net");
                };
            };
            crossdomainurl = (accounturl + "/crossdomain.xml");
            getconfigurl = (accounturl + "/MR/c.gif?a=");
            posturl = (accounturl + "/MR/d.gif");
            this.getSystemInfo();
            if (ExternalInterface.available){
                o = ExternalInterface.call("gomez.gt");
                if (o > new Date(0).getUTCMilliseconds()){
                    hasTag = true;
                    this.getRumSampleRateid = setInterval(this.getRumSampleRate, 100);
                };
                if (!(this.nopost)){
                    try {
                        ExternalInterface.call("eval", "try{var oAr=document.getElementsByTagName('object'); if(oAr.length==0) oAr=document.getElementsByTagName('embed'); var type='';var l=oAr.length;for(var i=0;i<l;i++){var oId=oAr[i].id;if(!oId) oId=oAr[i].name;var oTransform;if(window.document[oId]){oTransform=window.document[oId];}else if(navigator.appName.indexOf('Microsoft Internet')==-1){oTransform=oAr[i];}else{oTransform=document.getElementById(oId);};var movieurl=oTransform.src||oAr[i].movie||oTransform.getAttribute('src');oTransform.setGomezVar('gomezid',oId);oTransform.setGomezVar('gomezmovie',movieurl);oTransform.setGomezVar('gomezconect',type);};}catch(e){};");
                    } catch(e:Error) {
                    };
                    this.varId = setInterval(this.getIdInfo, 100);
                };
            };
            if (!(hasTag)){
                this.getConfig();
                this.makeCommonFromAS();
            };
            this.lastEvent.eventName = "";
            this.lastEvent.param = "";
            if (!(this.sendbyself)){
            };
        }
        public function setGroupID(g:String):void{
            this.strGroupId = replaceurl(g);
        }
        public function SendDynamicObject():void{
            var d:Object = new Object();
            if (this.dynamicObject.flvurl == null){
                return;
            };
            d.a = (((this.dynamicObject.PlayStartTime == undefined)) ? -1 : this.dynamicObject.PlayStartTime);
            d.b = (((this.dynamicObject.FirstBufferTime == undefined)) ? -1 : this.dynamicObject.FirstBufferTime);
            d.c = (((this.dynamicObject.FirstBufferPercentage == undefined)) ? -1 : this.dynamicObject.FirstBufferPercentage);
            d.d = (((this.dynamicObject.RebufferCount == undefined)) ? -1 : this.dynamicObject.RebufferCount);
            d.e = (((this.dynamicObject.DownLoadPercentage == undefined)) ? -1 : this.dynamicObject.DownLoadPercentage);
            d.f = (((this.dynamicObject.BitRate == undefined)) ? -1 : this.dynamicObject.BitRate);
            d.g = (((this.dynamicObject.FrameRate == undefined)) ? -1 : this.dynamicObject.FrameRate);
            d.h = (((this.dynamicObject.TotalReBufferTime == undefined)) ? -1 : this.dynamicObject.TotalReBufferTime);
            d.i = (((this.dynamicObject.TotalPlayTime == undefined)) ? -1 : this.dynamicObject.TotalPlayTime);
            d.j = (((this.dynamicObject.TotalReBufferPercentage == undefined)) ? -1 : this.dynamicObject.TotalReBufferPercentage);
            d.k = (((this.dynamicObject.CompletedTime == undefined)) ? -1 : this.dynamicObject.CompletedTime);
            d.l = (((this.dynamicObject.PlayCount == undefined)) ? -1 : this.dynamicObject.PlayCount);
            d.m = (((this.dynamicObject.Satisfaction == undefined)) ? -1 : this.dynamicObject.Satisfaction);
            d.o = (((this.dynamicObject.EndType == undefined)) ? 1 : this.dynamicObject.EndType);
            d.p = (((this.dynamicObject.StartTime == undefined)) ? -1 : this.dynamicObject.StartTime);
            this.dynamicObject.flvid = (((this.dynamicObject.flvid == undefined)) ? "" : this.dynamicObject.flvid);
            if (d.a > d.k){
                d.k = -1;
            };
            if (this.senderrorflag){
                this.makeObjectToString(this.dynamicObject.flvurl, d, this.dynamicObject.flvid);
            } else {
                clearInterval(this.customerObjcet);
                this.customerObjcet = setInterval(this.makeObjectToString, 100, this.dynamicObject.flvurl, d, this.dynamicObject.flvid);
            };
        }
        public function makeObjectToString(u:String, d:Object, id:String):void{
            var j:Number;
            if (!(this.sendbyself)){
                return;
            };
            if (hasTag){
                if (this.getrumtagsamplerate.toLowerCase() != "true"){
                    return;
                };
            } else {
                if (!(this.getSampleRate(Number(oCommonInfo.j)))){
                    return;
                };
            };
            if (hasTag){
                makeCommonObject();
            };
            var c:Object = {};
            c.a = replaceurl(u);
            c.q = replaceurl(id);
            if (u.indexOf("://") > -1){
                c.b = u.substr(0, u.indexOf("://"));
            } else {
                c.b = "http";
            };
            c.i = 1;
            var strz:String = "";
            if (d != null){
                strz = ("{n:y}" + this.makestring(d, "z"));
            } else {
                strz = "{n:y}{n:z}";
            };
            var str:String = (this.makeCommonString(c) + this.makestring(flvbasic, "x"));
            var z:Array = this.getCustomerEventStrArray(35);
            var sendstr:String = (str + strz);
            if (z != null){
                if (z.length == 1){
                    this.sendString((sendstr + z[0]), false);
                } else {
                    this.sendString(sendstr, false);
                    j = 0;
                    while (j < z.length) {
                        sendstr = (str + z[j]);
                        this.sendString(sendstr, false);
                        j++;
                    };
                };
            };
            clearInterval(this.customerObjcet);
        }
        public function setNetStream(u:String, ns:Object, ibmID:int, id:String=""):void{
            Debug.getInstance().traceDebug(((("GzMon.setNetStream: " + u) + " ") + ibmID));
            var gns:gomezNetStream = new gomezNetStream();
            gns.ibmID = ibmID;
            gns.netStream = (ns as NetStream);
            gns.flvurl = u;
            gns.flvid = replaceurl(id);
            gns.errorflag = false;
            this.AddNetStream(gns);
            this.setnetStream = true;
        }
        public function getStartTime():Date{
            return (startime);
        }
        public function getTimeSpan():Number{
            return (this.compareDate(new Date(), startime));
        }
        private function getRumSampleRate():void{
            ExternalInterface.call("eval", "try{var oAr=document.getElementsByTagName('object'); if(oAr.length==0) oAr=document.getElementsByTagName('embed'); var l=oAr.length;for(var i=0;i<l;i++){var oId=oAr[i].id;if(!oId) oId=oAr[i].name;var oTransform;if(window.document[oId]){oTransform=window.document[oId];}else if(navigator.appName.indexOf('Microsoft Internet')==-1){oTransform=oAr[i];}else{oTransform=document.getElementById(oId);};oTransform.setGomezVar('gomez_cansend',gomez.d);oTransform.setGomezVar('gomezverboseneed',gomez._w);};}catch(e){};");
            var g:String = this.gomez_cansend;
            if ((((g == true)) || ((g.toLowerCase() == "true")))){
                this.getrumtagsamplerate = this.gomezverboseneed;
                this.senderrorflag = true;
                clearInterval(this.getRumSampleRateid);
            };
        }
        private function setVarFromjs(t:String, v:String):void{
            if (t == "gomezid"){
                this.gomezid = v;
            } else {
                if (t == "gomezmovie"){
                    this.gomezmovie = v;
                } else {
                    if (t == "gomezconect"){
                        this.gomezconect = v;
                    } else {
                        if (t == "gomez_cansend"){
                            this.gomez_cansend = v;
                        } else {
                            if (t == "gomezverboseneed"){
                                this.gomezverboseneed = v;
                            } else {
                                if (t == "gomezrunFlg"){
                                    gomezrunFlg = v;
                                };
                            };
                        };
                    };
                };
            };
        }
        private function compareDate(d:Date, b:Date):Number{
            return ((d.getTime() - b.getTime()));
        }
        private function DateToString(d:Date):String{
            var m:Number = (d.getMonth() + 1);
            return (((((((((((d.getFullYear() + "-") + m) + "-") + d.getDate()) + " ") + d.getHours()) + ":") + d.getMinutes()) + ":") + d.getSeconds()));
        }

    }
}//package com.gomez 

import flash.net.*;
import flash.events.*;

class AbstractEventDispatcher implements IEventDispatcher {

    protected var _listener:EventDispatcher;

    public function AbstractEventDispatcher(){
        super();
        this._listener = new EventDispatcher(this);
    }
    public function hasEventListener(type:String):Boolean{
        return (this._listener.hasEventListener(type));
    }
    public function willTrigger(type:String):Boolean{
        return (this._listener.willTrigger(type));
    }
    public function addEventListener(type:String, listener:Function, useCapture:Boolean=false, priority:int=0, useWeakReference:Boolean=false):void{
        this._listener.addEventListener(type, listener, useCapture, priority, useWeakReference);
    }
    public function removeEventListener(type:String, listener:Function, useCapture:Boolean=false):void{
        this._listener.removeEventListener(type, listener, useCapture);
    }
    public function dispatchEvent(event:Event):Boolean{
        return (this._listener.dispatchEvent(event));
    }

}
class GomezEvents extends Event {

    public static const gomezNetStreamEvents:String = "gomezNetStreamEvents";
    public static const onMetaData:String = "onMetaData";
    public static const pause:String = "pause";
    public static const close:String = "close";

    public var data:Object;

    public function GomezEvents(type:String, data:Object, bubbles:Boolean=true, cancelable:Boolean=false){
        super(type, bubbles, cancelable);
        this.data = data;
    }
}
class gomezNetStream extends AbstractEventDispatcher {

    private var _ibmID:int;
    private var _ns:NetStream;
    private var _gomezid:Number;
    private var _gomezfirstseek:Boolean;
    private var _flvurl:String;
    private var _flvid:String;
    private var _errorflag:Boolean;
    private var _event:NetStatusEvent;
    private var _stopready:Boolean = false;

    public function gomezNetStream(){
    }
    private function netStatusHandler(event:NetStatusEvent):void{
        this.nsevent = event;
        dispatchEvent(new GomezEvents(GomezEvents.gomezNetStreamEvents, this));
    }
    public function get ibmID():int{
        return (this._ibmID);
    }
    public function set ibmID(value:int):void{
        this._ibmID = value;
    }
    public function set netStream(n:NetStream):void{
        this._ns = n;
        this._ns.addEventListener(NetStatusEvent.NET_STATUS, this.netStatusHandler);
    }
    public function get netStream():NetStream{
        return (this._ns);
    }
    public function set gomezid(n:Number):void{
        this._gomezid = n;
    }
    public function get gomezid():Number{
        return (this._gomezid);
    }
    public function set gomezfirstseek(n:Boolean):void{
        this._gomezfirstseek = n;
    }
    public function get gomezfirstseek():Boolean{
        return (this._gomezfirstseek);
    }
    public function set flvurl(n:String):void{
        this._flvurl = n;
    }
    public function get flvurl():String{
        return (this._flvurl);
    }
    public function set flvid(n:String):void{
        this._flvid = n;
    }
    public function get flvid():String{
        return (this._flvid);
    }
    public function set errorflag(n:Boolean):void{
        this._errorflag = n;
    }
    public function get errorflag():Boolean{
        return (this._errorflag);
    }
    public function set nsevent(n:NetStatusEvent):void{
        this._event = n;
    }
    public function get nsevent():NetStatusEvent{
        return (this._event);
    }
    public function set gomezStopReady(n:Boolean):void{
        this._stopready = n;
    }
    public function get gomezStopReady():Boolean{
        return (this._stopready);
    }
    public function get bytesLoaded():Number{
        return (this._ns.bytesLoaded);
    }
    public function get bytesTotal():Number{
        return (this._ns.bytesTotal);
    }

}
﻿package com.gomez {
    import flash.events.*;

    public class AbstractEventDispatcher implements IEventDispatcher {

        protected var _listener:EventDispatcher;

        public function AbstractEventDispatcher(){
            super();
            this._listener = new EventDispatcher(this);
        }
        public function hasEventListener(type:String):Boolean{
            return (this._listener.hasEventListener(type));
        }
        public function willTrigger(type:String):Boolean{
            return (this._listener.willTrigger(type));
        }
        public function addEventListener(type:String, listener:Function, useCapture:Boolean=false, priority:int=0, useWeakReference:Boolean=false):void{
            this._listener.addEventListener(type, listener, useCapture, priority, useWeakReference);
        }
        public function removeEventListener(type:String, listener:Function, useCapture:Boolean=false):void{
            this._listener.removeEventListener(type, listener, useCapture);
        }
        public function dispatchEvent(event:Event):Boolean{
            return (this._listener.dispatchEvent(event));
        }

    }
}//package com.gomez 
﻿package {
    import com.ibm.AS3util.*;
    import com.ibm.media.*;
    import flash.utils.*;
    import flash.events.*;
    import flash.external.*;
    import flash.net.*;
    import flash.display.*;

    public class Radio extends Sprite implements IEventDispatcher {

        private var _config:Config;
        private var _configLocation:String;
        private var _previousVolume:Number;
        private var _isMute:Boolean = false;
        private var _streamURL:String;
        private var _dataXML:XML;
        private var _dataLocation:String;
        private var _dataURL:URLRequest;
        private var _dataLoader:URLLoader;
        private var _loadTimer:Timer;
        public var _mainVideo:VideoDisplay;
        private var _isPlaying:Boolean;
        private var _playbackStarted:Boolean;
        private var _streamStatus:Array;
        private var _currStream:String = "";
        private var _debug:Debug;
        public var _streamNo:String;
        private var refreshSec:int = 300;
        private var _startRadio:Boolean;
        private var _startAudio:int;
        private var _numChannels:int;

        public function Radio(configLocation:String, streamNo:String, startAudio:int, startRadio:Boolean, numChannels:int){
            super();
            this._debug = Debug.getInstance();
            this._config = Config.getInstance();
            this._streamNo = streamNo;
            this._startAudio = startAudio;
            this._previousVolume = startAudio;
            this._startRadio = startRadio;
            this._numChannels = numChannels;
            this.init();
        }
        private function init():void{
            switch (this._numChannels){
                case 1:
                    this._streamStatus = [false];
                    break;
                case 2:
                    this._streamStatus = [false, false];
                    break;
                case 3:
                    this._streamStatus = [false, false, false];
                    break;
                default:
                    this._debug.traceFatal("Radio:init(): invalid number of channels");
            };
            this._dataLocation = this._config.radioXMLLocation;
            this._streamURL = (this._streamURL = Config.getInstance()[("radioURLLocation_" + this._streamNo)]);
            this.refreshSec = Config.getInstance().radioInterval;
            this._mainVideo = new VideoDisplay("MAIN", "MAIN", 0, 0);
            this._mainVideo.addEventListener(VideoEvent.PLAYBACK_STARTED, this.handlePlaybackStarted);
            this.addChild(this._mainVideo);
            this.loadData();
            this._loadTimer = new Timer((this.refreshSec * 1000), 0);
            this._loadTimer.addEventListener(TimerEvent.TIMER, this.handleLoadTimer);
            this._loadTimer.start();
            this._isPlaying = false;
        }
        private function startRadio():void{
            Debug.getInstance().traceDebug("Radio.startRadio() called");
            this._mainVideo.startPlayback(this._streamURL, "live", 0, 0, "Akamai", 0);
        }
        public function stopRadio():void{
            Debug.getInstance().traceInfo("Radio:stopRadio() Called");
            this._startRadio = false;
            try {
                this._mainVideo.stopPlayback();
            } catch(error:Error) {
                Debug.getInstance().traceError(("radio.stopRadio: " + error));
            };
            this.sendStatusToExternal();
        }
        private function setVolume(value:Number):void{
            var volume:Number;
            if (value >= 1){
                volume = (value / 10);
            } else {
                volume = value;
            };
            this._mainVideo.setVolume(volume);
            ExternalInterface.call("volumeStatus", volume);
        }
        private function loadData():void{
            this._dataXML = new XML();
            var tempURL:String = Config.getInstance().radioXMLLocation;
            this._debug.traceDebug(("loadData: " + tempURL));
            this._dataURL = new URLRequest(tempURL);
            this._dataLoader = new URLLoader(this._dataURL);
            this._dataLoader.addEventListener(IOErrorEvent.IO_ERROR, this.ioErrorHandler);
            this._dataLoader.addEventListener(Event.COMPLETE, this.dataXmlLoaded);
        }
        private function dataXmlLoaded(e:Event):void{
            var e:* = e;
            this._dataLoader.removeEventListener("complete", this.dataXmlLoaded);
            try {
                this._dataXML = XML(this._dataLoader.data);
            } catch(e:Error) {
                Debug.getInstance().traceError(("Radio.dataXmlLoaded: XML Error, " + e));
            };
            Debug.getInstance().traceDebug(this._dataXML);
            switch (this._numChannels){
                case 1:
                    this._streamStatus[0] = (((this._dataXML.radioIsOn_0 == "true")) ? true : false);
                    break;
                case 2:
                    this._streamStatus[0] = (((this._dataXML.radioIsOn_0 == "true")) ? true : false);
                    this._streamStatus[1] = (((this._dataXML.radioIsOn_1 == "true")) ? true : false);
                    break;
                case 3:
                    this._streamStatus[0] = (((this._dataXML.radioIsOn_0 == "true")) ? true : false);
                    this._streamStatus[1] = (((this._dataXML.radioIsOn_1 == "true")) ? true : false);
                    this._streamStatus[2] = (((this._dataXML.radioIsOn_2 == "true")) ? true : false);
                    break;
                default:
                    this._debug.traceFatal("Radio:dataXmlLoaded(): invalid number of channels");
            };
            if (this._streamStatus[parseInt(this._streamNo)] == true){
                if (this._startRadio == true){
                    this.startRadio();
                };
            } else {
                this.stopRadio();
            };
            this._startRadio = false;
            this.sendStatusToExternal();
        }
        private function sendStatusToExternal():void{
            var statusForExternal_send:String;
            this._debug.traceDebug("sendStatusToExternal() Called");
            var statusForExternal:Array = [0, 0, 0];
            switch (this._numChannels){
                case 1:
                    if (this._streamStatus[0] == true){
                        if ((((this._streamNo == "0")) && ((this._mainVideo.isPlaying == true)))){
                            statusForExternal[0] = 2;
                        } else {
                            statusForExternal[0] = 1;
                        };
                    } else {
                        statusForExternal[0] = 0;
                    };
                    statusForExternal_send = statusForExternal[0].toString();
                    break;
                case 2:
                    if (this._streamStatus[0] == true){
                        if ((((this._streamNo == "0")) && ((this._mainVideo.isPlaying == true)))){
                            statusForExternal[0] = 2;
                        } else {
                            statusForExternal[0] = 1;
                        };
                    } else {
                        statusForExternal[0] = 0;
                    };
                    if (this._streamStatus[1] == true){
                        if ((((this._streamNo == "1")) && ((this._mainVideo.isPlaying == true)))){
                            statusForExternal[1] = 2;
                        } else {
                            statusForExternal[1] = 1;
                        };
                    } else {
                        statusForExternal[1] = 0;
                    };
                    statusForExternal_send = ((statusForExternal[0].toString() + ",") + statusForExternal[1].toString());
                    break;
                case 3:
                    if (this._streamStatus[0] == true){
                        if ((((this._streamNo == "0")) && ((this._mainVideo.isPlaying == true)))){
                            statusForExternal[0] = 2;
                        } else {
                            statusForExternal[0] = 1;
                        };
                    } else {
                        statusForExternal[0] = 0;
                    };
                    if (this._streamStatus[1] == true){
                        if ((((this._streamNo == "1")) && ((this._mainVideo.isPlaying == true)))){
                            statusForExternal[1] = 2;
                        } else {
                            statusForExternal[1] = 1;
                        };
                    } else {
                        statusForExternal[1] = 0;
                    };
                    if (this._streamStatus[2] == true){
                        if ((((this._streamNo == "2")) && ((this._mainVideo.isPlaying == true)))){
                            statusForExternal[2] = 2;
                        } else {
                            statusForExternal[2] = 1;
                        };
                    } else {
                        statusForExternal[2] = 0;
                    };
                    statusForExternal_send = ((((statusForExternal[0].toString() + ",") + statusForExternal[1].toString()) + ",") + statusForExternal[2].toString());
                    break;
                default:
                    this._debug.traceFatal("Radio:sendStatusToExternal(): invalid number of channels");
            };
            this._debug.traceDebug((("calling radioStatus(" + statusForExternal_send) + ")"));
            ExternalInterface.call("radioStatus", statusForExternal_send);
        }
        private function ioErrorHandler(e:IOErrorEvent):void{
            Debug.getInstance().traceError("Radio.ioErrorHandler: Error loading radio file");
        }
        public function doMute():void{
            Debug.getInstance().traceDebug("Radio.doMute");
            if (this._isMute == true){
                this.setVolume(this._previousVolume);
                this._isMute = false;
            } else {
                this.setVolume(0);
                this._isMute = true;
            };
        }
        public function volumeChangeUp():void{
            Debug.getInstance().traceDebug(("Radio.volumeChangeUp: " + this._previousVolume));
            if (this._isMute == true){
                this._previousVolume = 0;
            };
            if (this._previousVolume < 10){
                this._previousVolume++;
                this._isMute = false;
            };
            this.setVolume(this._previousVolume);
        }
        public function volumeChangeDown():void{
            Debug.getInstance().traceDebug(("Radio.volumeChangeDown: " + this._previousVolume));
            if (this._isMute == false){
                if (this._previousVolume > 0){
                    this._previousVolume--;
                };
                this.setVolume(this._previousVolume);
            };
        }
        public function muteVolume():void{
            this.doMute();
        }
        private function handleLoadTimer(e:TimerEvent):void{
            this.loadData();
        }
        public function channelButtonClicked(which:String):void{
            this._streamNo = which;
            if (this._streamStatus[parseInt(which)] == true){
                this._streamURL = Config.getInstance()[("radioURLLocation_" + this._streamNo)];
                if (this._mainVideo.isPlaying == true){
                    this.stopRadio();
                };
                this.startRadio();
            } else {
                this.sendStatusToExternal();
            };
        }
        private function handlePlaybackStarted(e:VideoEvent):void{
            Debug.getInstance().traceDebug("Radio.handlePlaybacyStarted() called");
            if (this._previousVolume > 0){
                this.setVolume(this._previousVolume);
            } else {
                this.setVolume(5);
            };
            this.sendStatusToExternal();
            ExternalInterface.call("playBackStarted");
        }

    }
}//package